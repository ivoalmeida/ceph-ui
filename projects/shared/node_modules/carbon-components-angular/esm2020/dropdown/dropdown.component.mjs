import { Component, Input, Output, EventEmitter, ContentChild, ViewChild, HostListener, HostBinding, TemplateRef } from "@angular/core";
import { NG_VALUE_ACCESSOR } from "@angular/forms";
// Observable import is required here so typescript can compile correctly
import { of, Subscription } from "rxjs";
import { AbstractDropdownView } from "./abstract-dropdown-view.class";
import { getScrollableParents } from "carbon-components-angular/utils";
import { hasScrollableParents } from "carbon-components-angular/utils";
import * as i0 from "@angular/core";
import * as i1 from "carbon-components-angular/i18n";
import * as i2 from "./dropdown.service";
import * as i3 from "carbon-components-angular/utils";
import * as i4 from "@angular/common";
import * as i5 from "carbon-components-angular/icon";
/**
 * Drop-down lists enable users to select one or more items from a list.
 *
 * #### Opening behavior/List DOM placement
 * By default the dropdown will try to figure out the best placement for the dropdown list.
 *
 * If it's not contained within any scrolling elements, it will open inline, if it _is_
 * contained within a scrolling container it will try to open in the body, or an `cds-placeholder`.
 *
 * To control this behavior you can use the `appendInline` input:
 * - `[appendInline]="null"` is the default (auto detection)
 * - `[appendInline]="false"` will always append to the body/`cds-placeholder`
 * - `[appendInline]="true"` will always append inline (next to the dropdown button)
 *
 * Get started with importing the module:
 *
 * ```typescript
 * import { DropdownModule } from 'carbon-components-angular';
 * ```
 *
 * [See demo](../../?path=/story/components-dropdown--basic)
 */
export class Dropdown {
    /**
     * Creates an instance of Dropdown.
     */
    constructor(elementRef, i18n, dropdownService, elementService) {
        this.elementRef = elementRef;
        this.i18n = i18n;
        this.dropdownService = dropdownService;
        this.elementService = elementService;
        this.id = `dropdown-${Dropdown.dropdownCount++}`;
        /**
         * Hide label while keeping it accessible for screen readers
         */
        this.hideLabel = false;
        /**
         * Value displayed if no item is selected.
         */
        this.placeholder = "";
        /**
         * The selected value from the `Dropdown`. Can be a string or template.
         */
        this.displayValue = "";
        /**
         * Sets the optional clear button tooltip text.
         */
        this.clearText = this.i18n.get().DROPDOWN.CLEAR;
        /**
         * Size to render the dropdown field.
         */
        this.size = "md";
        /**
         * Defines whether or not the `Dropdown` supports selecting multiple items as opposed to single
         * item selection.
         */
        this.type = "single";
        /**
         * @deprecated since v5 - Use `cdsLayer` directive instead
         * `light` or `dark` dropdown theme
         */
        this.theme = "dark";
        /**
         * Set to `true` to disable the dropdown.
         */
        this.disabled = false;
        /**
         * Set to `true` for a readonly state.
         */
        this.readonly = false;
        /**
         * Set to `true` for a loading dropdown.
         */
        this.skeleton = false;
        /**
         * Set to `true` for an inline dropdown.
         */
        this.inline = false;
        /**
         * Set to `true` for a dropdown without arrow key activation.
         */
        this.disableArrowKeys = false;
        /**
         * Set to `true` for invalid state.
         */
        this.invalid = false;
        /**
          * Set to `true` to show a warning (contents set by warningText)
          */
        this.warn = false;
        /**
         * set to `true` to place the dropdown view inline with the component
         */
        this.appendInline = null;
        /**
         * Specify feedback (mode) of the selection.
         * `top`: selected item jumps to top
         * `fixed`: selected item stays at it's position
         * `top-after-reopen`: selected item jump to top after reopen dropdown
         */
        this.selectionFeedback = "top-after-reopen";
        /**
         * Accessible label for the button that opens the dropdown list.
         * Defaults to the `DROPDOWN.OPEN` value from the i18n service.
         */
        this.menuButtonLabel = this.i18n.get().DROPDOWN.OPEN;
        /**
         * Provides the label for the "# selected" text.
         * Defaults to the `DROPDOWN.SELECTED` value from the i18n service.
         */
        this.selectedLabel = this.i18n.get().DROPDOWN.SELECTED;
        /**
         * Emits selection events.
         */
        this.selected = new EventEmitter();
        /**
         * Emits event notifying to other classes that the `Dropdown` has been closed (collapsed).
         */
        this.onClose = new EventEmitter();
        /**
         * Emits event notifying to other classes that the `Dropdown` has been closed (collapsed).
         */
        this.close = new EventEmitter();
        this.hostClass = true;
        this.hostWrapperClass = true;
        /**
         * Experimental: enable fluid state
         */
        this.fluid = false;
        /**
         * Set to `true` if the dropdown is closed (not expanded).
         */
        this.menuIsClosed = true;
        /**
         * controls whether the `drop-up` class is applied
         */
        this._dropUp = false;
        // .bind creates a new function, so we declare the methods below
        // but .bind them up here
        this.noop = this._noop.bind(this);
        this.outsideClick = this._outsideClick.bind(this);
        this.outsideKey = this._outsideKey.bind(this);
        this.keyboardNav = this._keyboardNav.bind(this);
        this.visibilitySubscription = new Subscription();
        this.onTouchedCallback = this._noop;
        this._isFocused = false;
        // primarily used to capture and propagate input to `writeValue` before the content is available
        this._writtenValue = [];
        /**
         * function passed in by `registerOnChange`
         */
        this.propagateChange = (_) => { };
    }
    get fluidInvalidClass() {
        return this.invalid && this.fluid;
    }
    get fluidFocusClass() {
        return this.fluid && this._isFocused && this.menuIsClosed;
    }
    get writtenValue() {
        return this._writtenValue;
    }
    set writtenValue(val) {
        if (val && val.length === 0) {
            this.clearSelected();
        }
        this._writtenValue = val;
    }
    /**
     * Updates the `type` property in the `@ContentChild`.
     * The `type` property specifies whether the `Dropdown` allows single selection or multi selection.
     */
    ngOnInit() {
        if (this.view) {
            this.view.type = this.type;
        }
    }
    /**
     * Initializes classes and subscribes to events for single or multi selection.
     */
    ngAfterContentInit() {
        if (!this.view) {
            return;
        }
        if ((this.writtenValue && this.writtenValue.length) || typeof this.writtenValue === "number") {
            this.writeValue(this.writtenValue);
        }
        this.view.type = this.type;
        this.view.size = this.size;
        // function to check if the event is organic (isUpdate === false) or programmatic
        const isUpdate = event => event && event.isUpdate;
        this.view.select.subscribe(event => {
            if (this.type === "single" && !isUpdate(event) && !Array.isArray(event)) {
                this.closeMenu();
                if (event.item && event.item.selected) {
                    if (this.itemValueKey) {
                        this.propagateChange(event.item[this.itemValueKey]);
                    }
                    else {
                        this.propagateChange(event.item);
                    }
                }
                else {
                    this.propagateChange(null);
                }
            }
            if (this.type === "multi" && !isUpdate(event)) {
                // if we have a `value` selector and selected items map them appropriately
                if (this.itemValueKey && this.view.getSelected()) {
                    const values = this.view.getSelected().map(item => item[this.itemValueKey]);
                    this.propagateChange(values);
                    // otherwise just pass up the values from `getSelected`
                }
                else {
                    this.propagateChange(this.view.getSelected());
                }
            }
            // only emit selected for "organic" selections
            if (!isUpdate(event)) {
                this.checkForReorder();
                this.selected.emit(event);
            }
        });
    }
    ngAfterViewInit() {
        // if appendInline is default valued (null) we should:
        // 1. if there are scrollable parents (not including body) don't append inline
        //    this should also cover the case where the dropdown is in a modal
        //    (where we _do_ want to append to the placeholder)
        if (this.appendInline === null && hasScrollableParents(this.elementRef.nativeElement)) {
            this.appendInline = false;
            // 2. otherwise we should append inline
        }
        else if (this.appendInline === null) {
            this.appendInline = true;
        }
        this.checkForReorder();
    }
    /**
     * Removing the `Dropdown` from the body if it is appended to the body.
     */
    ngOnDestroy() {
        if (!this.appendInline) {
            this._appendToDropdown();
        }
    }
    /**
     * Propagates the injected `value`.
     */
    writeValue(value) {
        // cache the written value so we can use it in `AfterContentInit`
        this.writtenValue = value;
        this.view.onItemsReady(() => {
            // propagate null/falsey as an array (deselect everything)
            if (!value) {
                this.view.propagateSelected([value]);
            }
            else if (this.type === "single") {
                if (this.itemValueKey) {
                    // clone the specified item and update its state
                    const newValue = Object.assign({}, this.view.getListItems().find(item => item[this.itemValueKey] === value));
                    newValue.selected = true;
                    this.view.propagateSelected([newValue]);
                }
                else {
                    // pass the singular value as an array of ListItem
                    this.view.propagateSelected([value]);
                }
            }
            else {
                if (this.itemValueKey) {
                    // clone the items and update their state based on the received value array
                    // this way we don't lose any additional metadata that may be passed in via the `items` Input
                    let newValues = [];
                    for (const v of value) {
                        for (const item of this.view.getListItems()) {
                            if (item[this.itemValueKey] === v) {
                                newValues.push(Object.assign({}, item, { selected: true }));
                            }
                        }
                    }
                    this.view.propagateSelected(newValues);
                }
                else {
                    // we can safely assume we're passing an array of `ListItem`s
                    this.view.propagateSelected(value);
                }
            }
            this.checkForReorder();
        });
    }
    onBlur() {
        this.onTouchedCallback();
    }
    registerOnChange(fn) {
        this.propagateChange = fn;
    }
    /**
     * Registering the function injected to control the touch use of the `Dropdown`.
     */
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    /**
     * `ControlValueAccessor` method to programmatically disable the dropdown.
     *
     * ex: `this.formGroup.get("myDropdown").disable();`
     *
     * @param isDisabled `true` to disable the input
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * Adds keyboard functionality for navigation, selection and closing of the `Dropdown`.
     */
    onKeyDown(event) {
        if (this.readonly) {
            return;
        }
        if ((event.key === "Escape") && !this.menuIsClosed) {
            event.stopImmediatePropagation(); // don't unintentionally close other widgets that listen for Escape
        }
        if (event.key === "Escape") {
            event.preventDefault();
            this.closeMenu();
            this.dropdownButton.nativeElement.focus();
        }
        else if (this.menuIsClosed && (event.key === " " || event.key === "ArrowDown" || event.key === "ArrowUp")) {
            if (this.disableArrowKeys && (event.key === "ArrowDown" || event.key === "ArrowUp")) {
                return;
            }
            event.preventDefault();
            this.openMenu();
        }
        if (!this.menuIsClosed && event.key === "Tab" && this.dropdownMenu.nativeElement.contains(event.target)) {
            this.closeMenu();
        }
        if (!this.menuIsClosed && event.key === "Tab" && event.shiftKey) {
            this.closeMenu();
        }
        if (this.type === "multi") {
            return;
        }
        if (this.menuIsClosed) {
            this.closedDropdownNavigation(event);
        }
    }
    closedDropdownNavigation(event) {
        if (event.key === "ArrowDown") {
            event.preventDefault();
            this.view.getCurrentItem().selected = false;
            let item = this.view.getNextItem();
            if (item) {
                item.selected = true;
            }
        }
        else if (event.key === "ArrowUp") {
            event.preventDefault();
            this.view.getCurrentItem().selected = false;
            let item = this.view.getPrevItem();
            if (item) {
                item.selected = true;
            }
        }
    }
    /**
     * Returns the display value if there is a selection and displayValue is set,
     * if there is just a selection the ListItem content property will be returned,
     * otherwise the placeholder will be returned.
     */
    getDisplayStringValue() {
        if (!this.view || this.skeleton) {
            return;
        }
        let selected = this.view.getSelected();
        if (selected.length && (!this.displayValue || !this.isRenderString())) {
            if (this.type === "multi") {
                return of(this.placeholder);
            }
            else {
                return of(selected[0].content);
            }
        }
        else if (selected.length && this.isRenderString()) {
            return of(this.displayValue);
        }
        return of(this.placeholder);
    }
    isRenderString() {
        return typeof this.displayValue === "string";
    }
    getRenderTemplateContext() {
        if (!this.view) {
            return;
        }
        let selected = this.view.getSelected();
        if (this.type === "multi") {
            return { items: selected };
        }
        else if (selected && selected.length > 0) {
            return { item: selected[0] }; // this is to be compatible with the dropdown-list template
        }
        else {
            return {};
        }
    }
    getSelectedCount() {
        if (this.view.getSelected()) {
            return this.view.getSelected().length;
        }
    }
    clearSelected() {
        if (this.disabled || this.getSelectedCount() === 0) {
            return;
        }
        for (const item of this.view.getListItems()) {
            item.selected = false;
        }
        this.selected.emit([]);
        this.propagateChange([]);
    }
    /**
     * Returns `true` if there is a value selected.
     */
    valueSelected() {
        if (this.view.getSelected()) {
            return true;
        }
        return false;
    }
    _noop() { }
    /**
     * Handles clicks outside of the `Dropdown`.
     */
    _outsideClick(event) {
        if (!this.elementRef.nativeElement.contains(event.target) &&
            // if we're appendToBody the list isn't within the _elementRef,
            // so we've got to check if our target is possibly in there too.
            !this.dropdownMenu.nativeElement.contains(event.target)) {
            this.closeMenu();
        }
    }
    _outsideKey(event) {
        if (!this.menuIsClosed && event.key === "Tab" && this.dropdownMenu.nativeElement.contains(event.target)) {
            this.closeMenu();
        }
    }
    /**
     * Handles keyboard events so users are controlling the `Dropdown` instead of unintentionally controlling outside elements.
     */
    _keyboardNav(event) {
        if (event.key === "Escape" && !this.menuIsClosed) {
            event.stopImmediatePropagation(); // don't unintentionally close modal if inside of it
        }
        if (event.key === "Escape") {
            event.preventDefault();
            this.closeMenu();
            this.dropdownButton.nativeElement.focus();
        }
        else if (!this.menuIsClosed && event.key === "Tab") {
            // this way focus will start on the next focusable item from the dropdown
            // not the top of the body!
            this.dropdownButton.nativeElement.focus();
            this.dropdownButton.nativeElement.dispatchEvent(new KeyboardEvent("keydown", { bubbles: true, cancelable: true, key: "Tab" }));
            this.closeMenu();
        }
    }
    /**
     * Creates the `Dropdown` list appending it to the dropdown parent object instead of the body.
     */
    _appendToDropdown() {
        this.dropdownService.appendToDropdown(this.elementRef.nativeElement);
        this.dropdownMenu.nativeElement.removeEventListener("keydown", this.keyboardNav, true);
    }
    /**
     * Creates the `Dropdown` list as an element that is appended to the DOM body.
     */
    _appendToBody() {
        const lightClass = this.theme === "light" ? " cds--list-box--light" : "";
        const expandedClass = !this.menuIsClosed ? " cds--list-box--expanded" : "";
        this.dropdownService.appendToBody(this.dropdownButton.nativeElement, this.dropdownMenu.nativeElement, `${this.elementRef.nativeElement.className}${lightClass}${expandedClass}`);
        this.dropdownMenu.nativeElement.addEventListener("keydown", this.keyboardNav, true);
    }
    /**
     * Detects whether or not the `Dropdown` list is visible within all scrollable parents.
     * This can be overridden by passing in a value to the `dropUp` input.
     */
    _shouldDropUp() {
        // check if dropdownMenu exists first.
        const menu = this.dropdownMenu && this.dropdownMenu.nativeElement.querySelector(".cds--list-box__menu");
        // check if menu exists first.
        const menuRect = menu && menu.getBoundingClientRect();
        if (menu && menuRect) {
            const scrollableParents = getScrollableParents(menu);
            return scrollableParents.reduce((shouldDropUp, parent) => {
                const parentRect = parent.getBoundingClientRect();
                const isBelowParent = !(menuRect.bottom <= parentRect.bottom);
                return shouldDropUp || isBelowParent;
            }, false);
        }
        return false;
    }
    /**
     * Expands the dropdown menu in the view.
     */
    openMenu() {
        // prevents the dropdown from opening when list of items is empty
        if (this.view.getListItems().length === 0) {
            return;
        }
        this._dropUp = false;
        this.menuIsClosed = false;
        // move the dropdown list to the body if we're not appending inline
        // and position it relative to the dropdown wrapper
        if (!this.appendInline) {
            const target = this.dropdownButton.nativeElement;
            const parent = this.elementRef.nativeElement;
            this.visibilitySubscription = this.elementService
                .visibility(target, parent)
                .subscribe(value => {
                if (!value.visible) {
                    this.closeMenu();
                }
            });
            this._appendToBody();
        }
        // set the dropdown menu to drop up if it's near the bottom of the screen
        // setTimeout lets us measure after it's visible in the DOM
        setTimeout(() => {
            if (this.dropUp === null || this.dropUp === undefined) {
                this._dropUp = this._shouldDropUp();
            }
        }, 0);
        // we bind noop to document.body.firstElementChild to allow safari to fire events
        // from document. Then we unbind everything later to keep things light.
        document.body.firstElementChild.addEventListener("click", this.noop, true);
        document.body.firstElementChild.addEventListener("keydown", this.noop, true);
        document.addEventListener("click", this.outsideClick, true);
        document.addEventListener("keydown", this.outsideKey, true);
        setTimeout(() => this.view.initFocus(), 0);
    }
    /**
     * Collapsing the dropdown menu and removing unnecessary `EventListeners`.
     */
    closeMenu() {
        // return early if the menu is already closed
        if (this.menuIsClosed) {
            return;
        }
        this.menuIsClosed = true;
        this.checkForReorder();
        this.onClose.emit();
        this.close.emit();
        // focus the trigger button when we close ...
        this.dropdownButton.nativeElement.focus();
        // remove the conditional once this api is settled and part of abstract-dropdown-view.class
        if (this.view["disableScroll"]) {
            this.view["disableScroll"]();
        }
        // move the list back in the component on close
        if (!this.appendInline) {
            this.visibilitySubscription.unsubscribe();
            this._appendToDropdown();
        }
        document.body.firstElementChild.removeEventListener("click", this.noop, true);
        document.body.firstElementChild.removeEventListener("keydown", this.noop, true);
        document.removeEventListener("click", this.outsideClick, true);
        document.removeEventListener("keydown", this.outsideKey, true);
    }
    /**
     * Controls toggling menu states between open/expanded and closed/collapsed.
     */
    toggleMenu() {
        if (this.menuIsClosed) {
            this.openMenu();
        }
        else {
            this.closeMenu();
        }
    }
    isTemplate(value) {
        return value instanceof TemplateRef;
    }
    handleFocus(event) {
        this._isFocused = event.type === "focus";
        if (event.type === "blur") {
            this.onBlur();
        }
    }
    /**
     * Controls when it's needed to apply the selection feedback
     */
    checkForReorder() {
        const topAfterReopen = this.menuIsClosed && this.selectionFeedback === "top-after-reopen";
        if ((this.type === "multi") && (topAfterReopen || this.selectionFeedback === "top")) {
            this.view.reorderSelected();
        }
    }
}
Dropdown.dropdownCount = 0;
Dropdown.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: Dropdown, deps: [{ token: i0.ElementRef }, { token: i1.I18n }, { token: i2.DropdownService }, { token: i3.ElementService }], target: i0.ɵɵFactoryTarget.Component });
Dropdown.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.3.0", type: Dropdown, selector: "cds-dropdown, ibm-dropdown", inputs: { id: "id", label: "label", hideLabel: "hideLabel", helperText: "helperText", placeholder: "placeholder", displayValue: "displayValue", clearText: "clearText", size: "size", type: "type", theme: "theme", disabled: "disabled", readonly: "readonly", skeleton: "skeleton", inline: "inline", disableArrowKeys: "disableArrowKeys", invalid: "invalid", invalidText: "invalidText", warn: "warn", warnText: "warnText", appendInline: "appendInline", scrollableContainer: "scrollableContainer", itemValueKey: "itemValueKey", selectionFeedback: "selectionFeedback", menuButtonLabel: "menuButtonLabel", selectedLabel: "selectedLabel", dropUp: "dropUp", fluid: "fluid" }, outputs: { selected: "selected", onClose: "onClose", close: "close" }, host: { listeners: { "keydown": "onKeyDown($event)" }, properties: { "class.cds--list-box__wrapper--fluid--invalid": "this.fluidInvalidClass", "class.cds--list-box__wrapper--fluid--focus": "this.fluidFocusClass", "class.cds--dropdown__wrapper": "this.hostClass", "class.cds--list-box__wrapper": "this.hostWrapperClass", "class.cds--list-box__wrapper--fluid": "this.fluid" } }, providers: [
        {
            provide: NG_VALUE_ACCESSOR,
            useExisting: Dropdown,
            multi: true
        }
    ], queries: [{ propertyName: "view", first: true, predicate: AbstractDropdownView, descendants: true, static: true }], viewQueries: [{ propertyName: "dropdownButton", first: true, predicate: ["dropdownButton"], descendants: true, static: true }, { propertyName: "dropdownMenu", first: true, predicate: ["dropdownMenu"], descendants: true, static: true }], ngImport: i0, template: `
	<label
		*ngIf="label && !skeleton"
		[for]="id"
		class="cds--label"
		[ngClass]="{
			'cds--label--disabled': disabled,
			'cds--visually-hidden': hideLabel
		}">
		<ng-container *ngIf="!isTemplate(label)">{{label}}</ng-container>
		<ng-template *ngIf="isTemplate(label)" [ngTemplateOutlet]="label"></ng-template>
	</label>
	<div
		class="cds--list-box"
		[ngClass]="{
			'cds--dropdown': type !== 'multi' && !(skeleton && fluid),
			'cds--multiselect': type === 'multi',
			'cds--multi-select--selected': type === 'multi' && getSelectedCount() > 0,
			'cds--dropdown--light': theme === 'light',
			'cds--list-box--light': theme === 'light',
			'cds--list-box--inline': inline,
			'cds--skeleton': skeleton,
			'cds--dropdown--disabled cds--list-box--disabled': disabled,
			'cds--dropdown--readonly': readonly,
			'cds--dropdown--invalid': invalid,
			'cds--dropdown--warning cds--list-box--warning': warn,
			'cds--dropdown--sm cds--list-box--sm': size === 'sm',
			'cds--dropdown--md cds--list-box--md': size === 'md',
			'cds--dropdown--lg cds--list-box--lg': size === 'lg',
			'cds--list-box--expanded': !menuIsClosed,
			'cds--list-box--invalid': invalid
		}"
		[attr.data-invalid]="invalid ? true : null">
		<div *ngIf="skeleton && fluid" class="cds--list-box__label"></div>
		<button
			#dropdownButton
			[id]="id"
			type="button"
			class="cds--list-box__field"
			[ngClass]="{'a': !menuIsClosed}"
			[attr.aria-expanded]="!menuIsClosed"
			[attr.aria-disabled]="disabled"
			[attr.aria-readonly]="readonly"
			aria-haspopup="listbox"
			(click)="disabled || readonly ? $event.stopPropagation() : toggleMenu()"
			(focus)="fluid ? handleFocus($event) : null"
			(blur)="fluid ? handleFocus($event) : onBlur()"
			[attr.disabled]="disabled ? true : null">
			<div
				(click)="clearSelected()"
				(keydown.enter)="clearSelected()"
				*ngIf="type === 'multi' && getSelectedCount() > 0"
				class="cds--list-box__selection cds--tag--filter cds--list-box__selection--multi"
				tabindex="0"
				[title]="clearText">
				{{getSelectedCount()}}
				<svg
					focusable="false"
					preserveAspectRatio="xMidYMid meet"
					style="will-change: transform;"
					role="img"
					xmlns="http://www.w3.org/2000/svg"
					width="16"
					height="16"
					viewBox="0 0 16 16"
					aria-hidden="true">
					<path d="M12 4.7l-.7-.7L8 7.3 4.7 4l-.7.7L7.3 8 4 11.3l.7.7L8 8.7l3.3 3.3.7-.7L8.7 8z"></path>
				</svg>
			</div>
			<span *ngIf="isRenderString()" class="cds--list-box__label">{{getDisplayStringValue() | async}}</span>
			<ng-template
				*ngIf="!isRenderString()"
				[ngTemplateOutletContext]="getRenderTemplateContext()"
				[ngTemplateOutlet]="displayValue">
			</ng-template>
			<span class="cds--list-box__menu-icon">
				<svg
					*ngIf="!skeleton"
					cdsIcon="chevron--down"
					size="16"
					[attr.aria-label]="menuButtonLabel"
					[ngClass]="{'cds--list-box__menu-icon--open': !menuIsClosed }">
				</svg>
			</span>
		</button>
		<svg
			*ngIf="invalid"
			class="cds--list-box__invalid-icon"
			cdsIcon="warning--filled"
			size="16">
		</svg>
		<svg
			*ngIf="!invalid && warn"
			cdsIcon="warning--alt--filled"
			size="16"
			class="cds--list-box__invalid-icon cds--list-box__invalid-icon--warning">
		</svg>
		<div
			#dropdownMenu
			[ngClass]="{
				'cds--list-box--up': this.dropUp !== null && this.dropUp !== undefined ? dropUp : _dropUp
			}">
			<ng-content *ngIf="!menuIsClosed"></ng-content>
		</div>
	</div>
	<hr *ngIf="fluid" class="cds--list-box__divider" />
	<div
		*ngIf="helperText && !invalid && !warn && !skeleton && !fluid"
		class="cds--form__helper-text"
		[ngClass]="{
			'cds--form__helper-text--disabled': disabled
		}">
		<ng-container *ngIf="!isTemplate(helperText)">{{helperText}}</ng-container>
		<ng-template *ngIf="isTemplate(helperText)" [ngTemplateOutlet]="helperText"></ng-template>
	</div>
	<div *ngIf="invalid" class="cds--form-requirement">
		<ng-container *ngIf="!isTemplate(invalidText)">{{ invalidText }}</ng-container>
		<ng-template *ngIf="isTemplate(invalidText)" [ngTemplateOutlet]="invalidText"></ng-template>
	</div>
	<div *ngIf="!invalid && warn" class="cds--form-requirement">
		<ng-container *ngIf="!isTemplate(warnText)">{{warnText}}</ng-container>
		<ng-template *ngIf="isTemplate(warnText)" [ngTemplateOutlet]="warnText"></ng-template>
	</div>
	`, isInline: true, dependencies: [{ kind: "directive", type: i4.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i4.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i4.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: i5.IconDirective, selector: "[cdsIcon], [ibmIcon]", inputs: ["ibmIcon", "cdsIcon", "size", "title", "ariaLabel", "ariaLabelledBy", "ariaHidden", "isFocusable"] }, { kind: "pipe", type: i4.AsyncPipe, name: "async" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: Dropdown, decorators: [{
            type: Component,
            args: [{
                    selector: "cds-dropdown, ibm-dropdown",
                    template: `
	<label
		*ngIf="label && !skeleton"
		[for]="id"
		class="cds--label"
		[ngClass]="{
			'cds--label--disabled': disabled,
			'cds--visually-hidden': hideLabel
		}">
		<ng-container *ngIf="!isTemplate(label)">{{label}}</ng-container>
		<ng-template *ngIf="isTemplate(label)" [ngTemplateOutlet]="label"></ng-template>
	</label>
	<div
		class="cds--list-box"
		[ngClass]="{
			'cds--dropdown': type !== 'multi' && !(skeleton && fluid),
			'cds--multiselect': type === 'multi',
			'cds--multi-select--selected': type === 'multi' && getSelectedCount() > 0,
			'cds--dropdown--light': theme === 'light',
			'cds--list-box--light': theme === 'light',
			'cds--list-box--inline': inline,
			'cds--skeleton': skeleton,
			'cds--dropdown--disabled cds--list-box--disabled': disabled,
			'cds--dropdown--readonly': readonly,
			'cds--dropdown--invalid': invalid,
			'cds--dropdown--warning cds--list-box--warning': warn,
			'cds--dropdown--sm cds--list-box--sm': size === 'sm',
			'cds--dropdown--md cds--list-box--md': size === 'md',
			'cds--dropdown--lg cds--list-box--lg': size === 'lg',
			'cds--list-box--expanded': !menuIsClosed,
			'cds--list-box--invalid': invalid
		}"
		[attr.data-invalid]="invalid ? true : null">
		<div *ngIf="skeleton && fluid" class="cds--list-box__label"></div>
		<button
			#dropdownButton
			[id]="id"
			type="button"
			class="cds--list-box__field"
			[ngClass]="{'a': !menuIsClosed}"
			[attr.aria-expanded]="!menuIsClosed"
			[attr.aria-disabled]="disabled"
			[attr.aria-readonly]="readonly"
			aria-haspopup="listbox"
			(click)="disabled || readonly ? $event.stopPropagation() : toggleMenu()"
			(focus)="fluid ? handleFocus($event) : null"
			(blur)="fluid ? handleFocus($event) : onBlur()"
			[attr.disabled]="disabled ? true : null">
			<div
				(click)="clearSelected()"
				(keydown.enter)="clearSelected()"
				*ngIf="type === 'multi' && getSelectedCount() > 0"
				class="cds--list-box__selection cds--tag--filter cds--list-box__selection--multi"
				tabindex="0"
				[title]="clearText">
				{{getSelectedCount()}}
				<svg
					focusable="false"
					preserveAspectRatio="xMidYMid meet"
					style="will-change: transform;"
					role="img"
					xmlns="http://www.w3.org/2000/svg"
					width="16"
					height="16"
					viewBox="0 0 16 16"
					aria-hidden="true">
					<path d="M12 4.7l-.7-.7L8 7.3 4.7 4l-.7.7L7.3 8 4 11.3l.7.7L8 8.7l3.3 3.3.7-.7L8.7 8z"></path>
				</svg>
			</div>
			<span *ngIf="isRenderString()" class="cds--list-box__label">{{getDisplayStringValue() | async}}</span>
			<ng-template
				*ngIf="!isRenderString()"
				[ngTemplateOutletContext]="getRenderTemplateContext()"
				[ngTemplateOutlet]="displayValue">
			</ng-template>
			<span class="cds--list-box__menu-icon">
				<svg
					*ngIf="!skeleton"
					cdsIcon="chevron--down"
					size="16"
					[attr.aria-label]="menuButtonLabel"
					[ngClass]="{'cds--list-box__menu-icon--open': !menuIsClosed }">
				</svg>
			</span>
		</button>
		<svg
			*ngIf="invalid"
			class="cds--list-box__invalid-icon"
			cdsIcon="warning--filled"
			size="16">
		</svg>
		<svg
			*ngIf="!invalid && warn"
			cdsIcon="warning--alt--filled"
			size="16"
			class="cds--list-box__invalid-icon cds--list-box__invalid-icon--warning">
		</svg>
		<div
			#dropdownMenu
			[ngClass]="{
				'cds--list-box--up': this.dropUp !== null && this.dropUp !== undefined ? dropUp : _dropUp
			}">
			<ng-content *ngIf="!menuIsClosed"></ng-content>
		</div>
	</div>
	<hr *ngIf="fluid" class="cds--list-box__divider" />
	<div
		*ngIf="helperText && !invalid && !warn && !skeleton && !fluid"
		class="cds--form__helper-text"
		[ngClass]="{
			'cds--form__helper-text--disabled': disabled
		}">
		<ng-container *ngIf="!isTemplate(helperText)">{{helperText}}</ng-container>
		<ng-template *ngIf="isTemplate(helperText)" [ngTemplateOutlet]="helperText"></ng-template>
	</div>
	<div *ngIf="invalid" class="cds--form-requirement">
		<ng-container *ngIf="!isTemplate(invalidText)">{{ invalidText }}</ng-container>
		<ng-template *ngIf="isTemplate(invalidText)" [ngTemplateOutlet]="invalidText"></ng-template>
	</div>
	<div *ngIf="!invalid && warn" class="cds--form-requirement">
		<ng-container *ngIf="!isTemplate(warnText)">{{warnText}}</ng-container>
		<ng-template *ngIf="isTemplate(warnText)" [ngTemplateOutlet]="warnText"></ng-template>
	</div>
	`,
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: Dropdown,
                            multi: true
                        }
                    ]
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i1.I18n }, { type: i2.DropdownService }, { type: i3.ElementService }]; }, propDecorators: { fluidInvalidClass: [{
                type: HostBinding,
                args: ["class.cds--list-box__wrapper--fluid--invalid"]
            }], fluidFocusClass: [{
                type: HostBinding,
                args: ["class.cds--list-box__wrapper--fluid--focus"]
            }], id: [{
                type: Input
            }], label: [{
                type: Input
            }], hideLabel: [{
                type: Input
            }], helperText: [{
                type: Input
            }], placeholder: [{
                type: Input
            }], displayValue: [{
                type: Input
            }], clearText: [{
                type: Input
            }], size: [{
                type: Input
            }], type: [{
                type: Input
            }], theme: [{
                type: Input
            }], disabled: [{
                type: Input
            }], readonly: [{
                type: Input
            }], skeleton: [{
                type: Input
            }], inline: [{
                type: Input
            }], disableArrowKeys: [{
                type: Input
            }], invalid: [{
                type: Input
            }], invalidText: [{
                type: Input
            }], warn: [{
                type: Input
            }], warnText: [{
                type: Input
            }], appendInline: [{
                type: Input
            }], scrollableContainer: [{
                type: Input
            }], itemValueKey: [{
                type: Input
            }], selectionFeedback: [{
                type: Input
            }], menuButtonLabel: [{
                type: Input
            }], selectedLabel: [{
                type: Input
            }], dropUp: [{
                type: Input
            }], selected: [{
                type: Output
            }], onClose: [{
                type: Output
            }], close: [{
                type: Output
            }], view: [{
                type: ContentChild,
                args: [AbstractDropdownView, { static: true }]
            }], dropdownButton: [{
                type: ViewChild,
                args: ["dropdownButton", { static: true }]
            }], dropdownMenu: [{
                type: ViewChild,
                args: ["dropdownMenu", { static: true }]
            }], hostClass: [{
                type: HostBinding,
                args: ["class.cds--dropdown__wrapper"]
            }], hostWrapperClass: [{
                type: HostBinding,
                args: ["class.cds--list-box__wrapper"]
            }], fluid: [{
                type: HostBinding,
                args: ["class.cds--list-box__wrapper--fluid"]
            }, {
                type: Input
            }], onKeyDown: [{
                type: HostListener,
                args: ["keydown", ["$event"]]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHJvcGRvd24uY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2Ryb3Bkb3duL2Ryb3Bkb3duLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ04sU0FBUyxFQUNULEtBQUssRUFDTCxNQUFNLEVBQ04sWUFBWSxFQUVaLFlBQVksRUFFWixTQUFTLEVBRVQsWUFBWSxFQUVaLFdBQVcsRUFDWCxXQUFXLEVBRVgsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLGlCQUFpQixFQUF3QixNQUFNLGdCQUFnQixDQUFDO0FBRXpFLHlFQUF5RTtBQUN6RSxPQUFPLEVBRU4sRUFBRSxFQUNGLFlBQVksRUFDWixNQUFNLE1BQU0sQ0FBQztBQUVkLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLGdDQUFnQyxDQUFDO0FBSXRFLE9BQU8sRUFBa0Isb0JBQW9CLEVBQUUsTUFBTSxpQ0FBaUMsQ0FBQztBQUN2RixPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxpQ0FBaUMsQ0FBQzs7Ozs7OztBQUV2RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBcUJHO0FBdUlILE1BQU0sT0FBTyxRQUFRO0lBOExwQjs7T0FFRztJQUNILFlBQ1csVUFBc0IsRUFDdEIsSUFBVSxFQUNWLGVBQWdDLEVBQ2hDLGNBQThCO1FBSDlCLGVBQVUsR0FBVixVQUFVLENBQVk7UUFDdEIsU0FBSSxHQUFKLElBQUksQ0FBTTtRQUNWLG9CQUFlLEdBQWYsZUFBZSxDQUFpQjtRQUNoQyxtQkFBYyxHQUFkLGNBQWMsQ0FBZ0I7UUFoTGhDLE9BQUUsR0FBRyxZQUFZLFFBQVEsQ0FBQyxhQUFhLEVBQUUsRUFBRSxDQUFDO1FBS3JEOztXQUVHO1FBQ00sY0FBUyxHQUFHLEtBQUssQ0FBQztRQUszQjs7V0FFRztRQUNNLGdCQUFXLEdBQUcsRUFBRSxDQUFDO1FBQzFCOztXQUVHO1FBQ00saUJBQVksR0FBOEIsRUFBRSxDQUFD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QUFFLE1BQU0sRUFBRSxJQUFJLEVBQUU7Z0JBSUwsY0FBYztzQkFBNUQsU0FBUzt1QkFBQyxnQkFBZ0IsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUU7Z0JBSUEsWUFBWTtzQkFBeEQsU0FBUzt1QkFBQyxjQUFjLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFO2dCQUVFLFNBQVM7c0JBQXJELFdBQVc7dUJBQUMsOEJBQThCO2dCQUVFLGdCQUFnQjtzQkFBNUQsV0FBVzt1QkFBQyw4QkFBOEI7Z0JBSWtCLEtBQUs7c0JBQWpFLFdBQVc7dUJBQUMscUNBQXFDOztzQkFBRyxLQUFLO2dCQW1NMUQsU0FBUztzQkFEUixZQUFZO3VCQUFDLFNBQVMsRUFBRSxDQUFDLFFBQVEsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG5cdENvbXBvbmVudCxcblx0SW5wdXQsXG5cdE91dHB1dCxcblx0RXZlbnRFbWl0dGVyLFxuXHRFbGVtZW50UmVmLFxuXHRDb250ZW50Q2hpbGQsXG5cdE9uSW5pdCxcblx0Vmlld0NoaWxkLFxuXHRBZnRlckNvbnRlbnRJbml0LFxuXHRIb3N0TGlzdGVuZXIsXG5cdE9uRGVzdHJveSxcblx0SG9zdEJpbmRpbmcsXG5cdFRlbXBsYXRlUmVmLFxuXHRBZnRlclZpZXdJbml0XG59IGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XG5pbXBvcnQgeyBOR19WQUxVRV9BQ0NFU1NPUiwgQ29udHJvbFZhbHVlQWNjZXNzb3IgfSBmcm9tIFwiQGFuZ3VsYXIvZm9ybXNcIjtcblxuLy8gT2JzZXJ2YWJsZSBpbXBvcnQgaXMgcmVxdWlyZWQgaGVyZSBzbyB0eXBlc2NyaXB0IGNhbiBjb21waWxlIGNvcnJlY3RseVxuaW1wb3J0IHtcblx0T2JzZXJ2YWJsZSxcblx0b2YsXG5cdFN1YnNjcmlwdGlvblxufSBmcm9tIFwicnhqc1wiO1xuXG5pbXBvcnQgeyBBYnN0cmFjdERyb3Bkb3duVmlldyB9IGZyb20gXCIuL2Fic3RyYWN0LWRyb3Bkb3duLXZpZXcuY2xhc3NcIjtcbmltcG9ydCB7IEkxOG4gfSBmcm9tIFwiY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci9pMThuXCI7XG5pbXBvcnQgeyBMaXN0SXRlbSB9IGZyb20gXCIuL2xpc3QtaXRlbS5pbnRlcmZhY2VcIjtcbmltcG9ydCB7IERyb3Bkb3duU2VydmljZSB9IGZyb20gXCIuL2Ryb3Bkb3duLnNlcnZpY2VcIjtcbmltcG9ydCB7IEVsZW1lbnRTZXJ2aWNlLCBnZXRTY3JvbGxhYmxlUGFyZW50cyB9IGZyb20gXCJjYXJib24tY29tcG9uZW50cy1hbmd1bGFyL3V0aWxzXCI7XG5pbXBvcnQgeyBoYXNTY3JvbGxhYmxlUGFyZW50cyB9IGZyb20gXCJjYXJib24tY29tcG9uZW50cy1hbmd1bGFyL3V0aWxzXCI7XG5cbi8qKlxuICogRHJvcC1kb3duIGxpc3RzIGVuYWJsZSB1c2VycyB0byBzZWxlY3Qgb25lIG9yIG1vcmUgaXRlbXMgZnJvbSBhIGxpc3QuXG4gKlxuICogIyMjIyBPcGVuaW5nIGJlaGF2aW9yL0xpc3QgRE9NIHBsYWNlbWVudFxuICogQnkgZGVmYXVsdCB0aGUgZHJvcGRvd24gd2lsbCB0cnkgdG8gZmlndXJlIG91dCB0aGUgYmVzdCBwbGFjZW1lbnQgZm9yIHRoZSBkcm9wZG93biBsaXN0LlxuICpcbiAqIElmIGl0J3Mgbm90IGNvbnRhaW5lZCB3aXRoaW4gYW55IHNjcm9sbGluZyBlbGVtZW50cywgaXQgd2lsbCBvcGVuIGlubGluZSwgaWYgaXQgX2lzX1xuICogY29udGFpbmVkIHdpdGhpbiBhIHNjcm9sbGluZyBjb250YWluZXIgaXQgd2lsbCB0cnkgdG8gb3BlbiBpbiB0aGUgYm9keSwgb3IgYW4gYGNkcy1wbGFjZWhvbGRlcmAuXG4gKlxuICogVG8gY29udHJvbCB0aGlzIGJlaGF2aW9yIHlvdSBjYW4gdXNlIHRoZSBgYXBwZW5kSW5saW5lYCBpbnB1dDpcbiAqIC0gYFthcHBlbmRJbmxpbmVdPVwibnVsbFwiYCBpcyB0aGUgZGVmYXVsdCAoYXV0byBkZXRlY3Rpb24pXG4gKiAtIGBbYXBwZW5kSW5saW5lXT1cImZhbHNlXCJgIHdpbGwgYWx3YXlzIGFwcGVuZCB0byB0aGUgYm9keS9gY2RzLXBsYWNlaG9sZGVyYFxuICogLSBgW2FwcGVuZElubGluZV09XCJ0cnVlXCJgIHdpbGwgYWx3YXlzIGFwcGVuZCBpbmxpbmUgKG5leHQgdG8gdGhlIGRyb3Bkb3duIGJ1dHRvbilcbiAqXG4gKiBHZXQgc3RhcnRlZCB3aXRoIGltcG9ydGluZyB0aGUgbW9kdWxlOlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IERyb3Bkb3duTW9kdWxlIH0gZnJvbSAnY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhcic7XG4gKiBgYGBcbiAqXG4gKiBbU2VlIGRlbW9dKC4uLy4uLz9wYXRoPS9zdG9yeS9jb21wb25lbnRzLWRyb3Bkb3duLS1iYXNpYylcbiAqL1xuQENvbXBvbmVudCh7XG5cdHNlbGVjdG9yOiBcImNkcy1kcm9wZG93biwgaWJtLWRyb3Bkb3duXCIsXG5cdHRlbXBsYXRlOiBgXG5cdDxsYWJlbFxuXHRcdCpuZ0lmPVwibGFiZWwgJiYgIXNrZWxldG9uXCJcblx0XHRbZm9yXT1cImlkXCJcblx0XHRjbGFzcz1cImNkcy0tbGFiZWxcIlxuXHRcdFtuZ0NsYXNzXT1cIntcblx0XHRcdCdjZHMtLWxhYmVsLS1kaXNhYmxlZCc6IGRpc2FibGVkLFxuXHRcdFx0J2Nkcy0tdmlzdWFsbHktaGlkZGVuJzogaGlkZUxhYmVsXG5cdFx0fVwiPlxuXHRcdDxuZy1jb250YWluZXIgKm5nSWY9XCIhaXNUZW1wbGF0ZShsYWJlbClcIj57e2xhYmVsfX08L25nLWNvbnRhaW5lcj5cblx0XHQ8bmctdGVtcGxhdGUgKm5nSWY9XCJpc1RlbXBsYXRlKGxhYmVsKVwiIFtuZ1RlbXBsYXRlT3V0bGV0XT1cImxhYmVsXCI+PC9uZy10ZW1wbGF0ZT5cblx0PC9sYWJlbD5cblx0PGRpdlxuXHRcdGNsYXNzPVwiY2RzLS1saXN0LWJveFwiXG5cdFx0W25nQ2xhc3NdPVwie1xuXHRcdFx0J2Nkcy0tZHJvcGRvd24nOiB0eXBlICE9PSAnbXVsdGknICYmICEoc2tlbGV0b24gJiYgZmx1aWQpLFxuXHRcdFx0J2Nkcy0tbXVsdGlzZWxlY3QnOiB0eXBlID09PSAnbXVsdGknLFxuXHRcdFx0J2Nkcy0tbXVsdGktc2VsZWN0LS1zZWxlY3RlZCc6IHR5cGUgPT09ICdtdWx0aScgJiYgZ2V0U2VsZWN0ZWRDb3VudCgpID4gMCxcblx0XHRcdCdjZHMtLWRyb3Bkb3duLS1saWdodCc6IHRoZW1lID09PSAnbGlnaHQnLFxuXHRcdFx0J2Nkcy0tbGlzdC1ib3gtLWxpZ2h0JzogdGhlbWUgPT09ICdsaWdodCcsXG5cdFx0XHQnY2RzLS1saXN0LWJveC0taW5saW5lJzogaW5saW5lLFxuXHRcdFx0J2Nkcy0tc2tlbGV0b24nOiBza2VsZXRvbixcblx0XHRcdCdjZHMtLWRyb3Bkb3duLS1kaXNhYmxlZCBjZHMtLWxpc3QtYm94LS1kaXNhYmxlZCc6IGRpc2FibGVkLFxuXHRcdFx0J2Nkcy0tZHJvcGRvd24tLXJlYWRvbmx5JzogcmVhZG9ubHksXG5cdFx0XHQnY2RzLS1kcm9wZG93bi0taW52YWxpZCc6IGludmFsaWQsXG5cdFx0XHQnY2RzLS1kcm9wZG93bi0td2FybmluZyBjZHMtLWxpc3QtYm94LS13YXJuaW5nJzogd2Fybixcblx0XHRcdCdjZHMtLWRyb3Bkb3duLS1zbSBjZHMtLWxpc3QtYm94LS1zbSc6IHNpemUgPT09ICdzbScsXG5cdFx0XHQnY2RzLS1kcm9wZG93bi0tbWQgY2RzLS1saXN0LWJveC0tbWQnOiBzaXplID09PSAnbWQnLFxuXHRcdFx0J2Nkcy0tZHJvcGRvd24tLWxnIGNkcy0tbGlzdC1ib3gtLWxnJzogc2l6ZSA9PT0gJ2xnJyxcblx0XHRcdCdjZHMtLWxpc3QtYm94LS1leHBhbmRlZCc6ICFtZW51SXNDbG9zZWQsXG5cdFx0XHQnY2RzLS1saXN0LWJveC0taW52YWxpZCc6IGludmFsaWRcblx0XHR9XCJcblx0XHRbYXR0ci5kYXRhLWludmFsaWRdPVwiaW52YWxpZCA/IHRydWUgOiBudWxsXCI+XG5cdFx0PGRpdiAqbmdJZj1cInNrZWxldG9uICYmIGZsdWlkXCIgY2xhc3M9XCJjZHMtLWxpc3QtYm94X19sYWJlbFwiPjwvZGl2PlxuXHRcdDxidXR0b25cblx0XHRcdCNkcm9wZG93bkJ1dHRvblxuXHRcdFx0W2lkXT1cImlkXCJcblx0XHRcdHR5cGU9XCJidXR0b25cIlxuXHRcdFx0Y2xhc3M9XCJjZHMtLWxpc3QtYm94X19maWVsZFwiXG5cdFx0XHRbbmdDbGFzc109XCJ7J2EnOiAhbWVudUlzQ2xvc2VkfVwiXG5cdFx0XHRbYXR0ci5hcmlhLWV4cGFuZGVkXT1cIiFtZW51SXNDbG9zZWRcIlxuXHRcdFx0W2F0dHIuYXJpYS1kaXNhYmxlZF09XCJkaXNhYmxlZFwiXG5cdFx0XHRbYXR0ci5hcmlhLXJlYWRvbmx5XT1cInJlYWRvbmx5XCJcblx0XHRcdGFyaWEtaGFzcG9wdXA9XCJsaXN0Ym94XCJcblx0XHRcdChjbGljayk9XCJkaXNhYmxlZCB8fCByZWFkb25seSA/ICRldmVudC5zdG9wUHJvcGFnYXRpb24oKSA6IHRvZ2dsZU1lbnUoKVwiXG5cdFx0XHQoZm9jdXMpPVwiZmx1aWQgPyBoYW5kbGVGb2N1cygkZXZlbnQpIDogbnVsbFwiXG5cdFx0XHQoYmx1cik9XCJmbHVpZCA/IGhhbmRsZUZvY3VzKCRldmVudCkgOiBvbkJsdXIoKVwiXG5cdFx0XHRbYXR0ci5kaXNhYmxlZF09XCJkaXNhYmxlZCA/IHRydWUgOiBudWxsXCI+XG5cdFx0XHQ8ZGl2XG5cdFx0XHRcdChjbGljayk9XCJjbGVhclNlbGVjdGVkKClcIlxuXHRcdFx0XHQoa2V5ZG93bi5lbnRlcik9XCJjbGVhclNlbGVjdGVkKClcIlxuXHRcdFx0XHQqbmdJZj1cInR5cGUgPT09ICdtdWx0aScgJiYgZ2V0U2VsZWN0ZWRDb3VudCgpID4gMFwiXG5cdFx0XHRcdGNsYXNzPVwiY2RzLS1saXN0LWJveF9fc2VsZWN0aW9uIGNkcy0tdGFnLS1maWx0ZXIgY2RzLS1saXN0LWJveF9fc2VsZWN0aW9uLS1tdWx0aVwiXG5cdFx0XHRcdHRhYmluZGV4PVwiMFwiXG5cdFx0XHRcdFt0aXRsZV09XCJjbGVhclRleHRcIj5cblx0XHRcdFx0e3tnZXRTZWxlY3RlZENvdW50KCl9fVxuXHRcdFx0XHQ8c3ZnXG5cdFx0XHRcdFx0Zm9jdXNhYmxlPVwiZmFsc2VcIlxuXHRcdFx0XHRcdHByZXNlcnZlQXNwZWN0UmF0aW89XCJ4TWlkWU1pZCBtZWV0XCJcblx0XHRcdFx0XHRzdHlsZT1cIndpbGwtY2hhbmdlOiB0cmFuc2Zvcm07XCJcblx0XHRcdFx0XHRyb2xlPVwiaW1nXCJcblx0XHRcdFx0XHR4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcblx0XHRcdFx0XHR3aWR0aD1cIjE2XCJcblx0XHRcdFx0XHRoZWlnaHQ9XCIxNlwiXG5cdFx0XHRcdFx0dmlld0JveD1cIjAgMCAxNiAxNlwiXG5cdFx0XHRcdFx0YXJpYS1oaWRkZW49XCJ0cnVlXCI+XG5cdFx0XHRcdFx0PHBhdGggZD1cIk0xMiA0LjdsLS43LS43TDggNy4zIDQuNyA0bC0uNy43TDcuMyA4IDQgMTEuM2wuNy43TDggOC43bDMuMyAzLjMuNy0uN0w4LjcgOHpcIj48L3BhdGg+XG5cdFx0XHRcdDwvc3ZnPlxuXHRcdFx0PC9kaXY+XG5cdFx0XHQ8c3BhbiAqbmdJZj1cImlzUmVuZGVyU3RyaW5nKClcIiBjbGFzcz1cImNkcy0tbGlzdC1ib3hfX2xhYmVsXCI+e3tnZXREaXNwbGF5U3RyaW5nVmFsdWUoKSB8IGFzeW5jfX08L3NwYW4+XG5cdFx0XHQ8bmctdGVtcGxhdGVcblx0XHRcdFx0Km5nSWY9XCIhaXNSZW5kZXJTdHJpbmcoKVwiXG5cdFx0XHRcdFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJnZXRSZW5kZXJUZW1wbGF0ZUNvbnRleHQoKVwiXG5cdFx0XHRcdFtuZ1RlbXBsYXRlT3V0bGV0XT1cImRpc3BsYXlWYWx1ZVwiPlxuXHRcdFx0PC9uZy10ZW1wbGF0ZT5cblx0XHRcdDxzcGFuIGNsYXNzPVwiY2RzLS1saXN0LWJveF9fbWVudS1pY29uXCI+XG5cdFx0XHRcdDxzdmdcblx0XHRcdFx0XHQqbmdJZj1cIiFza2VsZXRvblwiXG5cdFx0XHRcdFx0Y2RzSWNvbj1cImNoZXZyb24tLWRvd25cIlxuXHRcdFx0XHRcdHNpemU9XCIxNlwiXG5cdFx0XHRcdFx0W2F0dHIuYXJpYS1sYWJlbF09XCJtZW51QnV0dG9uTGFiZWxcIlxuXHRcdFx0XHRcdFtuZ0NsYXNzXT1cInsnY2RzLS1saXN0LWJveF9fbWVudS1pY29uLS1vcGVuJzogIW1lbnVJc0Nsb3NlZCB9XCI+XG5cdFx0XHRcdDwvc3ZnPlxuXHRcdFx0PC9zcGFuPlxuXHRcdDwvYnV0dG9uPlxuXHRcdDxzdmdcblx0XHRcdCpuZ0lmPVwiaW52YWxpZFwiXG5cdFx0XHRjbGFzcz1cImNkcy0tbGlzdC1ib3hfX2ludmFsaWQtaWNvblwiXG5cdFx0XHRjZHNJY29uPVwid2FybmluZy0tZmlsbGVkXCJcblx0XHRcdHNpemU9XCIxNlwiPlxuXHRcdDwvc3ZnPlxuXHRcdDxzdmdcblx0XHRcdCpuZ0lmPVwiIWludmFsaWQgJiYgd2FyblwiXG5cdFx0XHRjZHNJY29uPVwid2FybmluZy0tYWx0LS1maWxsZWRcIlxuXHRcdFx0c2l6ZT1cIjE2XCJcblx0XHRcdGNsYXNzPVwiY2RzLS1saXN0LWJveF9faW52YWxpZC1pY29uIGNkcy0tbGlzdC1ib3hfX2ludmFsaWQtaWNvbi0td2FybmluZ1wiPlxuXHRcdDwvc3ZnPlxuXHRcdDxkaXZcblx0XHRcdCNkcm9wZG93bk1lbnVcblx0XHRcdFtuZ0NsYXNzXT1cIntcblx0XHRcdFx0J2Nkcy0tbGlzdC1ib3gtLXVwJzogdGhpcy5kcm9wVXAgIT09IG51bGwgJiYgdGhpcy5kcm9wVXAgIT09IHVuZGVmaW5lZCA/IGRyb3BVcCA6IF9kcm9wVXBcblx0XHRcdH1cIj5cblx0XHRcdDxuZy1jb250ZW50ICpuZ0lmPVwiIW1lbnVJc0Nsb3NlZFwiPjwvbmctY29udGVudD5cblx0XHQ8L2Rpdj5cblx0PC9kaXY+XG5cdDxociAqbmdJZj1cImZsdWlkXCIgY2xhc3M9XCJjZHMtLWxpc3QtYm94X19kaXZpZGVyXCIgLz5cblx0PGRpdlxuXHRcdCpuZ0lmPVwiaGVscGVyVGV4dCAmJiAhaW52YWxpZCAmJiAhd2FybiAmJiAhc2tlbGV0b24gJiYgIWZsdWlkXCJcblx0XHRjbGFzcz1cImNkcy0tZm9ybV9faGVscGVyLXRleHRcIlxuXHRcdFtuZ0NsYXNzXT1cIntcblx0XHRcdCdjZHMtLWZvcm1fX2hlbHBlci10ZXh0LS1kaXNhYmxlZCc6IGRpc2FibGVkXG5cdFx0fVwiPlxuXHRcdDxuZy1jb250YWluZXIgKm5nSWY9XCIhaXNUZW1wbGF0ZShoZWxwZXJUZXh0KVwiPnt7aGVscGVyVGV4dH19PC9uZy1jb250YWluZXI+XG5cdFx0PG5nLXRlbXBsYXRlICpuZ0lmPVwiaXNUZW1wbGF0ZShoZWxwZXJUZXh0KVwiIFtuZ1RlbXBsYXRlT3V0bGV0XT1cImhlbHBlclRleHRcIj48L25nLXRlbXBsYXRlPlxuXHQ8L2Rpdj5cblx0PGRpdiAqbmdJZj1cImludmFsaWRcIiBjbGFzcz1cImNkcy0tZm9ybS1yZXF1aXJlbWVudFwiPlxuXHRcdDxuZy1jb250YWluZXIgKm5nSWY9XCIhaXNUZW1wbGF0ZShpbnZhbGlkVGV4dClcIj57eyBpbnZhbGlkVGV4dCB9fTwvbmctY29udGFpbmVyPlxuXHRcdDxuZy10ZW1wbGF0ZSAqbmdJZj1cImlzVGVtcGxhdGUoaW52YWxpZFRleHQpXCIgW25nVGVtcGxhdGVPdXRsZXRdPVwiaW52YWxpZFRleHRcIj48L25nLXRlbXBsYXRlPlxuXHQ8L2Rpdj5cblx0PGRpdiAqbmdJZj1cIiFpbnZhbGlkICYmIHdhcm5cIiBjbGFzcz1cImNkcy0tZm9ybS1yZXF1aXJlbWVudFwiPlxuXHRcdDxuZy1jb250YWluZXIgKm5nSWY9XCIhaXNUZW1wbGF0ZSh3YXJuVGV4dClcIj57e3dhcm5UZXh0fX08L25nLWNvbnRhaW5lcj5cblx0XHQ8bmctdGVtcGxhdGUgKm5nSWY9XCJpc1RlbXBsYXRlKHdhcm5UZXh0KVwiIFtuZ1RlbXBsYXRlT3V0bGV0XT1cIndhcm5UZXh0XCI+PC9uZy10ZW1wbGF0ZT5cblx0PC9kaXY+XG5cdGAsXG5cdHByb3ZpZGVyczogW1xuXHRcdHtcblx0XHRcdHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuXHRcdFx0dXNlRXhpc3Rpbmc6IERyb3Bkb3duLFxuXHRcdFx0bXVsdGk6IHRydWVcblx0XHR9XG5cdF1cbn0pXG5leHBvcnQgY2xhc3MgRHJvcGRvd24gaW1wbGVtZW50cyBPbkluaXQsIEFmdGVyQ29udGVudEluaXQsIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSwgQ29udHJvbFZhbHVlQWNjZXNzb3Ige1xuXHRzdGF0aWMgZHJvcGRvd25Db3VudCA9IDA7XG5cdEBIb3N0QmluZGluZyhcImNsYXNzLmNkcy0tbGlzdC1ib3hfX3dyYXBwZXItLWZsdWlkLS1pbnZhbGlkXCIpIGdldCBmbHVpZEludmFsaWRDbGFzcygpIHtcblx0XHRyZXR1cm4gdGhpcy5pbnZhbGlkICYmIHRoaXMuZmx1aWQ7XG5cdH1cblxuXHRASG9zdEJpbmRpbmcoXCJjbGFzcy5jZHMtLWxpc3QtYm94X193cmFwcGVyLS1mbHVpZC0tZm9jdXNcIikgZ2V0IGZsdWlkRm9jdXNDbGFzcygpIHtcblx0XHRyZXR1cm4gdGhpcy5mbHVpZCAmJiB0aGlzLl9pc0ZvY3VzZWQgJiYgdGhpcy5tZW51SXNDbG9zZWQ7XG5cdH1cblxuXHRwcm90ZWN0ZWQgZ2V0IHdyaXR0ZW5WYWx1ZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5fd3JpdHRlblZhbHVlO1xuXHR9XG5cblx0cHJvdGVjdGVkIHNldCB3cml0dGVuVmFsdWUodmFsOiBhbnlbXSkge1xuXHRcdGlmICh2YWwgJiYgdmFsLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0dGhpcy5jbGVhclNlbGVjdGVkKCk7XG5cdFx0fVxuXHRcdHRoaXMuX3dyaXR0ZW5WYWx1ZSA9IHZhbDtcblx0fVxuXG5cdEBJbnB1dCgpIGlkID0gYGRyb3Bkb3duLSR7RHJvcGRvd24uZHJvcGRvd25Db3VudCsrfWA7XG5cdC8qKlxuXHQgKiBMYWJlbCBmb3IgdGhlIGRyb3Bkb3duLlxuXHQgKi9cblx0QElucHV0KCkgbGFiZWw6IHN0cmluZyB8IFRlbXBsYXRlUmVmPGFueT47XG5cdC8qKlxuXHQgKiBIaWRlIGxhYmVsIHdoaWxlIGtlZXBpbmcgaXQgYWNjZXNzaWJsZSBmb3Igc2NyZWVuIHJlYWRlcnNcblx0ICovXG5cdEBJbnB1dCgpIGhpZGVMYWJlbCA9IGZhbHNlO1xuXHQvKipcblx0ICogU2V0cyB0aGUgb3B0aW9uYWwgaGVscGVyIHRleHQuXG5cdCAqL1xuXHRASW5wdXQoKSBoZWxwZXJUZXh0OiBzdHJpbmcgfCBUZW1wbGF0ZVJlZjxhbnk+O1xuXHQvKipcblx0ICogVmFsdWUgZGlzcGxheWVkIGlmIG5vIGl0ZW0gaXMgc2VsZWN0ZWQuXG5cdCAqL1xuXHRASW5wdXQoKSBwbGFjZWhvbGRlciA9IFwiXCI7XG5cdC8qKlxuXHQgKiBUaGUgc2VsZWN0ZWQgdmFsdWUgZnJvbSB0aGUgYERyb3Bkb3duYC4gQ2FuIGJlIGEgc3RyaW5nIG9yIHRlbXBsYXRlLlxuXHQgKi9cblx0QElucHV0KCkgZGlzcGxheVZhbHVlOiBzdHJpbmcgfCBUZW1wbGF0ZVJlZjxhbnk+ID0gXCJcIjtcblx0LyoqXG5cdCAqIFNldHMgdGhlIG9wdGlvbmFsIGNsZWFyIGJ1dHRvbiB0b29sdGlwIHRleHQuXG5cdCAqL1xuXHRASW5wdXQoKSBjbGVhclRleHQ6IHN0cmluZyA9IHRoaXMuaTE4bi5nZXQoKS5EUk9QRE9XTi5DTEVBUjtcblx0LyoqXG5cdCAqIFNpemUgdG8gcmVuZGVyIHRoZSBkcm9wZG93biBmaWVsZC5cblx0ICovXG5cdEBJbnB1dCgpIHNpemU6IFwic21cIiB8IFwibWRcIiB8IFwibGdcIiA9IFwibWRcIjtcblx0LyoqXG5cdCAqIERlZmluZXMgd2hldGhlciBvciBub3QgdGhlIGBEcm9wZG93bmAgc3VwcG9ydHMgc2VsZWN0aW5nIG11bHRpcGxlIGl0ZW1zIGFzIG9wcG9zZWQgdG8gc2luZ2xlXG5cdCAqIGl0ZW0gc2VsZWN0aW9uLlxuXHQgKi9cblx0QElucHV0KCkgdHlwZTogXCJzaW5nbGVcIiB8IFwibXVsdGlcIiA9IFwic2luZ2xlXCI7XG5cdC8qKlxuXHQgKiBAZGVwcmVjYXRlZCBzaW5jZSB2NSAtIFVzZSBgY2RzTGF5ZXJgIGRpcmVjdGl2ZSBpbnN0ZWFkXG5cdCAqIGBsaWdodGAgb3IgYGRhcmtgIGRyb3Bkb3duIHRoZW1lXG5cdCAqL1xuXHRASW5wdXQoKSB0aGVtZTogXCJsaWdodFwiIHwgXCJkYXJrXCIgPSBcImRhcmtcIjtcblx0LyoqXG5cdCAqIFNldCB0byBgdHJ1ZWAgdG8gZGlzYWJsZSB0aGUgZHJvcGRvd24uXG5cdCAqL1xuXHRASW5wdXQoKSBkaXNhYmxlZCA9IGZhbHNlO1xuXHQvKipcblx0ICogU2V0IHRvIGB0cnVlYCBmb3IgYSByZWFkb25seSBzdGF0ZS5cblx0ICovXG5cdEBJbnB1dCgpIHJlYWRvbmx5ID0gZmFsc2U7XG5cdC8qKlxuXHQgKiBTZXQgdG8gYHRydWVgIGZvciBhIGxvYWRpbmcgZHJvcGRvd24uXG5cdCAqL1xuXHRASW5wdXQoKSBza2VsZXRvbiA9IGZhbHNlO1xuXHQvKipcblx0ICogU2V0IHRvIGB0cnVlYCBmb3IgYW4gaW5saW5lIGRyb3Bkb3duLlxuXHQgKi9cblx0QElucHV0KCkgaW5saW5lID0gZmFsc2U7XG5cdC8qKlxuXHQgKiBTZXQgdG8gYHRydWVgIGZvciBhIGRyb3Bkb3duIHdpdGhvdXQgYXJyb3cga2V5IGFjdGl2YXRpb24uXG5cdCAqL1xuXHRASW5wdXQoKSBkaXNhYmxlQXJyb3dLZXlzID0gZmFsc2U7XG5cdC8qKlxuXHQgKiBTZXQgdG8gYHRydWVgIGZvciBpbnZhbGlkIHN0YXRlLlxuXHQgKi9cblx0QElucHV0KCkgaW52YWxpZCA9IGZhbHNlO1xuXHQvKipcblx0ICogVmFsdWUgZGlzcGxheWVkIGlmIGRyb3Bkb3duIGlzIGluIGludmFsaWQgc3RhdGUuXG5cdCAqL1xuXHRASW5wdXQoKSBpbnZhbGlkVGV4dDogc3RyaW5nIHwgVGVtcGxhdGVSZWY8YW55Pjtcblx0LyoqXG5cdCAgKiBTZXQgdG8gYHRydWVgIHRvIHNob3cgYSB3YXJuaW5nIChjb250ZW50cyBzZXQgYnkgd2FybmluZ1RleHQpXG5cdCAgKi9cblx0QElucHV0KCkgd2FybiA9IGZhbHNlO1xuXHQvKipcblx0ICogU2V0cyB0aGUgd2FybmluZyB0ZXh0XG5cdCAqL1xuXHRASW5wdXQoKSB3YXJuVGV4dDogc3RyaW5nIHwgVGVtcGxhdGVSZWY8YW55Pjtcblx0LyoqXG5cdCAqIHNldCB0byBgdHJ1ZWAgdG8gcGxhY2UgdGhlIGRyb3Bkb3duIHZpZXcgaW5saW5lIHdpdGggdGhlIGNvbXBvbmVudFxuXHQgKi9cblx0QElucHV0KCkgYXBwZW5kSW5saW5lOiBib29sZWFuID0gbnVsbDtcblx0LyoqXG5cdCAqIFF1ZXJ5IHN0cmluZyBmb3IgdGhlIGVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgYERyb3Bkb3duYC5cblx0ICogVXNlZCB0byB0cmlnZ2VyIGNsb3NpbmcgdGhlIGRyb3Bkb3duIGlmIGl0IHNjcm9sbHMgb3V0c2lkZSBvZiB0aGUgdmlld3BvcnQgb2YgdGhlIGBzY3JvbGxhYmxlQ29udGFpbmVyYC5cblx0ICovXG5cdEBJbnB1dCgpIHNjcm9sbGFibGVDb250YWluZXI6IHN0cmluZztcblx0LyoqXG5cdCAqIFNwZWNpZmllcyB0aGUgcHJvcGVydHkgdG8gYmUgdXNlZCBhcyB0aGUgcmV0dXJuIHZhbHVlIHRvIGBuZ01vZGVsYFxuXHQgKi9cblx0QElucHV0KCkgaXRlbVZhbHVlS2V5OiBzdHJpbmc7XG5cdC8qKlxuXHQgKiBTcGVjaWZ5IGZlZWRiYWNrIChtb2RlKSBvZiB0aGUgc2VsZWN0aW9uLlxuXHQgKiBgdG9wYDogc2VsZWN0ZWQgaXRlbSBqdW1wcyB0byB0b3Bcblx0ICogYGZpeGVkYDogc2VsZWN0ZWQgaXRlbSBzdGF5cyBhdCBpdCdzIHBvc2l0aW9uXG5cdCAqIGB0b3AtYWZ0ZXItcmVvcGVuYDogc2VsZWN0ZWQgaXRlbSBqdW1wIHRvIHRvcCBhZnRlciByZW9wZW4gZHJvcGRvd25cblx0ICovXG5cdEBJbnB1dCgpIHNlbGVjdGlvbkZlZWRiYWNrOiBcInRvcFwiIHwgXCJmaXhlZFwiIHwgXCJ0b3AtYWZ0ZXItcmVvcGVuXCIgPSBcInRvcC1hZnRlci1yZW9wZW5cIjtcblx0LyoqXG5cdCAqIEFjY2Vzc2libGUgbGFiZWwgZm9yIHRoZSBidXR0b24gdGhhdCBvcGVucyB0aGUgZHJvcGRvd24gbGlzdC5cblx0ICogRGVmYXVsdHMgdG8gdGhlIGBEUk9QRE9XTi5PUEVOYCB2YWx1ZSBmcm9tIHRoZSBpMThuIHNlcnZpY2UuXG5cdCAqL1xuXHRASW5wdXQoKSBtZW51QnV0dG9uTGFiZWwgPSB0aGlzLmkxOG4uZ2V0KCkuRFJPUERPV04uT1BFTjtcblx0LyoqXG5cdCAqIFByb3ZpZGVzIHRoZSBsYWJlbCBmb3IgdGhlIFwiIyBzZWxlY3RlZFwiIHRleHQuXG5cdCAqIERlZmF1bHRzIHRvIHRoZSBgRFJPUERPV04uU0VMRUNURURgIHZhbHVlIGZyb20gdGhlIGkxOG4gc2VydmljZS5cblx0ICovXG5cdEBJbnB1dCgpIHNlbGVjdGVkTGFiZWwgPSB0aGlzLmkxOG4uZ2V0KCkuRFJPUERPV04uU0VMRUNURUQ7XG5cdC8qKlxuXHQgKiBPdmVycmlkZXMgdGhlIGF1dG9tYXRpYyBkcm9wVXAuXG5cdCAqL1xuXHRASW5wdXQoKSBkcm9wVXA6IGJvb2xlYW47XG5cdC8qKlxuXHQgKiBFbWl0cyBzZWxlY3Rpb24gZXZlbnRzLlxuXHQgKi9cblx0QE91dHB1dCgpIHNlbGVjdGVkOiBFdmVudEVtaXR0ZXI8T2JqZWN0PiA9IG5ldyBFdmVudEVtaXR0ZXI8T2JqZWN0PigpO1xuXHQvKipcblx0ICogRW1pdHMgZXZlbnQgbm90aWZ5aW5nIHRvIG90aGVyIGNsYXNzZXMgdGhhdCB0aGUgYERyb3Bkb3duYCBoYXMgYmVlbiBjbG9zZWQgKGNvbGxhcHNlZCkuXG5cdCAqL1xuXHRAT3V0cHV0KCkgb25DbG9zZTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblx0LyoqXG5cdCAqIEVtaXRzIGV2ZW50IG5vdGlmeWluZyB0byBvdGhlciBjbGFzc2VzIHRoYXQgdGhlIGBEcm9wZG93bmAgaGFzIGJlZW4gY2xvc2VkIChjb2xsYXBzZWQpLlxuXHQgKi9cblx0QE91dHB1dCgpIGNsb3NlOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG5cdC8qKlxuXHQgKiBNYWludGFpbnMgYSByZWZlcmVuY2UgdG8gdGhlIGBBYnN0cmFjdERyb3Bkb3duVmlld2Agb2JqZWN0IHdpdGhpbiB0aGUgY29udGVudCBET00uXG5cdCAqL1xuXHRAQ29udGVudENoaWxkKEFic3RyYWN0RHJvcGRvd25WaWV3LCB7IHN0YXRpYzogdHJ1ZSB9KSB2aWV3OiBBYnN0cmFjdERyb3Bkb3duVmlldztcblx0LyoqXG5cdCAqIE1haW50YWlucyBhIHJlZmVyZW5jZSB0byB0aGUgdmlldyBET00gZWxlbWVudCBvZiB0aGUgYERyb3Bkb3duYCBidXR0b24uXG5cdCAqL1xuXHRAVmlld0NoaWxkKFwiZHJvcGRvd25CdXR0b25cIiwgeyBzdGF0aWM6IHRydWUgfSkgZHJvcGRvd25CdXR0b247XG5cdC8qKlxuXHQgKiBWaWV3Q2hpZCBvZiB0aGUgZHJvcGRvd24gdmlldy5cblx0ICovXG5cdEBWaWV3Q2hpbGQoXCJkcm9wZG93bk1lbnVcIiwgeyBzdGF0aWM6IHRydWUgfSkgZHJvcGRvd25NZW51O1xuXG5cdEBIb3N0QmluZGluZyhcImNsYXNzLmNkcy0tZHJvcGRvd25fX3dyYXBwZXJcIikgaG9zdENsYXNzID0gdHJ1ZTtcblxuXHRASG9zdEJpbmRpbmcoXCJjbGFzcy5jZHMtLWxpc3QtYm94X193cmFwcGVyXCIpIGhvc3RXcmFwcGVyQ2xhc3MgPSB0cnVlO1xuXHQvKipcblx0ICogRXhwZXJpbWVudGFsOiBlbmFibGUgZmx1aWQgc3RhdGVcblx0ICovXG5cdEBIb3N0QmluZGluZyhcImNsYXNzLmNkcy0tbGlzdC1ib3hfX3dyYXBwZXItLWZsdWlkXCIpIEBJbnB1dCgpIGZsdWlkID0gZmFsc2U7XG5cblx0LyoqXG5cdCAqIFNldCB0byBgdHJ1ZWAgaWYgdGhlIGRyb3Bkb3duIGlzIGNsb3NlZCAobm90IGV4cGFuZGVkKS5cblx0ICovXG5cdG1lbnVJc0Nsb3NlZCA9IHRydWU7XG5cblx0LyoqXG5cdCAqIGNvbnRyb2xzIHdoZXRoZXIgdGhlIGBkcm9wLXVwYCBjbGFzcyBpcyBhcHBsaWVkXG5cdCAqL1xuXHRfZHJvcFVwID0gZmFsc2U7XG5cblx0Ly8gLmJpbmQgY3JlYXRlcyBhIG5ldyBmdW5jdGlvbiwgc28gd2UgZGVjbGFyZSB0aGUgbWV0aG9kcyBiZWxvd1xuXHQvLyBidXQgLmJpbmQgdGhlbSB1cCBoZXJlXG5cdG5vb3AgPSB0aGlzLl9ub29wLmJpbmQodGhpcyk7XG5cdG91dHNpZGVDbGljayA9IHRoaXMuX291dHNpZGVDbGljay5iaW5kKHRoaXMpO1xuXHRvdXRzaWRlS2V5ID0gdGhpcy5fb3V0c2lkZUtleS5iaW5kKHRoaXMpO1xuXHRrZXlib2FyZE5hdiA9IHRoaXMuX2tleWJvYXJkTmF2LmJpbmQodGhpcyk7XG5cblx0cHJvdGVjdGVkIHZpc2liaWxpdHlTdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG5cblx0cHJvdGVjdGVkIG9uVG91Y2hlZENhbGxiYWNrOiAoKSA9PiB2b2lkID0gdGhpcy5fbm9vcDtcblxuXHRwcm90ZWN0ZWQgX2lzRm9jdXNlZCA9IGZhbHNlO1xuXG5cdC8vIHByaW1hcmlseSB1c2VkIHRvIGNhcHR1cmUgYW5kIHByb3BhZ2F0ZSBpbnB1dCB0byBgd3JpdGVWYWx1ZWAgYmVmb3JlIHRoZSBjb250ZW50IGlzIGF2YWlsYWJsZVxuXHRwcml2YXRlIF93cml0dGVuVmFsdWU6IGFueSA9IFtdO1xuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIERyb3Bkb3duLlxuXHQgKi9cblx0Y29uc3RydWN0b3IoXG5cdFx0cHJvdGVjdGVkIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsXG5cdFx0cHJvdGVjdGVkIGkxOG46IEkxOG4sXG5cdFx0cHJvdGVjdGVkIGRyb3Bkb3duU2VydmljZTogRHJvcGRvd25TZXJ2aWNlLFxuXHRcdHByb3RlY3RlZCBlbGVtZW50U2VydmljZTogRWxlbWVudFNlcnZpY2UpIHt9XG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgdGhlIGB0eXBlYCBwcm9wZXJ0eSBpbiB0aGUgYEBDb250ZW50Q2hpbGRgLlxuXHQgKiBUaGUgYHR5cGVgIHByb3BlcnR5IHNwZWNpZmllcyB3aGV0aGVyIHRoZSBgRHJvcGRvd25gIGFsbG93cyBzaW5nbGUgc2VsZWN0aW9uIG9yIG11bHRpIHNlbGVjdGlvbi5cblx0ICovXG5cdG5nT25Jbml0KCkge1xuXHRcdGlmICh0aGlzLnZpZXcpIHtcblx0XHRcdHRoaXMudmlldy50eXBlID0gdGhpcy50eXBlO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBJbml0aWFsaXplcyBjbGFzc2VzIGFuZCBzdWJzY3JpYmVzIHRvIGV2ZW50cyBmb3Igc2luZ2xlIG9yIG11bHRpIHNlbGVjdGlvbi5cblx0ICovXG5cdG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcblx0XHRpZiAoIXRoaXMudmlldykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAoKHRoaXMud3JpdHRlblZhbHVlICYmIHRoaXMud3JpdHRlblZhbHVlLmxlbmd0aCkgfHwgdHlwZW9mIHRoaXMud3JpdHRlblZhbHVlID09PSBcIm51bWJlclwiKSB7XG5cdFx0XHR0aGlzLndyaXRlVmFsdWUodGhpcy53cml0dGVuVmFsdWUpO1xuXHRcdH1cblx0XHR0aGlzLnZpZXcudHlwZSA9IHRoaXMudHlwZTtcblx0XHR0aGlzLnZpZXcuc2l6ZSA9IHRoaXMuc2l6ZTtcblxuXHRcdC8vIGZ1bmN0aW9uIHRvIGNoZWNrIGlmIHRoZSBldmVudCBpcyBvcmdhbmljIChpc1VwZGF0ZSA9PT0gZmFsc2UpIG9yIHByb2dyYW1tYXRpY1xuXHRcdGNvbnN0IGlzVXBkYXRlID0gZXZlbnQgPT4gZXZlbnQgJiYgZXZlbnQuaXNVcGRhdGU7XG5cblx0XHR0aGlzLnZpZXcuc2VsZWN0LnN1YnNjcmliZShldmVudCA9PiB7XG5cdFx0XHRpZiAodGhpcy50eXBlID09PSBcInNpbmdsZVwiICYmICFpc1VwZGF0ZShldmVudCkgJiYgIUFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG5cdFx0XHRcdHRoaXMuY2xvc2VNZW51KCk7XG5cdFx0XHRcdGlmIChldmVudC5pdGVtICYmIGV2ZW50Lml0ZW0uc2VsZWN0ZWQpIHtcblx0XHRcdFx0XHRpZiAodGhpcy5pdGVtVmFsdWVLZXkpIHtcblx0XHRcdFx0XHRcdHRoaXMucHJvcGFnYXRlQ2hhbmdlKGV2ZW50Lml0ZW1bdGhpcy5pdGVtVmFsdWVLZXldKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy5wcm9wYWdhdGVDaGFuZ2UoZXZlbnQuaXRlbSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMucHJvcGFnYXRlQ2hhbmdlKG51bGwpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLnR5cGUgPT09IFwibXVsdGlcIiAmJiAhaXNVcGRhdGUoZXZlbnQpKSB7XG5cdFx0XHRcdC8vIGlmIHdlIGhhdmUgYSBgdmFsdWVgIHNlbGVjdG9yIGFuZCBzZWxlY3RlZCBpdGVtcyBtYXAgdGhlbSBhcHByb3ByaWF0ZWx5XG5cdFx0XHRcdGlmICh0aGlzLml0ZW1WYWx1ZUtleSAmJiB0aGlzLnZpZXcuZ2V0U2VsZWN0ZWQoKSkge1xuXHRcdFx0XHRcdGNvbnN0IHZhbHVlcyA9IHRoaXMudmlldy5nZXRTZWxlY3RlZCgpLm1hcChpdGVtID0+IGl0ZW1bdGhpcy5pdGVtVmFsdWVLZXldKTtcblx0XHRcdFx0XHR0aGlzLnByb3BhZ2F0ZUNoYW5nZSh2YWx1ZXMpO1xuXHRcdFx0XHRcdC8vIG90aGVyd2lzZSBqdXN0IHBhc3MgdXAgdGhlIHZhbHVlcyBmcm9tIGBnZXRTZWxlY3RlZGBcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLnByb3BhZ2F0ZUNoYW5nZSh0aGlzLnZpZXcuZ2V0U2VsZWN0ZWQoKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIG9ubHkgZW1pdCBzZWxlY3RlZCBmb3IgXCJvcmdhbmljXCIgc2VsZWN0aW9uc1xuXHRcdFx0aWYgKCFpc1VwZGF0ZShldmVudCkpIHtcblx0XHRcdFx0dGhpcy5jaGVja0ZvclJlb3JkZXIoKTtcblx0XHRcdFx0dGhpcy5zZWxlY3RlZC5lbWl0KGV2ZW50KTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdG5nQWZ0ZXJWaWV3SW5pdCgpIHtcblx0XHQvLyBpZiBhcHBlbmRJbmxpbmUgaXMgZGVmYXVsdCB2YWx1ZWQgKG51bGwpIHdlIHNob3VsZDpcblx0XHQvLyAxLiBpZiB0aGVyZSBhcmUgc2Nyb2xsYWJsZSBwYXJlbnRzIChub3QgaW5jbHVkaW5nIGJvZHkpIGRvbid0IGFwcGVuZCBpbmxpbmVcblx0XHQvLyAgICB0aGlzIHNob3VsZCBhbHNvIGNvdmVyIHRoZSBjYXNlIHdoZXJlIHRoZSBkcm9wZG93biBpcyBpbiBhIG1vZGFsXG5cdFx0Ly8gICAgKHdoZXJlIHdlIF9kb18gd2FudCB0byBhcHBlbmQgdG8gdGhlIHBsYWNlaG9sZGVyKVxuXHRcdGlmICh0aGlzLmFwcGVuZElubGluZSA9PT0gbnVsbCAmJiBoYXNTY3JvbGxhYmxlUGFyZW50cyh0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCkpIHtcblx0XHRcdHRoaXMuYXBwZW5kSW5saW5lID0gZmFsc2U7XG5cdFx0XHQvLyAyLiBvdGhlcndpc2Ugd2Ugc2hvdWxkIGFwcGVuZCBpbmxpbmVcblx0XHR9IGVsc2UgaWYgKHRoaXMuYXBwZW5kSW5saW5lID09PSBudWxsKSB7XG5cdFx0XHR0aGlzLmFwcGVuZElubGluZSA9IHRydWU7XG5cdFx0fVxuXHRcdHRoaXMuY2hlY2tGb3JSZW9yZGVyKCk7XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZpbmcgdGhlIGBEcm9wZG93bmAgZnJvbSB0aGUgYm9keSBpZiBpdCBpcyBhcHBlbmRlZCB0byB0aGUgYm9keS5cblx0ICovXG5cdG5nT25EZXN0cm95KCkge1xuXHRcdGlmICghdGhpcy5hcHBlbmRJbmxpbmUpIHtcblx0XHRcdHRoaXMuX2FwcGVuZFRvRHJvcGRvd24oKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUHJvcGFnYXRlcyB0aGUgaW5qZWN0ZWQgYHZhbHVlYC5cblx0ICovXG5cdHdyaXRlVmFsdWUodmFsdWU6IGFueSkge1xuXHRcdC8vIGNhY2hlIHRoZSB3cml0dGVuIHZhbHVlIHNvIHdlIGNhbiB1c2UgaXQgaW4gYEFmdGVyQ29udGVudEluaXRgXG5cdFx0dGhpcy53cml0dGVuVmFsdWUgPSB2YWx1ZTtcblx0XHR0aGlzLnZpZXcub25JdGVtc1JlYWR5KCgpID0+IHtcblx0XHRcdC8vIHByb3BhZ2F0ZSBudWxsL2ZhbHNleSBhcyBhbiBhcnJheSAoZGVzZWxlY3QgZXZlcnl0aGluZylcblx0XHRcdGlmICghdmFsdWUpIHtcblx0XHRcdFx0dGhpcy52aWV3LnByb3BhZ2F0ZVNlbGVjdGVkKFt2YWx1ZV0pO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLnR5cGUgPT09IFwic2luZ2xlXCIpIHtcblx0XHRcdFx0aWYgKHRoaXMuaXRlbVZhbHVlS2V5KSB7XG5cdFx0XHRcdFx0Ly8gY2xvbmUgdGhlIHNwZWNpZmllZCBpdGVtIGFuZCB1cGRhdGUgaXRzIHN0YXRlXG5cdFx0XHRcdFx0Y29uc3QgbmV3VmFsdWUgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnZpZXcuZ2V0TGlzdEl0ZW1zKCkuZmluZChpdGVtID0+IGl0ZW1bdGhpcy5pdGVtVmFsdWVLZXldID09PSB2YWx1ZSkpO1xuXHRcdFx0XHRcdG5ld1ZhbHVlLnNlbGVjdGVkID0gdHJ1ZTtcblx0XHRcdFx0XHR0aGlzLnZpZXcucHJvcGFnYXRlU2VsZWN0ZWQoW25ld1ZhbHVlXSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gcGFzcyB0aGUgc2luZ3VsYXIgdmFsdWUgYXMgYW4gYXJyYXkgb2YgTGlzdEl0ZW1cblx0XHRcdFx0XHR0aGlzLnZpZXcucHJvcGFnYXRlU2VsZWN0ZWQoW3ZhbHVlXSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICh0aGlzLml0ZW1WYWx1ZUtleSkge1xuXHRcdFx0XHRcdC8vIGNsb25lIHRoZSBpdGVtcyBhbmQgdXBkYXRlIHRoZWlyIHN0YXRlIGJhc2VkIG9uIHRoZSByZWNlaXZlZCB2YWx1ZSBhcnJheVxuXHRcdFx0XHRcdC8vIHRoaXMgd2F5IHdlIGRvbid0IGxvc2UgYW55IGFkZGl0aW9uYWwgbWV0YWRhdGEgdGhhdCBtYXkgYmUgcGFzc2VkIGluIHZpYSB0aGUgYGl0ZW1zYCBJbnB1dFxuXHRcdFx0XHRcdGxldCBuZXdWYWx1ZXMgPSBbXTtcblx0XHRcdFx0XHRmb3IgKGNvbnN0IHYgb2YgdmFsdWUpIHtcblx0XHRcdFx0XHRcdGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLnZpZXcuZ2V0TGlzdEl0ZW1zKCkpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGl0ZW1bdGhpcy5pdGVtVmFsdWVLZXldID09PSB2KSB7XG5cdFx0XHRcdFx0XHRcdFx0bmV3VmFsdWVzLnB1c2goT2JqZWN0LmFzc2lnbih7fSwgaXRlbSwgeyBzZWxlY3RlZDogdHJ1ZSB9KSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy52aWV3LnByb3BhZ2F0ZVNlbGVjdGVkKG5ld1ZhbHVlcyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gd2UgY2FuIHNhZmVseSBhc3N1bWUgd2UncmUgcGFzc2luZyBhbiBhcnJheSBvZiBgTGlzdEl0ZW1gc1xuXHRcdFx0XHRcdHRoaXMudmlldy5wcm9wYWdhdGVTZWxlY3RlZCh2YWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMuY2hlY2tGb3JSZW9yZGVyKCk7XG5cdFx0fSk7XG5cdH1cblxuXHRvbkJsdXIoKSB7XG5cdFx0dGhpcy5vblRvdWNoZWRDYWxsYmFjaygpO1xuXHR9XG5cblx0cmVnaXN0ZXJPbkNoYW5nZShmbjogYW55KSB7XG5cdFx0dGhpcy5wcm9wYWdhdGVDaGFuZ2UgPSBmbjtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZWdpc3RlcmluZyB0aGUgZnVuY3Rpb24gaW5qZWN0ZWQgdG8gY29udHJvbCB0aGUgdG91Y2ggdXNlIG9mIHRoZSBgRHJvcGRvd25gLlxuXHQgKi9cblx0cmVnaXN0ZXJPblRvdWNoZWQoZm46IGFueSkge1xuXHRcdHRoaXMub25Ub3VjaGVkQ2FsbGJhY2sgPSBmbjtcblx0fVxuXG5cdC8qKlxuXHQgKiBmdW5jdGlvbiBwYXNzZWQgaW4gYnkgYHJlZ2lzdGVyT25DaGFuZ2VgXG5cdCAqL1xuXHRwcm9wYWdhdGVDaGFuZ2UgPSAoXzogYW55KSA9PiB7IH07XG5cblx0LyoqXG5cdCAqIGBDb250cm9sVmFsdWVBY2Nlc3NvcmAgbWV0aG9kIHRvIHByb2dyYW1tYXRpY2FsbHkgZGlzYWJsZSB0aGUgZHJvcGRvd24uXG5cdCAqXG5cdCAqIGV4OiBgdGhpcy5mb3JtR3JvdXAuZ2V0KFwibXlEcm9wZG93blwiKS5kaXNhYmxlKCk7YFxuXHQgKlxuXHQgKiBAcGFyYW0gaXNEaXNhYmxlZCBgdHJ1ZWAgdG8gZGlzYWJsZSB0aGUgaW5wdXRcblx0ICovXG5cdHNldERpc2FibGVkU3RhdGUoaXNEaXNhYmxlZDogYm9vbGVhbikge1xuXHRcdHRoaXMuZGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMga2V5Ym9hcmQgZnVuY3Rpb25hbGl0eSBmb3IgbmF2aWdhdGlvbiwgc2VsZWN0aW9uIGFuZCBjbG9zaW5nIG9mIHRoZSBgRHJvcGRvd25gLlxuXHQgKi9cblx0QEhvc3RMaXN0ZW5lcihcImtleWRvd25cIiwgW1wiJGV2ZW50XCJdKVxuXHRvbktleURvd24oZXZlbnQ6IEtleWJvYXJkRXZlbnQpIHtcblx0XHRpZiAodGhpcy5yZWFkb25seSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICgoZXZlbnQua2V5ID09PSBcIkVzY2FwZVwiKSAmJiAhdGhpcy5tZW51SXNDbG9zZWQpIHtcblx0XHRcdGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpOyAgLy8gZG9uJ3QgdW5pbnRlbnRpb25hbGx5IGNsb3NlIG90aGVyIHdpZGdldHMgdGhhdCBsaXN0ZW4gZm9yIEVzY2FwZVxuXHRcdH1cblx0XHRpZiAoZXZlbnQua2V5ID09PSBcIkVzY2FwZVwiKSB7XG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0dGhpcy5jbG9zZU1lbnUoKTtcblx0XHRcdHRoaXMuZHJvcGRvd25CdXR0b24ubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuXHRcdH0gZWxzZSBpZiAodGhpcy5tZW51SXNDbG9zZWQgJiYgKGV2ZW50LmtleSA9PT0gXCIgXCIgfHwgZXZlbnQua2V5ID09PSBcIkFycm93RG93blwiIHx8IGV2ZW50LmtleSA9PT0gXCJBcnJvd1VwXCIpKSB7XG5cdFx0XHRpZiAodGhpcy5kaXNhYmxlQXJyb3dLZXlzICYmIChldmVudC5rZXkgPT09IFwiQXJyb3dEb3duXCIgfHwgZXZlbnQua2V5ID09PSBcIkFycm93VXBcIikpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdHRoaXMub3Blbk1lbnUoKTtcblx0XHR9XG5cblx0XHRpZiAoIXRoaXMubWVudUlzQ2xvc2VkICYmIGV2ZW50LmtleSA9PT0gXCJUYWJcIiAmJiB0aGlzLmRyb3Bkb3duTWVudS5uYXRpdmVFbGVtZW50LmNvbnRhaW5zKGV2ZW50LnRhcmdldCBhcyBOb2RlKSkge1xuXHRcdFx0dGhpcy5jbG9zZU1lbnUoKTtcblx0XHR9XG5cblx0XHRpZiAoIXRoaXMubWVudUlzQ2xvc2VkICYmIGV2ZW50LmtleSA9PT0gXCJUYWJcIiAmJiBldmVudC5zaGlmdEtleSkge1xuXHRcdFx0dGhpcy5jbG9zZU1lbnUoKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy50eXBlID09PSBcIm11bHRpXCIpIHsgcmV0dXJuOyB9XG5cblx0XHRpZiAodGhpcy5tZW51SXNDbG9zZWQpIHtcblx0XHRcdHRoaXMuY2xvc2VkRHJvcGRvd25OYXZpZ2F0aW9uKGV2ZW50KTtcblx0XHR9XG5cdH1cblxuXHRjbG9zZWREcm9wZG93bk5hdmlnYXRpb24oZXZlbnQpIHtcblx0XHRpZiAoZXZlbnQua2V5ID09PSBcIkFycm93RG93blwiKSB7XG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0dGhpcy52aWV3LmdldEN1cnJlbnRJdGVtKCkuc2VsZWN0ZWQgPSBmYWxzZTtcblx0XHRcdGxldCBpdGVtID0gdGhpcy52aWV3LmdldE5leHRJdGVtKCk7XG5cdFx0XHRpZiAoaXRlbSkgeyBpdGVtLnNlbGVjdGVkID0gdHJ1ZTsgfVxuXHRcdH0gZWxzZSBpZiAoZXZlbnQua2V5ID09PSBcIkFycm93VXBcIikge1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdHRoaXMudmlldy5nZXRDdXJyZW50SXRlbSgpLnNlbGVjdGVkID0gZmFsc2U7XG5cdFx0XHRsZXQgaXRlbSA9IHRoaXMudmlldy5nZXRQcmV2SXRlbSgpO1xuXHRcdFx0aWYgKGl0ZW0pIHsgaXRlbS5zZWxlY3RlZCA9IHRydWU7IH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgZGlzcGxheSB2YWx1ZSBpZiB0aGVyZSBpcyBhIHNlbGVjdGlvbiBhbmQgZGlzcGxheVZhbHVlIGlzIHNldCxcblx0ICogaWYgdGhlcmUgaXMganVzdCBhIHNlbGVjdGlvbiB0aGUgTGlzdEl0ZW0gY29udGVudCBwcm9wZXJ0eSB3aWxsIGJlIHJldHVybmVkLFxuXHQgKiBvdGhlcndpc2UgdGhlIHBsYWNlaG9sZGVyIHdpbGwgYmUgcmV0dXJuZWQuXG5cdCAqL1xuXHRnZXREaXNwbGF5U3RyaW5nVmFsdWUoKTogT2JzZXJ2YWJsZTxzdHJpbmc+IHtcblx0XHRpZiAoIXRoaXMudmlldyB8fCB0aGlzLnNrZWxldG9uKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGxldCBzZWxlY3RlZCA9IHRoaXMudmlldy5nZXRTZWxlY3RlZCgpO1xuXHRcdGlmIChzZWxlY3RlZC5sZW5ndGggJiYgKCF0aGlzLmRpc3BsYXlWYWx1ZSB8fCAhdGhpcy5pc1JlbmRlclN0cmluZygpKSkge1xuXHRcdFx0aWYgKHRoaXMudHlwZSA9PT0gXCJtdWx0aVwiKSB7XG5cdFx0XHRcdHJldHVybiBvZih0aGlzLnBsYWNlaG9sZGVyKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBvZihzZWxlY3RlZFswXS5jb250ZW50KTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKHNlbGVjdGVkLmxlbmd0aCAmJiB0aGlzLmlzUmVuZGVyU3RyaW5nKCkpIHtcblx0XHRcdHJldHVybiBvZih0aGlzLmRpc3BsYXlWYWx1ZSBhcyBzdHJpbmcpO1xuXHRcdH1cblx0XHRyZXR1cm4gb2YodGhpcy5wbGFjZWhvbGRlcik7XG5cdH1cblxuXHRpc1JlbmRlclN0cmluZygpOiBib29sZWFuIHtcblx0XHRyZXR1cm4gdHlwZW9mIHRoaXMuZGlzcGxheVZhbHVlID09PSBcInN0cmluZ1wiO1xuXHR9XG5cblx0Z2V0UmVuZGVyVGVtcGxhdGVDb250ZXh0KCkge1xuXHRcdGlmICghdGhpcy52aWV3KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGxldCBzZWxlY3RlZCA9IHRoaXMudmlldy5nZXRTZWxlY3RlZCgpO1xuXHRcdGlmICh0aGlzLnR5cGUgPT09IFwibXVsdGlcIikge1xuXHRcdFx0cmV0dXJuIHsgaXRlbXM6IHNlbGVjdGVkIH07XG5cdFx0fSBlbHNlIGlmIChzZWxlY3RlZCAmJiBzZWxlY3RlZC5sZW5ndGggPiAwKSB7XG5cdFx0XHRyZXR1cm4geyBpdGVtOiBzZWxlY3RlZFswXSB9OyAvLyB0aGlzIGlzIHRvIGJlIGNvbXBhdGlibGUgd2l0aCB0aGUgZHJvcGRvd24tbGlzdCB0ZW1wbGF0ZVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4ge307XG5cdFx0fVxuXHR9XG5cblx0Z2V0U2VsZWN0ZWRDb3VudCgpOiBudW1iZXIge1xuXHRcdGlmICh0aGlzLnZpZXcuZ2V0U2VsZWN0ZWQoKSkge1xuXHRcdFx0cmV0dXJuIHRoaXMudmlldy5nZXRTZWxlY3RlZCgpLmxlbmd0aDtcblx0XHR9XG5cdH1cblxuXHRjbGVhclNlbGVjdGVkKCkge1xuXHRcdGlmICh0aGlzLmRpc2FibGVkIHx8IHRoaXMuZ2V0U2VsZWN0ZWRDb3VudCgpID09PSAwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLnZpZXcuZ2V0TGlzdEl0ZW1zKCkpIHtcblx0XHRcdGl0ZW0uc2VsZWN0ZWQgPSBmYWxzZTtcblx0XHR9XG5cdFx0dGhpcy5zZWxlY3RlZC5lbWl0KFtdKTtcblx0XHR0aGlzLnByb3BhZ2F0ZUNoYW5nZShbXSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlcmUgaXMgYSB2YWx1ZSBzZWxlY3RlZC5cblx0ICovXG5cdHZhbHVlU2VsZWN0ZWQoKTogYm9vbGVhbiB7XG5cdFx0aWYgKHRoaXMudmlldy5nZXRTZWxlY3RlZCgpKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0X25vb3AoKSB7IH1cblx0LyoqXG5cdCAqIEhhbmRsZXMgY2xpY2tzIG91dHNpZGUgb2YgdGhlIGBEcm9wZG93bmAuXG5cdCAqL1xuXHRfb3V0c2lkZUNsaWNrKGV2ZW50KSB7XG5cdFx0aWYgKCF0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5jb250YWlucyhldmVudC50YXJnZXQpICYmXG5cdFx0XHQvLyBpZiB3ZSdyZSBhcHBlbmRUb0JvZHkgdGhlIGxpc3QgaXNuJ3Qgd2l0aGluIHRoZSBfZWxlbWVudFJlZixcblx0XHRcdC8vIHNvIHdlJ3ZlIGdvdCB0byBjaGVjayBpZiBvdXIgdGFyZ2V0IGlzIHBvc3NpYmx5IGluIHRoZXJlIHRvby5cblx0XHRcdCF0aGlzLmRyb3Bkb3duTWVudS5uYXRpdmVFbGVtZW50LmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpIHtcblx0XHRcdHRoaXMuY2xvc2VNZW51KCk7XG5cdFx0fVxuXHR9XG5cdF9vdXRzaWRlS2V5KGV2ZW50KSB7XG5cdFx0aWYgKCF0aGlzLm1lbnVJc0Nsb3NlZCAmJiBldmVudC5rZXkgPT09IFwiVGFiXCIgJiYgdGhpcy5kcm9wZG93bk1lbnUubmF0aXZlRWxlbWVudC5jb250YWlucyhldmVudC50YXJnZXQgYXMgTm9kZSkpIHtcblx0XHRcdHRoaXMuY2xvc2VNZW51KCk7XG5cdFx0fVxuXHR9XG5cdC8qKlxuXHQgKiBIYW5kbGVzIGtleWJvYXJkIGV2ZW50cyBzbyB1c2VycyBhcmUgY29udHJvbGxpbmcgdGhlIGBEcm9wZG93bmAgaW5zdGVhZCBvZiB1bmludGVudGlvbmFsbHkgY29udHJvbGxpbmcgb3V0c2lkZSBlbGVtZW50cy5cblx0ICovXG5cdF9rZXlib2FyZE5hdihldmVudDogS2V5Ym9hcmRFdmVudCkge1xuXHRcdGlmIChldmVudC5rZXkgPT09IFwiRXNjYXBlXCIgJiYgIXRoaXMubWVudUlzQ2xvc2VkKSB7XG5cdFx0XHRldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTsgIC8vIGRvbid0IHVuaW50ZW50aW9uYWxseSBjbG9zZSBtb2RhbCBpZiBpbnNpZGUgb2YgaXRcblx0XHR9XG5cdFx0aWYgKGV2ZW50LmtleSA9PT0gXCJFc2NhcGVcIikge1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdHRoaXMuY2xvc2VNZW51KCk7XG5cdFx0XHR0aGlzLmRyb3Bkb3duQnV0dG9uLm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcblx0XHR9IGVsc2UgaWYgKCF0aGlzLm1lbnVJc0Nsb3NlZCAmJiBldmVudC5rZXkgPT09IFwiVGFiXCIpIHtcblx0XHRcdC8vIHRoaXMgd2F5IGZvY3VzIHdpbGwgc3RhcnQgb24gdGhlIG5leHQgZm9jdXNhYmxlIGl0ZW0gZnJvbSB0aGUgZHJvcGRvd25cblx0XHRcdC8vIG5vdCB0aGUgdG9wIG9mIHRoZSBib2R5IVxuXHRcdFx0dGhpcy5kcm9wZG93bkJ1dHRvbi5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG5cdFx0XHR0aGlzLmRyb3Bkb3duQnV0dG9uLm5hdGl2ZUVsZW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgS2V5Ym9hcmRFdmVudChcImtleWRvd25cIiwgeyBidWJibGVzOiB0cnVlLCBjYW5jZWxhYmxlOiB0cnVlLCBrZXk6IFwiVGFiXCIgfSkpO1xuXHRcdFx0dGhpcy5jbG9zZU1lbnUoKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyB0aGUgYERyb3Bkb3duYCBsaXN0IGFwcGVuZGluZyBpdCB0byB0aGUgZHJvcGRvd24gcGFyZW50IG9iamVjdCBpbnN0ZWFkIG9mIHRoZSBib2R5LlxuXHQgKi9cblx0X2FwcGVuZFRvRHJvcGRvd24oKSB7XG5cdFx0dGhpcy5kcm9wZG93blNlcnZpY2UuYXBwZW5kVG9Ecm9wZG93bih0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCk7XG5cdFx0dGhpcy5kcm9wZG93bk1lbnUubmF0aXZlRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLmtleWJvYXJkTmF2LCB0cnVlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIHRoZSBgRHJvcGRvd25gIGxpc3QgYXMgYW4gZWxlbWVudCB0aGF0IGlzIGFwcGVuZGVkIHRvIHRoZSBET00gYm9keS5cblx0ICovXG5cdF9hcHBlbmRUb0JvZHkoKSB7XG5cdFx0Y29uc3QgbGlnaHRDbGFzcyA9IHRoaXMudGhlbWUgPT09IFwibGlnaHRcIiA/IFwiIGNkcy0tbGlzdC1ib3gtLWxpZ2h0XCIgOiBcIlwiO1xuXHRcdGNvbnN0IGV4cGFuZGVkQ2xhc3MgPSAhdGhpcy5tZW51SXNDbG9zZWQgPyBcIiBjZHMtLWxpc3QtYm94LS1leHBhbmRlZFwiIDogXCJcIjtcblx0XHR0aGlzLmRyb3Bkb3duU2VydmljZS5hcHBlbmRUb0JvZHkoXG5cdFx0XHR0aGlzLmRyb3Bkb3duQnV0dG9uLm5hdGl2ZUVsZW1lbnQsXG5cdFx0XHR0aGlzLmRyb3Bkb3duTWVudS5uYXRpdmVFbGVtZW50LFxuXHRcdFx0YCR7dGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuY2xhc3NOYW1lfSR7bGlnaHRDbGFzc30ke2V4cGFuZGVkQ2xhc3N9YCk7XG5cdFx0dGhpcy5kcm9wZG93bk1lbnUubmF0aXZlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLmtleWJvYXJkTmF2LCB0cnVlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEZXRlY3RzIHdoZXRoZXIgb3Igbm90IHRoZSBgRHJvcGRvd25gIGxpc3QgaXMgdmlzaWJsZSB3aXRoaW4gYWxsIHNjcm9sbGFibGUgcGFyZW50cy5cblx0ICogVGhpcyBjYW4gYmUgb3ZlcnJpZGRlbiBieSBwYXNzaW5nIGluIGEgdmFsdWUgdG8gdGhlIGBkcm9wVXBgIGlucHV0LlxuXHQgKi9cblx0X3Nob3VsZERyb3BVcCgpIHtcblx0XHQvLyBjaGVjayBpZiBkcm9wZG93bk1lbnUgZXhpc3RzIGZpcnN0LlxuXHRcdGNvbnN0IG1lbnUgPSB0aGlzLmRyb3Bkb3duTWVudSAmJiB0aGlzLmRyb3Bkb3duTWVudS5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCIuY2RzLS1saXN0LWJveF9fbWVudVwiKTtcblx0XHQvLyBjaGVjayBpZiBtZW51IGV4aXN0cyBmaXJzdC5cblx0XHRjb25zdCBtZW51UmVjdCA9IG1lbnUgJiYgbWVudS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHRpZiAobWVudSAmJiBtZW51UmVjdCkge1xuXHRcdFx0Y29uc3Qgc2Nyb2xsYWJsZVBhcmVudHMgPSBnZXRTY3JvbGxhYmxlUGFyZW50cyhtZW51KTtcblx0XHRcdHJldHVybiBzY3JvbGxhYmxlUGFyZW50cy5yZWR1Y2UoKHNob3VsZERyb3BVcDogYm9vbGVhbiwgcGFyZW50OiBIVE1MRWxlbWVudCkgPT4ge1xuXHRcdFx0XHRjb25zdCBwYXJlbnRSZWN0ID0gcGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdFx0XHRjb25zdCBpc0JlbG93UGFyZW50ID0gIShtZW51UmVjdC5ib3R0b20gPD0gcGFyZW50UmVjdC5ib3R0b20pO1xuXHRcdFx0XHRyZXR1cm4gc2hvdWxkRHJvcFVwIHx8IGlzQmVsb3dQYXJlbnQ7XG5cdFx0XHR9LCBmYWxzZSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEV4cGFuZHMgdGhlIGRyb3Bkb3duIG1lbnUgaW4gdGhlIHZpZXcuXG5cdCAqL1xuXHRvcGVuTWVudSgpIHtcblx0XHQvLyBwcmV2ZW50cyB0aGUgZHJvcGRvd24gZnJvbSBvcGVuaW5nIHdoZW4gbGlzdCBvZiBpdGVtcyBpcyBlbXB0eVxuXHRcdGlmICh0aGlzLnZpZXcuZ2V0TGlzdEl0ZW1zKCkubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fZHJvcFVwID0gZmFsc2U7XG5cdFx0dGhpcy5tZW51SXNDbG9zZWQgPSBmYWxzZTtcblxuXHRcdC8vIG1vdmUgdGhlIGRyb3Bkb3duIGxpc3QgdG8gdGhlIGJvZHkgaWYgd2UncmUgbm90IGFwcGVuZGluZyBpbmxpbmVcblx0XHQvLyBhbmQgcG9zaXRpb24gaXQgcmVsYXRpdmUgdG8gdGhlIGRyb3Bkb3duIHdyYXBwZXJcblx0XHRpZiAoIXRoaXMuYXBwZW5kSW5saW5lKSB7XG5cdFx0XHRjb25zdCB0YXJnZXQgPSB0aGlzLmRyb3Bkb3duQnV0dG9uLm5hdGl2ZUVsZW1lbnQ7XG5cdFx0XHRjb25zdCBwYXJlbnQgPSB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcblx0XHRcdHRoaXMudmlzaWJpbGl0eVN1YnNjcmlwdGlvbiA9IHRoaXMuZWxlbWVudFNlcnZpY2Vcblx0XHRcdFx0LnZpc2liaWxpdHkodGFyZ2V0LCBwYXJlbnQpXG5cdFx0XHRcdC5zdWJzY3JpYmUodmFsdWUgPT4ge1xuXHRcdFx0XHRcdGlmICghdmFsdWUudmlzaWJsZSkge1xuXHRcdFx0XHRcdFx0dGhpcy5jbG9zZU1lbnUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0dGhpcy5fYXBwZW5kVG9Cb2R5KCk7XG5cdFx0fVxuXG5cdFx0Ly8gc2V0IHRoZSBkcm9wZG93biBtZW51IHRvIGRyb3AgdXAgaWYgaXQncyBuZWFyIHRoZSBib3R0b20gb2YgdGhlIHNjcmVlblxuXHRcdC8vIHNldFRpbWVvdXQgbGV0cyB1cyBtZWFzdXJlIGFmdGVyIGl0J3MgdmlzaWJsZSBpbiB0aGUgRE9NXG5cdFx0c2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHRpZiAodGhpcy5kcm9wVXAgPT09IG51bGwgfHwgdGhpcy5kcm9wVXAgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0aGlzLl9kcm9wVXAgPSB0aGlzLl9zaG91bGREcm9wVXAoKTtcblx0XHRcdH1cblx0XHR9LCAwKTtcblxuXHRcdC8vIHdlIGJpbmQgbm9vcCB0byBkb2N1bWVudC5ib2R5LmZpcnN0RWxlbWVudENoaWxkIHRvIGFsbG93IHNhZmFyaSB0byBmaXJlIGV2ZW50c1xuXHRcdC8vIGZyb20gZG9jdW1lbnQuIFRoZW4gd2UgdW5iaW5kIGV2ZXJ5dGhpbmcgbGF0ZXIgdG8ga2VlcCB0aGluZ3MgbGlnaHQuXG5cdFx0ZG9jdW1lbnQuYm9keS5maXJzdEVsZW1lbnRDaGlsZC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5ub29wLCB0cnVlKTtcblx0XHRkb2N1bWVudC5ib2R5LmZpcnN0RWxlbWVudENoaWxkLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMubm9vcCwgdHJ1ZSk7XG5cdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMub3V0c2lkZUNsaWNrLCB0cnVlKTtcblx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLm91dHNpZGVLZXksIHRydWUpO1xuXHRcdHNldFRpbWVvdXQoKCkgPT4gdGhpcy52aWV3LmluaXRGb2N1cygpLCAwKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb2xsYXBzaW5nIHRoZSBkcm9wZG93biBtZW51IGFuZCByZW1vdmluZyB1bm5lY2Vzc2FyeSBgRXZlbnRMaXN0ZW5lcnNgLlxuXHQgKi9cblx0Y2xvc2VNZW51KCkge1xuXHRcdC8vIHJldHVybiBlYXJseSBpZiB0aGUgbWVudSBpcyBhbHJlYWR5IGNsb3NlZFxuXHRcdGlmICh0aGlzLm1lbnVJc0Nsb3NlZCkgeyByZXR1cm47IH1cblx0XHR0aGlzLm1lbnVJc0Nsb3NlZCA9IHRydWU7XG5cdFx0dGhpcy5jaGVja0ZvclJlb3JkZXIoKTtcblx0XHR0aGlzLm9uQ2xvc2UuZW1pdCgpO1xuXHRcdHRoaXMuY2xvc2UuZW1pdCgpO1xuXG5cdFx0Ly8gZm9jdXMgdGhlIHRyaWdnZXIgYnV0dG9uIHdoZW4gd2UgY2xvc2UgLi4uXG5cdFx0dGhpcy5kcm9wZG93bkJ1dHRvbi5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG5cblx0XHQvLyByZW1vdmUgdGhlIGNvbmRpdGlvbmFsIG9uY2UgdGhpcyBhcGkgaXMgc2V0dGxlZCBhbmQgcGFydCBvZiBhYnN0cmFjdC1kcm9wZG93bi12aWV3LmNsYXNzXG5cdFx0aWYgKHRoaXMudmlld1tcImRpc2FibGVTY3JvbGxcIl0pIHtcblx0XHRcdHRoaXMudmlld1tcImRpc2FibGVTY3JvbGxcIl0oKTtcblx0XHR9XG5cblx0XHQvLyBtb3ZlIHRoZSBsaXN0IGJhY2sgaW4gdGhlIGNvbXBvbmVudCBvbiBjbG9zZVxuXHRcdGlmICghdGhpcy5hcHBlbmRJbmxpbmUpIHtcblx0XHRcdHRoaXMudmlzaWJpbGl0eVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuXHRcdFx0dGhpcy5fYXBwZW5kVG9Ecm9wZG93bigpO1xuXHRcdH1cblx0XHRkb2N1bWVudC5ib2R5LmZpcnN0RWxlbWVudENoaWxkLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLm5vb3AsIHRydWUpO1xuXHRcdGRvY3VtZW50LmJvZHkuZmlyc3RFbGVtZW50Q2hpbGQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5ub29wLCB0cnVlKTtcblx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5vdXRzaWRlQ2xpY2ssIHRydWUpO1xuXHRcdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMub3V0c2lkZUtleSwgdHJ1ZSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udHJvbHMgdG9nZ2xpbmcgbWVudSBzdGF0ZXMgYmV0d2VlbiBvcGVuL2V4cGFuZGVkIGFuZCBjbG9zZWQvY29sbGFwc2VkLlxuXHQgKi9cblx0dG9nZ2xlTWVudSgpIHtcblx0XHRpZiAodGhpcy5tZW51SXNDbG9zZWQpIHtcblx0XHRcdHRoaXMub3Blbk1lbnUoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5jbG9zZU1lbnUoKTtcblx0XHR9XG5cdH1cblxuXHRwdWJsaWMgaXNUZW1wbGF0ZSh2YWx1ZSkge1xuXHRcdHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFRlbXBsYXRlUmVmO1xuXHR9XG5cblx0aGFuZGxlRm9jdXMoZXZlbnQ6IEZvY3VzRXZlbnQpIHtcblx0XHR0aGlzLl9pc0ZvY3VzZWQgPSBldmVudC50eXBlID09PSBcImZvY3VzXCI7XG5cdFx0aWYgKGV2ZW50LnR5cGUgPT09IFwiYmx1clwiKSB7XG5cdFx0XHR0aGlzLm9uQmx1cigpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBDb250cm9scyB3aGVuIGl0J3MgbmVlZGVkIHRvIGFwcGx5IHRoZSBzZWxlY3Rpb24gZmVlZGJhY2tcblx0ICovXG5cdHByb3RlY3RlZCBjaGVja0ZvclJlb3JkZXIoKSB7XG5cdFx0Y29uc3QgdG9wQWZ0ZXJSZW9wZW4gPSB0aGlzLm1lbnVJc0Nsb3NlZCAmJiB0aGlzLnNlbGVjdGlvbkZlZWRiYWNrID09PSBcInRvcC1hZnRlci1yZW9wZW5cIjtcblx0XHRpZiAoKHRoaXMudHlwZSA9PT0gXCJtdWx0aVwiKSAmJiAodG9wQWZ0ZXJSZW9wZW4gfHwgdGhpcy5zZWxlY3Rpb25GZWVkYmFjayA9PT0gXCJ0b3BcIikpIHtcblx0XHRcdHRoaXMudmlldy5yZW9yZGVyU2VsZWN0ZWQoKTtcblx0XHR9XG5cdH1cbn1cbiJdfQ==