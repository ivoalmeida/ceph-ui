import { Component, Input, ViewChild } from "@angular/core";
import { merge } from "carbon-components-angular/utils";
import * as i0 from "@angular/core";
import * as i1 from "carbon-components-angular/i18n";
import * as i2 from "@angular/common";
import * as i3 from "carbon-components-angular/icon";
/**
 * Get started with importing the module:
 *
 * ```typescript
 * import { TilesModule } from 'carbon-components-angular';
 * ```
 *
 * [See demo](../../?path=/story/components-tiles-expandable--basic)
 */
export class ExpandableTile {
    constructor(i18n, element) {
        this.i18n = i18n;
        this.element = element;
        /**
         * @deprecated since v5 - Use `cdsLayer` directive instead
         * Set to `"light"` to apply the light style
         */
        this.theme = "dark";
        /**
         * Controls the expanded state
         */
        this.expanded = false;
        /**
         * Controls the interactive state
         */
        this.interactive = false;
        this.tileMaxHeight = 0;
        this.currentExpandedHeight = 0;
        this.expand = this.i18n.getOverridable("TILES.EXPAND");
        this.collapse = this.i18n.getOverridable("TILES.COLLAPSE");
    }
    /**
     * Expects an object that contains some or all of:
     * ```
     * {
     *		"EXPAND": "Expand",
     *		"COLLAPSE": "Collapse",
     * }
     * ```
     */
    set translations(value) {
        const valueWithDefaults = merge(this.i18n.getMultiple("TILES"), value);
        this.expand.override(valueWithDefaults.EXPAND);
        this.collapse.override(valueWithDefaults.COLLAPSE);
    }
    ngAfterViewInit() {
        this.updateMaxHeight();
    }
    get expandedHeight() {
        const tile = this.element.nativeElement.querySelector(".cds--tile");
        const tilePadding = parseInt(getComputedStyle(tile).paddingBottom, 10) + parseInt(getComputedStyle(tile).paddingTop, 10);
        const expandedHeight = this.tileMaxHeight + tilePadding;
        if (!isNaN(expandedHeight)) {
            this.currentExpandedHeight = expandedHeight;
        }
        return this.currentExpandedHeight;
    }
    updateMaxHeight() {
        if (this.expanded) {
            this.tileMaxHeight = this.tileContainer.nativeElement.getBoundingClientRect().height;
        }
        else {
            this.tileMaxHeight = this.element.nativeElement.querySelector(".cds--tile-content__above-the-fold").getBoundingClientRect().height;
        }
    }
    onClick() {
        this.expanded = !this.expanded;
        this.updateMaxHeight();
    }
}
ExpandableTile.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: ExpandableTile, deps: [{ token: i1.I18n }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
ExpandableTile.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.3.0", type: ExpandableTile, selector: "cds-expandable-tile, ibm-expandable-tile", inputs: { theme: "theme", expanded: "expanded", interactive: "interactive", translations: "translations" }, viewQueries: [{ propertyName: "tileContainer", first: true, predicate: ["container"], descendants: true }], ngImport: i0, template: `
		<button
			*ngIf="!interactive"
			class="cds--tile cds--tile--expandable"
			[ngClass]="{
				'cds--tile--is-expanded' : expanded,
				'cds--tile--light': theme === 'light'
			}"
			[ngStyle]="{'max-height': expandedHeight + 'px'}"
			type="button"
			(click)="onClick()"
			[attr.aria-expanded]="expanded"
			[attr.title]="(expanded ? collapse.subject : expand.subject) | async">
				<ng-container *ngTemplateOutlet="expandableTileContent"></ng-container>
		</button>

		<div
			*ngIf="interactive"
			class="cds--tile cds--tile--expandable cds--tile--expandable--interactive"
			[ngClass]="{
				'cds--tile--is-expanded' : expanded,
				'cds--tile--light': theme === 'light'
			}"
			[ngStyle]="{'max-height': expandedHeight + 'px'}"
			[attr.title]="(expanded ? collapse.subject : expand.subject) | async">
			<ng-container *ngTemplateOutlet="expandableTileContent"></ng-container>
		</div>

		<ng-template #chevronIcon>
			<svg cdsIcon="chevron--down" size="16"></svg>
		</ng-template>

		<ng-template #expandableTileContent>
			<div #container>
				<div class="cds--tile-content">
					<ng-content select="[cdsAboveFold],[ibmAboveFold],.cds--tile-content__above-the-fold"></ng-content>
				</div>
				<div *ngIf="!interactive" class="cds--tile__chevron">
					<ng-container *ngTemplateOutlet="chevronIcon"></ng-container>
				</div>
				<button
					*ngIf="interactive"
					class="cds--tile__chevron cds--tile__chevron--interactive"
					type="button"
					(click)="onClick()"
					[attr.aria-expanded]="expanded"
					[attr.aria-label]="(expanded ? collapse.subject : expand.subject) | async">
					<ng-container *ngTemplateOutlet="chevronIcon"></ng-container>
				</button>
				<div class="cds--tile-content">
					<ng-content select="[cdsBelowFold],[ibmBelowFold],.cds--tile-content__below-the-fold"></ng-content>
				</div>
			</div>
		</ng-template>
	`, isInline: true, dependencies: [{ kind: "directive", type: i2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i2.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: i2.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "directive", type: i3.IconDirective, selector: "[cdsIcon], [ibmIcon]", inputs: ["ibmIcon", "cdsIcon", "size", "title", "ariaLabel", "ariaLabelledBy", "ariaHidden", "isFocusable"] }, { kind: "pipe", type: i2.AsyncPipe, name: "async" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: ExpandableTile, decorators: [{
            type: Component,
            args: [{
                    selector: "cds-expandable-tile, ibm-expandable-tile",
                    template: `
		<button
			*ngIf="!interactive"
			class="cds--tile cds--tile--expandable"
			[ngClass]="{
				'cds--tile--is-expanded' : expanded,
				'cds--tile--light': theme === 'light'
			}"
			[ngStyle]="{'max-height': expandedHeight + 'px'}"
			type="button"
			(click)="onClick()"
			[attr.aria-expanded]="expanded"
			[attr.title]="(expanded ? collapse.subject : expand.subject) | async">
				<ng-container *ngTemplateOutlet="expandableTileContent"></ng-container>
		</button>

		<div
			*ngIf="interactive"
			class="cds--tile cds--tile--expandable cds--tile--expandable--interactive"
			[ngClass]="{
				'cds--tile--is-expanded' : expanded,
				'cds--tile--light': theme === 'light'
			}"
			[ngStyle]="{'max-height': expandedHeight + 'px'}"
			[attr.title]="(expanded ? collapse.subject : expand.subject) | async">
			<ng-container *ngTemplateOutlet="expandableTileContent"></ng-container>
		</div>

		<ng-template #chevronIcon>
			<svg cdsIcon="chevron--down" size="16"></svg>
		</ng-template>

		<ng-template #expandableTileContent>
			<div #container>
				<div class="cds--tile-content">
					<ng-content select="[cdsAboveFold],[ibmAboveFold],.cds--tile-content__above-the-fold"></ng-content>
				</div>
				<div *ngIf="!interactive" class="cds--tile__chevron">
					<ng-container *ngTemplateOutlet="chevronIcon"></ng-container>
				</div>
				<button
					*ngIf="interactive"
					class="cds--tile__chevron cds--tile__chevron--interactive"
					type="button"
					(click)="onClick()"
					[attr.aria-expanded]="expanded"
					[attr.aria-label]="(expanded ? collapse.subject : expand.subject) | async">
					<ng-container *ngTemplateOutlet="chevronIcon"></ng-container>
				</button>
				<div class="cds--tile-content">
					<ng-content select="[cdsBelowFold],[ibmBelowFold],.cds--tile-content__below-the-fold"></ng-content>
				</div>
			</div>
		</ng-template>
	`
                }]
        }], ctorParameters: function () { return [{ type: i1.I18n }, { type: i0.ElementRef }]; }, propDecorators: { theme: [{
                type: Input
            }], expanded: [{
                type: Input
            }], interactive: [{
                type: Input
            }], translations: [{
                type: Input
            }], tileContainer: [{
                type: ViewChild,
                args: ["container"]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXhwYW5kYWJsZS10aWxlLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy90aWxlcy9leHBhbmRhYmxlLXRpbGUuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTixTQUFTLEVBQ1QsS0FBSyxFQUdMLFNBQVMsRUFDVCxNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQUUsS0FBSyxFQUFFLE1BQU0saUNBQWlDLENBQUM7Ozs7O0FBT3hEOzs7Ozs7OztHQVFHO0FBMkRILE1BQU0sT0FBTyxjQUFjO0lBdUMxQixZQUFzQixJQUFVLEVBQVksT0FBbUI7UUFBekMsU0FBSSxHQUFKLElBQUksQ0FBTTtRQUFZLFlBQU8sR0FBUCxPQUFPLENBQVk7UUF0Qy9EOzs7V0FHRztRQUNNLFVBQUssR0FBcUIsTUFBTSxDQUFDO1FBRTFDOztXQUVHO1FBQ00sYUFBUSxHQUFHLEtBQUssQ0FBQztRQUMxQjs7V0FFRztRQUNNLGdCQUFXLEdBQUcsS0FBSyxDQUFDO1FBbUI3QixrQkFBYSxHQUFHLENBQUMsQ0FBQztRQUNsQiwwQkFBcUIsR0FBRyxDQUFDLENBQUM7UUFFMUIsV0FBTSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBQ2xELGFBQVEsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO0lBRVksQ0FBQztJQXhCbkU7Ozs7Ozs7O09BUUc7SUFDSCxJQUNJLFlBQVksQ0FBQyxLQUFpQztRQUNqRCxNQUFNLGlCQUFpQixHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUN2RSxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUMvQyxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxpQkFBaUIsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNwRCxDQUFDO0lBWUQsZUFBZTtRQUNkLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztJQUN4QixDQUFDO0lBRUQsSUFBSSxjQUFjO1FBQ2pCLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLGFBQWEsQ0FBQyxZQUFZLENBQUMsQ0FBQztRQUNwRSxNQUFNLFdBQVcsR0FDZCxRQUFRLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUMsYUFBYSxFQUFFLEVBQUUsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsQ0FBQyxVQUFVLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDeEcsTUFBTSxjQUFjLEdBQUcsSUFBSSxDQUFDLGFBQWEsR0FBRyxXQUFXLENBQUM7UUFDeEQsSUFBSSxDQUFDLEtBQUssQ0FBQyxjQUFjLENBQUMsRUFBRTtZQUMzQixJQUFJLENBQUMscUJBQXFCLEdBQUcsY0FBYyxDQUFDO1NBQzVDO1FBQ0QsT0FBTyxJQUFJLENBQUMscUJBQXFCLENBQUM7SUFDbkMsQ0FBQztJQUVELGVBQWU7UUFDZCxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDbEIsSUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLGFBQWEsQ0FBQyxxQkFBcUIsRUFBRSxDQUFDLE1BQU0sQ0FBQztTQUNyRjthQUFNO1lBQ04sSUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxhQUFhLENBQUMsb0NBQW9DLENBQUMsQ0FBQyxxQkFBcUIsRUFBRSxDQUFDLE1BQU0sQ0FBQztTQUNuSTtJQUNGLENBQUM7SUFFRCxPQUFPO1FBQ04sSUFBSSxDQUFDLFFBQVEsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUM7UUFDL0IsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO0lBQ3hCLENBQUM7OzJHQW5FVyxjQUFjOytGQUFkLGNBQWMsd1NBeERoQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBc0RUOzJGQUVXLGNBQWM7a0JBMUQxQixTQUFTO21CQUFDO29CQUNWLFFBQVEsRUFBRSwwQ0FBMEM7b0JBQ3BELFFBQVEsRUFBRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBc0RUO2lCQUNEO29IQU1TLEtBQUs7c0JBQWIsS0FBSztnQkFLRyxRQUFRO3NCQUFoQixLQUFLO2dCQUlHLFdBQVc7c0JBQW5CLEtBQUs7Z0JBV0YsWUFBWTtzQkFEZixLQUFLO2dCQU9rQixhQUFhO3NCQUFwQyxTQUFTO3VCQUFDLFdBQVciLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuXHRDb21wb25lbnQsXG5cdElucHV0LFxuXHRFbGVtZW50UmVmLFxuXHRBZnRlclZpZXdJbml0LFxuXHRWaWV3Q2hpbGRcbn0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcbmltcG9ydCB7IEkxOG4gfSBmcm9tIFwiY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci9pMThuXCI7XG5pbXBvcnQgeyBtZXJnZSB9IGZyb20gXCJjYXJib24tY29tcG9uZW50cy1hbmd1bGFyL3V0aWxzXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXhwYW5kYWJsZVRpbGVUcmFuc2xhdGlvbnMge1xuXHRFWFBBTkQ6IHN0cmluZztcblx0Q09MTEFQU0U6IHN0cmluZztcbn1cblxuLyoqXG4gKiBHZXQgc3RhcnRlZCB3aXRoIGltcG9ydGluZyB0aGUgbW9kdWxlOlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IFRpbGVzTW9kdWxlIH0gZnJvbSAnY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhcic7XG4gKiBgYGBcbiAqXG4gKiBbU2VlIGRlbW9dKC4uLy4uLz9wYXRoPS9zdG9yeS9jb21wb25lbnRzLXRpbGVzLWV4cGFuZGFibGUtLWJhc2ljKVxuICovXG5AQ29tcG9uZW50KHtcblx0c2VsZWN0b3I6IFwiY2RzLWV4cGFuZGFibGUtdGlsZSwgaWJtLWV4cGFuZGFibGUtdGlsZVwiLFxuXHR0ZW1wbGF0ZTogYFxuXHRcdDxidXR0b25cblx0XHRcdCpuZ0lmPVwiIWludGVyYWN0aXZlXCJcblx0XHRcdGNsYXNzPVwiY2RzLS10aWxlIGNkcy0tdGlsZS0tZXhwYW5kYWJsZVwiXG5cdFx0XHRbbmdDbGFzc109XCJ7XG5cdFx0XHRcdCdjZHMtLXRpbGUtLWlzLWV4cGFuZGVkJyA6IGV4cGFuZGVkLFxuXHRcdFx0XHQnY2RzLS10aWxlLS1saWdodCc6IHRoZW1lID09PSAnbGlnaHQnXG5cdFx0XHR9XCJcblx0XHRcdFtuZ1N0eWxlXT1cInsnbWF4LWhlaWdodCc6IGV4cGFuZGVkSGVpZ2h0ICsgJ3B4J31cIlxuXHRcdFx0dHlwZT1cImJ1dHRvblwiXG5cdFx0XHQoY2xpY2spPVwib25DbGljaygpXCJcblx0XHRcdFthdHRyLmFyaWEtZXhwYW5kZWRdPVwiZXhwYW5kZWRcIlxuXHRcdFx0W2F0dHIudGl0bGVdPVwiKGV4cGFuZGVkID8gY29sbGFwc2Uuc3ViamVjdCA6IGV4cGFuZC5zdWJqZWN0KSB8IGFzeW5jXCI+XG5cdFx0XHRcdDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJleHBhbmRhYmxlVGlsZUNvbnRlbnRcIj48L25nLWNvbnRhaW5lcj5cblx0XHQ8L2J1dHRvbj5cblxuXHRcdDxkaXZcblx0XHRcdCpuZ0lmPVwiaW50ZXJhY3RpdmVcIlxuXHRcdFx0Y2xhc3M9XCJjZHMtLXRpbGUgY2RzLS10aWxlLS1leHBhbmRhYmxlIGNkcy0tdGlsZS0tZXhwYW5kYWJsZS0taW50ZXJhY3RpdmVcIlxuXHRcdFx0W25nQ2xhc3NdPVwie1xuXHRcdFx0XHQnY2RzLS10aWxlLS1pcy1leHBhbmRlZCcgOiBleHBhbmRlZCxcblx0XHRcdFx0J2Nkcy0tdGlsZS0tbGlnaHQnOiB0aGVtZSA9PT0gJ2xpZ2h0J1xuXHRcdFx0fVwiXG5cdFx0XHRbbmdTdHlsZV09XCJ7J21heC1oZWlnaHQnOiBleHBhbmRlZEhlaWdodCArICdweCd9XCJcblx0XHRcdFthdHRyLnRpdGxlXT1cIihleHBhbmRlZCA/IGNvbGxhcHNlLnN1YmplY3QgOiBleHBhbmQuc3ViamVjdCkgfCBhc3luY1wiPlxuXHRcdFx0PG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cImV4cGFuZGFibGVUaWxlQ29udGVudFwiPjwvbmctY29udGFpbmVyPlxuXHRcdDwvZGl2PlxuXG5cdFx0PG5nLXRlbXBsYXRlICNjaGV2cm9uSWNvbj5cblx0XHRcdDxzdmcgY2RzSWNvbj1cImNoZXZyb24tLWRvd25cIiBzaXplPVwiMTZcIj48L3N2Zz5cblx0XHQ8L25nLXRlbXBsYXRlPlxuXG5cdFx0PG5nLXRlbXBsYXRlICNleHBhbmRhYmxlVGlsZUNvbnRlbnQ+XG5cdFx0XHQ8ZGl2ICNjb250YWluZXI+XG5cdFx0XHRcdDxkaXYgY2xhc3M9XCJjZHMtLXRpbGUtY29udGVudFwiPlxuXHRcdFx0XHRcdDxuZy1jb250ZW50IHNlbGVjdD1cIltjZHNBYm92ZUZvbGRdLFtpYm1BYm92ZUZvbGRdLC5jZHMtLXRpbGUtY29udGVudF9fYWJvdmUtdGhlLWZvbGRcIj48L25nLWNvbnRlbnQ+XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8ZGl2ICpuZ0lmPVwiIWludGVyYWN0aXZlXCIgY2xhc3M9XCJjZHMtLXRpbGVfX2NoZXZyb25cIj5cblx0XHRcdFx0XHQ8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiY2hldnJvbkljb25cIj48L25nLWNvbnRhaW5lcj5cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHQqbmdJZj1cImludGVyYWN0aXZlXCJcblx0XHRcdFx0XHRjbGFzcz1cImNkcy0tdGlsZV9fY2hldnJvbiBjZHMtLXRpbGVfX2NoZXZyb24tLWludGVyYWN0aXZlXCJcblx0XHRcdFx0XHR0eXBlPVwiYnV0dG9uXCJcblx0XHRcdFx0XHQoY2xpY2spPVwib25DbGljaygpXCJcblx0XHRcdFx0XHRbYXR0ci5hcmlhLWV4cGFuZGVkXT1cImV4cGFuZGVkXCJcblx0XHRcdFx0XHRbYXR0ci5hcmlhLWxhYmVsXT1cIihleHBhbmRlZCA/IGNvbGxhcHNlLnN1YmplY3QgOiBleHBhbmQuc3ViamVjdCkgfCBhc3luY1wiPlxuXHRcdFx0XHRcdDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJjaGV2cm9uSWNvblwiPjwvbmctY29udGFpbmVyPlxuXHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdFx0PGRpdiBjbGFzcz1cImNkcy0tdGlsZS1jb250ZW50XCI+XG5cdFx0XHRcdFx0PG5nLWNvbnRlbnQgc2VsZWN0PVwiW2Nkc0JlbG93Rm9sZF0sW2libUJlbG93Rm9sZF0sLmNkcy0tdGlsZS1jb250ZW50X19iZWxvdy10aGUtZm9sZFwiPjwvbmctY29udGVudD5cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHQ8L2Rpdj5cblx0XHQ8L25nLXRlbXBsYXRlPlxuXHRgXG59KVxuZXhwb3J0IGNsYXNzIEV4cGFuZGFibGVUaWxlIGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCB7XG5cdC8qKlxuXHQgKiBAZGVwcmVjYXRlZCBzaW5jZSB2NSAtIFVzZSBgY2RzTGF5ZXJgIGRpcmVjdGl2ZSBpbnN0ZWFkXG5cdCAqIFNldCB0byBgXCJsaWdodFwiYCB0byBhcHBseSB0aGUgbGlnaHQgc3R5bGVcblx0ICovXG5cdEBJbnB1dCgpIHRoZW1lOiBcImxpZ2h0XCIgfCBcImRhcmtcIiA9IFwiZGFya1wiO1xuXG5cdC8qKlxuXHQgKiBDb250cm9scyB0aGUgZXhwYW5kZWQgc3RhdGVcblx0ICovXG5cdEBJbnB1dCgpIGV4cGFuZGVkID0gZmFsc2U7XG5cdC8qKlxuXHQgKiBDb250cm9scyB0aGUgaW50ZXJhY3RpdmUgc3RhdGVcblx0ICovXG5cdEBJbnB1dCgpIGludGVyYWN0aXZlID0gZmFsc2U7XG5cdC8qKlxuXHQgKiBFeHBlY3RzIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIHNvbWUgb3IgYWxsIG9mOlxuXHQgKiBgYGBcblx0ICoge1xuXHQgKlx0XHRcIkVYUEFORFwiOiBcIkV4cGFuZFwiLFxuXHQgKlx0XHRcIkNPTExBUFNFXCI6IFwiQ29sbGFwc2VcIixcblx0ICogfVxuXHQgKiBgYGBcblx0ICovXG5cdEBJbnB1dCgpXG5cdHNldCB0cmFuc2xhdGlvbnModmFsdWU6IEV4cGFuZGFibGVUaWxlVHJhbnNsYXRpb25zKSB7XG5cdFx0Y29uc3QgdmFsdWVXaXRoRGVmYXVsdHMgPSBtZXJnZSh0aGlzLmkxOG4uZ2V0TXVsdGlwbGUoXCJUSUxFU1wiKSwgdmFsdWUpO1xuXHRcdHRoaXMuZXhwYW5kLm92ZXJyaWRlKHZhbHVlV2l0aERlZmF1bHRzLkVYUEFORCk7XG5cdFx0dGhpcy5jb2xsYXBzZS5vdmVycmlkZSh2YWx1ZVdpdGhEZWZhdWx0cy5DT0xMQVBTRSk7XG5cdH1cblxuXHRAVmlld0NoaWxkKFwiY29udGFpbmVyXCIpIHRpbGVDb250YWluZXI6IEVsZW1lbnRSZWY7XG5cblx0dGlsZU1heEhlaWdodCA9IDA7XG5cdGN1cnJlbnRFeHBhbmRlZEhlaWdodCA9IDA7XG5cblx0ZXhwYW5kID0gdGhpcy5pMThuLmdldE92ZXJyaWRhYmxlKFwiVElMRVMuRVhQQU5EXCIpO1xuXHRjb2xsYXBzZSA9IHRoaXMuaTE4bi5nZXRPdmVycmlkYWJsZShcIlRJTEVTLkNPTExBUFNFXCIpO1xuXG5cdGNvbnN0cnVjdG9yKHByb3RlY3RlZCBpMThuOiBJMThuLCBwcm90ZWN0ZWQgZWxlbWVudDogRWxlbWVudFJlZikge31cblxuXHRuZ0FmdGVyVmlld0luaXQoKSB7XG5cdFx0dGhpcy51cGRhdGVNYXhIZWlnaHQoKTtcblx0fVxuXG5cdGdldCBleHBhbmRlZEhlaWdodCgpIHtcblx0XHRjb25zdCB0aWxlID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcihcIi5jZHMtLXRpbGVcIik7XG5cdFx0Y29uc3QgdGlsZVBhZGRpbmdcblx0XHRcdD0gcGFyc2VJbnQoZ2V0Q29tcHV0ZWRTdHlsZSh0aWxlKS5wYWRkaW5nQm90dG9tLCAxMCkgKyBwYXJzZUludChnZXRDb21wdXRlZFN0eWxlKHRpbGUpLnBhZGRpbmdUb3AsIDEwKTtcblx0XHRjb25zdCBleHBhbmRlZEhlaWdodCA9IHRoaXMudGlsZU1heEhlaWdodCArIHRpbGVQYWRkaW5nO1xuXHRcdGlmICghaXNOYU4oZXhwYW5kZWRIZWlnaHQpKSB7XG5cdFx0XHR0aGlzLmN1cnJlbnRFeHBhbmRlZEhlaWdodCA9IGV4cGFuZGVkSGVpZ2h0O1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5jdXJyZW50RXhwYW5kZWRIZWlnaHQ7XG5cdH1cblxuXHR1cGRhdGVNYXhIZWlnaHQoKSB7XG5cdFx0aWYgKHRoaXMuZXhwYW5kZWQpIHtcblx0XHRcdHRoaXMudGlsZU1heEhlaWdodCA9IHRoaXMudGlsZUNvbnRhaW5lci5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy50aWxlTWF4SGVpZ2h0ID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcihcIi5jZHMtLXRpbGUtY29udGVudF9fYWJvdmUtdGhlLWZvbGRcIikuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xuXHRcdH1cblx0fVxuXG5cdG9uQ2xpY2soKSB7XG5cdFx0dGhpcy5leHBhbmRlZCA9ICF0aGlzLmV4cGFuZGVkO1xuXHRcdHRoaXMudXBkYXRlTWF4SGVpZ2h0KCk7XG5cdH1cbn1cbiJdfQ==