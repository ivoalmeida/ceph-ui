import { Component, Input, Output, EventEmitter, HostBinding, ContentChildren, TemplateRef } from "@angular/core";
import { SelectionTile } from "./selection-tile.component";
import { NG_VALUE_ACCESSOR } from "@angular/forms";
import { Subject } from "rxjs";
import { takeUntil } from "rxjs/operators";
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
/**
 * Get started with importing the module:
 *
 * ```typescript
 * import { TilesModule } from 'carbon-components-angular';
 * ```
 *
 * [See demo](../../?path=/story/components-tiles-grouped--selectable)
 */
export class TileGroup {
    constructor() {
        /**
         * The tile group `name`
         */
        this.name = `tile-group-${TileGroup.tileGroupCount}`;
        /**
         * Set to `true` to support multiple tile selection
         */
        this.multiple = false;
        /**
         * Emits an event when the tile selection changes.
         *
         * Emits an object that looks like:
         * ```javascript
         * {
         * 	value: "something",
         * 	selected: true,
         * 	name: "tile-group-1"
         * }
         * ```
         */
        this.selected = new EventEmitter();
        this.tileGroupClass = true;
        this.unsubscribe$ = new Subject();
        this.unsubscribeTiles$ = new Subject();
        this.onChange = (_) => { };
        this.onTouched = () => { };
        TileGroup.tileGroupCount++;
    }
    ngAfterContentInit() {
        const updateTiles = () => {
            // remove old subscriptions
            this.unsubscribeTiles$.next();
            // react to changes
            // setTimeout to avoid ExpressionChangedAfterItHasBeenCheckedError
            setTimeout(() => {
                this.selectionTiles.forEach(tile => {
                    tile.name = this.name;
                    tile.change
                        .pipe(takeUntil(this.unsubscribeTiles$))
                        .subscribe(() => {
                        this.selected.emit({
                            value: tile.value,
                            selected: tile.selected,
                            name: this.name
                        });
                        this.onChange(tile.value);
                    });
                    tile.multiple = this.multiple;
                });
            });
        };
        updateTiles();
        this.selectionTiles.changes
            .pipe(takeUntil(this.unsubscribe$))
            .subscribe(_ => updateTiles());
    }
    ngOnDestroy() {
        this.unsubscribe$.next();
        this.unsubscribe$.complete();
        // takes care of tile subscriptions when tile-group dies
        this.unsubscribeTiles$.next();
        this.unsubscribeTiles$.complete();
    }
    writeValue(value) {
        if (!this.selectionTiles) {
            return;
        }
        this.selectionTiles.forEach(tile => {
            if (tile.value === value) {
                tile.selected = true;
            }
            else {
                tile.selected = false;
            }
        });
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    isTemplate(value) {
        return value instanceof TemplateRef;
    }
}
TileGroup.tileGroupCount = 0;
TileGroup.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: TileGroup, deps: [], target: i0.ɵɵFactoryTarget.Component });
TileGroup.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.3.0", type: TileGroup, selector: "cds-tile-group, ibm-tile-group", inputs: { name: "name", multiple: "multiple", legend: "legend" }, outputs: { selected: "selected" }, host: { properties: { "class.cds--tile-group": "this.tileGroupClass" } }, providers: [
        {
            provide: NG_VALUE_ACCESSOR,
            useExisting: TileGroup,
            multi: true
        }
    ], queries: [{ propertyName: "selectionTiles", predicate: SelectionTile }], ngImport: i0, template: `
		<fieldset>
			<legend *ngIf="legend" class="cds--label">
				<ng-template *ngIf="isTemplate(legend); else legendLabel;" [ngTemplateOutlet]="legend"></ng-template>
				<ng-template #legendLabel>{{legend}}</ng-template>
			</legend>
			<ng-content select="ibm-selection-tile,cds-selection-tile"></ng-content>
		</fieldset>`, isInline: true, dependencies: [{ kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: TileGroup, decorators: [{
            type: Component,
            args: [{
                    selector: "cds-tile-group, ibm-tile-group",
                    template: `
		<fieldset>
			<legend *ngIf="legend" class="cds--label">
				<ng-template *ngIf="isTemplate(legend); else legendLabel;" [ngTemplateOutlet]="legend"></ng-template>
				<ng-template #legendLabel>{{legend}}</ng-template>
			</legend>
			<ng-content select="ibm-selection-tile,cds-selection-tile"></ng-content>
		</fieldset>`,
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: TileGroup,
                            multi: true
                        }
                    ]
                }]
        }], ctorParameters: function () { return []; }, propDecorators: { name: [{
                type: Input
            }], multiple: [{
                type: Input
            }], legend: [{
                type: Input
            }], selected: [{
                type: Output
            }], tileGroupClass: [{
                type: HostBinding,
                args: ["class.cds--tile-group"]
            }], selectionTiles: [{
                type: ContentChildren,
                args: [SelectionTile]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGlsZS1ncm91cC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvdGlsZXMvdGlsZS1ncm91cC5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNOLFNBQVMsRUFFVCxLQUFLLEVBQ0wsTUFBTSxFQUNOLFlBQVksRUFDWixXQUFXLEVBQ1gsZUFBZSxFQUdmLFdBQVcsRUFDWCxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUFDM0QsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFbkQsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUMvQixPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7OztBQUUzQzs7Ozs7Ozs7R0FRRztBQW1CSCxNQUFNLE9BQU8sU0FBUztJQWtDckI7UUFoQ0E7O1dBRUc7UUFDTSxTQUFJLEdBQUcsY0FBYyxTQUFTLENBQUMsY0FBYyxFQUFFLENBQUM7UUFDekQ7O1dBRUc7UUFDTSxhQUFRLEdBQUcsS0FBSyxDQUFDO1FBSTFCOzs7Ozs7Ozs7OztXQVdHO1FBQ08sYUFBUSxHQUFnQyxJQUFJLFlBQVksRUFBRSxDQUFDO1FBRS9CLG1CQUFjLEdBQUcsSUFBSSxDQUFDO1FBSWxELGlCQUFZLEdBQUcsSUFBSSxPQUFPLEVBQVEsQ0FBQztRQUNuQyxzQkFBaUIsR0FBRyxJQUFJLE9BQU8sRUFBUSxDQUFDO1FBTWxELGFBQVEsR0FBRyxDQUFDLENBQU0sRUFBRSxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBRTNCLGNBQVMsR0FBRyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFMckIsU0FBUyxDQUFDLGNBQWMsRUFBRSxDQUFDO0lBQzVCLENBQUM7SUFNRCxrQkFBa0I7UUFDakIsTUFBTSxXQUFXLEdBQUcsR0FBRyxFQUFFO1lBQ3hCLDJCQUEyQjtZQUMzQixJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxFQUFFLENBQUM7WUFFOUIsbUJBQW1CO1lBQ25CLGtFQUFrRTtZQUNsRSxVQUFVLENBQUMsR0FBRyxFQUFFO2dCQUNmLElBQUksQ0FBQyxjQUFjLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFO29CQUNsQyxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUM7b0JBQ3RCLElBQUksQ0FBQyxNQUFNO3lCQUNULElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUM7eUJBQ3ZDLFNBQVMsQ0FBQyxHQUFHLEVBQUU7d0JBQ2YsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUM7NEJBQ2xCLEtBQUssRUFBRSxJQUFJLENBQUMsS0FBSzs0QkFDakIsUUFBUSxFQUFFLElBQUksQ0FBQyxRQUFROzRCQUN2QixJQUFJLEVBQUUsSUFBSSxDQUFDLElBQUk7eUJBQ2YsQ0FBQyxDQUFDO3dCQUNILElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO29CQUMzQixDQUFDLENBQUMsQ0FBQztvQkFDSixJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUM7Z0JBQy9CLENBQUMsQ0FBQyxDQUFDO1lBQ0osQ0FBQyxDQUFDLENBQUM7UUFDSixDQUFDLENBQUM7UUFDRixXQUFXLEVBQUUsQ0FBQztRQUVkLElBQUksQ0FBQyxjQUFjLENBQUMsT0FBTzthQUN6QixJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQzthQUNsQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDO0lBQ2pDLENBQUM7SUFFRCxXQUFXO1FBQ1YsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUN6QixJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBRTdCLHdEQUF3RDtRQUN4RCxJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDOUIsSUFBSSxDQUFDLGlCQUFpQixDQUFDLFFBQVEsRUFBRSxDQUFDO0lBQ25DLENBQUM7SUFFRCxVQUFVLENBQUMsS0FBVTtRQUNwQixJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsRUFBRTtZQUFFLE9BQU87U0FBRTtRQUNyQyxJQUFJLENBQUMsY0FBYyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUNsQyxJQUFJLElBQUksQ0FBQyxLQUFLLEtBQUssS0FBSyxFQUFFO2dCQUN6QixJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQzthQUNyQjtpQkFBTTtnQkFDTixJQUFJLENBQUMsUUFBUSxHQUFHLEtBQUssQ0FBQzthQUN0QjtRQUNGLENBQUMsQ0FBQyxDQUFDO0lBQ0osQ0FBQztJQUVELGdCQUFnQixDQUFDLEVBQU87UUFDdkIsSUFBSSxDQUFDLFFBQVEsR0FBRyxFQUFFLENBQUM7SUFDcEIsQ0FBQztJQUVELGlCQUFpQixDQUFDLEVBQU87UUFDeEIsSUFBSSxDQUFDLFNBQVMsR0FBRyxFQUFFLENBQUM7SUFDckIsQ0FBQztJQUVNLFVBQVUsQ0FBQyxLQUFLO1FBQ3RCLE9BQU8sS0FBSyxZQUFZLFdBQVcsQ0FBQztJQUNyQyxDQUFDOztBQXRHTSx3QkFBYyxHQUFHLENBQUMsQ0FBQztzR0FEZCxTQUFTOzBGQUFULFNBQVMsd09BUlY7UUFDVjtZQUNDLE9BQU8sRUFBRSxpQkFBaUI7WUFDMUIsV0FBVyxFQUFFLFNBQVM7WUFDdEIsS0FBSyxFQUFFLElBQUk7U0FDWDtLQUNELHlEQStCZ0IsYUFBYSw2QkE3Q3BCOzs7Ozs7O2NBT0c7MkZBU0QsU0FBUztrQkFsQnJCLFNBQVM7bUJBQUM7b0JBQ1YsUUFBUSxFQUFFLGdDQUFnQztvQkFDMUMsUUFBUSxFQUFFOzs7Ozs7O2NBT0c7b0JBQ2IsU0FBUyxFQUFFO3dCQUNWOzRCQUNDLE9BQU8sRUFBRSxpQkFBaUI7NEJBQzFCLFdBQVcsV0FBVzs0QkFDdEIsS0FBSyxFQUFFLElBQUk7eUJBQ1g7cUJBQ0Q7aUJBQ0Q7MEVBTVMsSUFBSTtzQkFBWixLQUFLO2dCQUlHLFFBQVE7c0JBQWhCLEtBQUs7Z0JBRUcsTUFBTTtzQkFBZCxLQUFLO2dCQWNJLFFBQVE7c0JBQWpCLE1BQU07Z0JBRStCLGNBQWM7c0JBQW5ELFdBQVc7dUJBQUMsdUJBQXVCO2dCQUVKLGNBQWM7c0JBQTdDLGVBQWU7dUJBQUMsYUFBYSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG5cdENvbXBvbmVudCxcblx0QWZ0ZXJDb250ZW50SW5pdCxcblx0SW5wdXQsXG5cdE91dHB1dCxcblx0RXZlbnRFbWl0dGVyLFxuXHRIb3N0QmluZGluZyxcblx0Q29udGVudENoaWxkcmVuLFxuXHRRdWVyeUxpc3QsXG5cdE9uRGVzdHJveSxcblx0VGVtcGxhdGVSZWZcbn0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcbmltcG9ydCB7IFNlbGVjdGlvblRpbGUgfSBmcm9tIFwiLi9zZWxlY3Rpb24tdGlsZS5jb21wb25lbnRcIjtcbmltcG9ydCB7IE5HX1ZBTFVFX0FDQ0VTU09SIH0gZnJvbSBcIkBhbmd1bGFyL2Zvcm1zXCI7XG5pbXBvcnQgeyBUaWxlU2VsZWN0aW9uIH0gZnJvbSBcIi4vdGlsZS1zZWxlY3Rpb24uaW50ZXJmYWNlXCI7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSBcInJ4anNcIjtcbmltcG9ydCB7IHRha2VVbnRpbCB9IGZyb20gXCJyeGpzL29wZXJhdG9yc1wiO1xuXG4vKipcbiAqIEdldCBzdGFydGVkIHdpdGggaW1wb3J0aW5nIHRoZSBtb2R1bGU6XG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHsgVGlsZXNNb2R1bGUgfSBmcm9tICdjYXJib24tY29tcG9uZW50cy1hbmd1bGFyJztcbiAqIGBgYFxuICpcbiAqIFtTZWUgZGVtb10oLi4vLi4vP3BhdGg9L3N0b3J5L2NvbXBvbmVudHMtdGlsZXMtZ3JvdXBlZC0tc2VsZWN0YWJsZSlcbiAqL1xuQENvbXBvbmVudCh7XG5cdHNlbGVjdG9yOiBcImNkcy10aWxlLWdyb3VwLCBpYm0tdGlsZS1ncm91cFwiLFxuXHR0ZW1wbGF0ZTogYFxuXHRcdDxmaWVsZHNldD5cblx0XHRcdDxsZWdlbmQgKm5nSWY9XCJsZWdlbmRcIiBjbGFzcz1cImNkcy0tbGFiZWxcIj5cblx0XHRcdFx0PG5nLXRlbXBsYXRlICpuZ0lmPVwiaXNUZW1wbGF0ZShsZWdlbmQpOyBlbHNlIGxlZ2VuZExhYmVsO1wiIFtuZ1RlbXBsYXRlT3V0bGV0XT1cImxlZ2VuZFwiPjwvbmctdGVtcGxhdGU+XG5cdFx0XHRcdDxuZy10ZW1wbGF0ZSAjbGVnZW5kTGFiZWw+e3tsZWdlbmR9fTwvbmctdGVtcGxhdGU+XG5cdFx0XHQ8L2xlZ2VuZD5cblx0XHRcdDxuZy1jb250ZW50IHNlbGVjdD1cImlibS1zZWxlY3Rpb24tdGlsZSxjZHMtc2VsZWN0aW9uLXRpbGVcIj48L25nLWNvbnRlbnQ+XG5cdFx0PC9maWVsZHNldD5gLFxuXHRwcm92aWRlcnM6IFtcblx0XHR7XG5cdFx0XHRwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcblx0XHRcdHVzZUV4aXN0aW5nOiBUaWxlR3JvdXAsXG5cdFx0XHRtdWx0aTogdHJ1ZVxuXHRcdH1cblx0XVxufSlcbmV4cG9ydCBjbGFzcyBUaWxlR3JvdXAgaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0LCBPbkRlc3Ryb3kge1xuXHRzdGF0aWMgdGlsZUdyb3VwQ291bnQgPSAwO1xuXHQvKipcblx0ICogVGhlIHRpbGUgZ3JvdXAgYG5hbWVgXG5cdCAqL1xuXHRASW5wdXQoKSBuYW1lID0gYHRpbGUtZ3JvdXAtJHtUaWxlR3JvdXAudGlsZUdyb3VwQ291bnR9YDtcblx0LyoqXG5cdCAqIFNldCB0byBgdHJ1ZWAgdG8gc3VwcG9ydCBtdWx0aXBsZSB0aWxlIHNlbGVjdGlvblxuXHQgKi9cblx0QElucHV0KCkgbXVsdGlwbGUgPSBmYWxzZTtcblxuXHRASW5wdXQoKSBsZWdlbmQ6IHN0cmluZyB8IFRlbXBsYXRlUmVmPGFueT47XG5cblx0LyoqXG5cdCAqIEVtaXRzIGFuIGV2ZW50IHdoZW4gdGhlIHRpbGUgc2VsZWN0aW9uIGNoYW5nZXMuXG5cdCAqXG5cdCAqIEVtaXRzIGFuIG9iamVjdCB0aGF0IGxvb2tzIGxpa2U6XG5cdCAqIGBgYGphdmFzY3JpcHRcblx0ICoge1xuXHQgKiBcdHZhbHVlOiBcInNvbWV0aGluZ1wiLFxuXHQgKiBcdHNlbGVjdGVkOiB0cnVlLFxuXHQgKiBcdG5hbWU6IFwidGlsZS1ncm91cC0xXCJcblx0ICogfVxuXHQgKiBgYGBcblx0ICovXG5cdEBPdXRwdXQoKSBzZWxlY3RlZDogRXZlbnRFbWl0dGVyPFRpbGVTZWxlY3Rpb24+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG5cdEBIb3N0QmluZGluZyhcImNsYXNzLmNkcy0tdGlsZS1ncm91cFwiKSB0aWxlR3JvdXBDbGFzcyA9IHRydWU7XG5cblx0QENvbnRlbnRDaGlsZHJlbihTZWxlY3Rpb25UaWxlKSBzZWxlY3Rpb25UaWxlczogUXVlcnlMaXN0PFNlbGVjdGlvblRpbGU+O1xuXG5cdHByb3RlY3RlZCB1bnN1YnNjcmliZSQgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXHRwcm90ZWN0ZWQgdW5zdWJzY3JpYmVUaWxlcyQgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdFRpbGVHcm91cC50aWxlR3JvdXBDb3VudCsrO1xuXHR9XG5cblx0b25DaGFuZ2UgPSAoXzogYW55KSA9PiB7IH07XG5cblx0b25Ub3VjaGVkID0gKCkgPT4geyB9O1xuXG5cdG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcblx0XHRjb25zdCB1cGRhdGVUaWxlcyA9ICgpID0+IHtcblx0XHRcdC8vIHJlbW92ZSBvbGQgc3Vic2NyaXB0aW9uc1xuXHRcdFx0dGhpcy51bnN1YnNjcmliZVRpbGVzJC5uZXh0KCk7XG5cblx0XHRcdC8vIHJlYWN0IHRvIGNoYW5nZXNcblx0XHRcdC8vIHNldFRpbWVvdXQgdG8gYXZvaWQgRXhwcmVzc2lvbkNoYW5nZWRBZnRlckl0SGFzQmVlbkNoZWNrZWRFcnJvclxuXHRcdFx0c2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHRcdHRoaXMuc2VsZWN0aW9uVGlsZXMuZm9yRWFjaCh0aWxlID0+IHtcblx0XHRcdFx0XHR0aWxlLm5hbWUgPSB0aGlzLm5hbWU7XG5cdFx0XHRcdFx0dGlsZS5jaGFuZ2Vcblx0XHRcdFx0XHRcdC5waXBlKHRha2VVbnRpbCh0aGlzLnVuc3Vic2NyaWJlVGlsZXMkKSlcblx0XHRcdFx0XHRcdC5zdWJzY3JpYmUoKCkgPT4ge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnNlbGVjdGVkLmVtaXQoe1xuXHRcdFx0XHRcdFx0XHRcdHZhbHVlOiB0aWxlLnZhbHVlLFxuXHRcdFx0XHRcdFx0XHRcdHNlbGVjdGVkOiB0aWxlLnNlbGVjdGVkLFxuXHRcdFx0XHRcdFx0XHRcdG5hbWU6IHRoaXMubmFtZVxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0dGhpcy5vbkNoYW5nZSh0aWxlLnZhbHVlKTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdHRpbGUubXVsdGlwbGUgPSB0aGlzLm11bHRpcGxlO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdH07XG5cdFx0dXBkYXRlVGlsZXMoKTtcblxuXHRcdHRoaXMuc2VsZWN0aW9uVGlsZXMuY2hhbmdlc1xuXHRcdFx0LnBpcGUodGFrZVVudGlsKHRoaXMudW5zdWJzY3JpYmUkKSlcblx0XHRcdC5zdWJzY3JpYmUoXyA9PiB1cGRhdGVUaWxlcygpKTtcblx0fVxuXG5cdG5nT25EZXN0cm95KCkge1xuXHRcdHRoaXMudW5zdWJzY3JpYmUkLm5leHQoKTtcblx0XHR0aGlzLnVuc3Vic2NyaWJlJC5jb21wbGV0ZSgpO1xuXG5cdFx0Ly8gdGFrZXMgY2FyZSBvZiB0aWxlIHN1YnNjcmlwdGlvbnMgd2hlbiB0aWxlLWdyb3VwIGRpZXNcblx0XHR0aGlzLnVuc3Vic2NyaWJlVGlsZXMkLm5leHQoKTtcblx0XHR0aGlzLnVuc3Vic2NyaWJlVGlsZXMkLmNvbXBsZXRlKCk7XG5cdH1cblxuXHR3cml0ZVZhbHVlKHZhbHVlOiBhbnkpIHtcblx0XHRpZiAoIXRoaXMuc2VsZWN0aW9uVGlsZXMpIHsgcmV0dXJuOyB9XG5cdFx0dGhpcy5zZWxlY3Rpb25UaWxlcy5mb3JFYWNoKHRpbGUgPT4ge1xuXHRcdFx0aWYgKHRpbGUudmFsdWUgPT09IHZhbHVlKSB7XG5cdFx0XHRcdHRpbGUuc2VsZWN0ZWQgPSB0cnVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGlsZS5zZWxlY3RlZCA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0cmVnaXN0ZXJPbkNoYW5nZShmbjogYW55KSB7XG5cdFx0dGhpcy5vbkNoYW5nZSA9IGZuO1xuXHR9XG5cblx0cmVnaXN0ZXJPblRvdWNoZWQoZm46IGFueSkge1xuXHRcdHRoaXMub25Ub3VjaGVkID0gZm47XG5cdH1cblxuXHRwdWJsaWMgaXNUZW1wbGF0ZSh2YWx1ZSkge1xuXHRcdHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFRlbXBsYXRlUmVmO1xuXHR9XG59XG4iXX0=