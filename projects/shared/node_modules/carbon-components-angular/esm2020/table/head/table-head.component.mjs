import { Component, Input, Output, EventEmitter } from "@angular/core";
import { getScrollbarWidth } from "carbon-components-angular/utils";
import * as i0 from "@angular/core";
import * as i1 from "carbon-components-angular/i18n";
import * as i2 from "@angular/common";
import * as i3 from "./table-head-cell.component";
import * as i4 from "./table-head-checkbox.component";
import * as i5 from "./table-head-expand.component";
/**
 * A subcomponent that creates the thead of the table
 *
 * ## Basic usage
 *
 * ```html
 * 	<thead cdsTableHead [model]="model"></thead>
 * ```
 */
export class TableHead {
    constructor(i18n) {
        this.i18n = i18n;
        this.showSelectionColumn = true;
        this.enableSingleSelect = false;
        this.selectAllCheckboxSomeSelected = false;
        this.selectAllCheckbox = false;
        this.skeleton = false;
        this.stickyHeader = false;
        this.showExpandAllToggle = false;
        /**
         * Setting sortable to false will disable all headers including headers which are sortable. Is is
         * possible to set the sortable state on the header item to disable/enable sorting for only some headers.
         */
        this.sortable = true;
        /**
         * Emits an index of the column that wants to be sorted.
         */
        this.sort = new EventEmitter();
        /**
         * Emits if all rows are selected.
         *
         * @param model
         */
        this.selectAll = new EventEmitter();
        /**
         * Emits if all rows are deselected.
         *
         * @param model
         */
        this.deselectAll = new EventEmitter();
        /**
         * Emits if all rows are expanded.
         *
         * @param model
         */
        this.expandAllRows = new EventEmitter();
        /**
         * Emits if all rows are collapsed.
         *
         * @param model
         */
        this.collapseAllRows = new EventEmitter();
        this.scrollbarWidth = 0;
        this._checkboxHeaderLabel = this.i18n.getOverridable("TABLE.CHECKBOX_HEADER");
        this._sortDescendingLabel = this.i18n.getOverridable("TABLE.SORT_DESCENDING");
        this._sortAscendingLabel = this.i18n.getOverridable("TABLE.SORT_ASCENDING");
        this._filterTitle = this.i18n.getOverridable("TABLE.FILTER");
    }
    set checkboxHeaderLabel(value) {
        this._checkboxHeaderLabel.override(value);
    }
    get checkboxHeaderLabel() {
        return this._checkboxHeaderLabel.value;
    }
    set sortDescendingLabel(value) {
        this._sortDescendingLabel.override(value);
    }
    get sortDescendingLabel() {
        return this._sortDescendingLabel.value;
    }
    set sortAscendingLabel(value) {
        this._sortAscendingLabel.override(value);
    }
    get sortAscendingLabel() {
        return this._sortAscendingLabel.value;
    }
    set filterTitle(value) {
        this._filterTitle.override(value);
    }
    get filterTitle() {
        return this._filterTitle.value;
    }
    ngAfterViewInit() {
        setTimeout(() => {
            this.scrollbarWidth = getScrollbarWidth();
        });
    }
    onSelectAllCheckboxChange() {
        if (!this.selectAllCheckbox && !this.selectAllCheckboxSomeSelected) {
            this.selectAll.emit(this.model);
        }
        else {
            this.deselectAll.emit(this.model);
        }
    }
    onExpandAllRowsChange(expand) {
        if (expand) {
            this.expandAllRows.emit(this.model);
        }
        else {
            this.collapseAllRows.emit(this.model);
        }
    }
    getCheckboxHeaderLabel() {
        return this._checkboxHeaderLabel.subject;
    }
    getSortDescendingLabel() {
        return this._sortDescendingLabel.subject;
    }
    getSortAscendingLabel() {
        return this._sortAscendingLabel.subject;
    }
    getFilterTitle() {
        return this._filterTitle.subject;
    }
}
TableHead.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: TableHead, deps: [{ token: i1.I18n }], target: i0.ɵɵFactoryTarget.Component });
TableHead.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.3.0", type: TableHead, selector: "[cdsTableHead], [ibmTableHead]", inputs: { model: "model", showSelectionColumn: "showSelectionColumn", enableSingleSelect: "enableSingleSelect", selectAllCheckboxSomeSelected: "selectAllCheckboxSomeSelected", selectAllCheckbox: "selectAllCheckbox", skeleton: "skeleton", stickyHeader: "stickyHeader", showExpandAllToggle: "showExpandAllToggle", sortable: "sortable", checkboxHeaderLabel: "checkboxHeaderLabel", sortDescendingLabel: "sortDescendingLabel", sortAscendingLabel: "sortAscendingLabel", filterTitle: "filterTitle" }, outputs: { sort: "sort", selectAll: "selectAll", deselectAll: "deselectAll", expandAllRows: "expandAllRows", collapseAllRows: "collapseAllRows" }, ngImport: i0, template: `
	<ng-container *ngIf="model">
		<tr>
			<th
				cdsTableHeadExpand
				*ngIf="model.hasExpandableRows()"
				scope="col"
				[showExpandAllToggle]="showExpandAllToggle"
				[ngClass]="{'cds--table-expand-v2': stickyHeader}"
				[id]="model.getId('expand')"
				[expanded]="model.expandableRowsCount() === model.expandedRowsCount()"
				(expandedChange)="onExpandAllRowsChange($event)">
			</th>
			<th
				*ngIf="!skeleton && showSelectionColumn && enableSingleSelect"
				scope="col"
				[id]="model.getId('select')">
				<!-- add width 0; since the carbon styles don't seem to constrain this headers width -->
			</th>
			<th
				cdsTableHeadCheckbox
				*ngIf="!skeleton && showSelectionColumn && !enableSingleSelect"
				scope="col"
				[checked]="selectAllCheckbox"
				[indeterminate]="selectAllCheckboxSomeSelected"
				[ariaLabel]="getCheckboxHeaderLabel()"
				[skeleton]="skeleton"
				[name]="model.getHeaderId('select')"
				(change)="onSelectAllCheckboxChange()"
				[id]="model.getId('select')">
			</th>
			<ng-container *ngFor="let column of model.header; let i = index">
				<th
					*ngIf="column && column.visible"
					[ngStyle]="column.style"
					cdsTableHeadCell
					scope="col"
					[class]="column.className"
					[sortable]="sortable"
					[skeleton]="skeleton"
					[id]="model.getId(i)"
					[column]="column"
					[filterTitle]="getFilterTitle()"
					[attr.colspan]="column.colSpan"
					[attr.rowspan]="column.rowSpan"
					(sort)="sort.emit(i)">
				</th>
			</ng-container>
			<th *ngIf="!skeleton && stickyHeader && scrollbarWidth"
				scope="col"
				[ngStyle]="{'width': scrollbarWidth + 'px', 'padding': 0, 'border': 0}">
				<!--
					Scrollbar pushes body to the left so this header column is added to push
					the title bar the same amount and keep the header and body columns aligned.
				-->
			</th>
		</tr>
	</ng-container>
	<ng-content></ng-content>
	`, isInline: true, styles: [".cds--table-expand-v2{padding-left:2.5rem}\n"], dependencies: [{ kind: "directive", type: i2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i2.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "component", type: i3.TableHeadCell, selector: "[cdsTableHeadCell], [ibmTableHeadCell]", inputs: ["column", "skeleton", "sortable", "sortDescendingLabel", "sortAscendingLabel", "filterTitle"], outputs: ["sort"] }, { kind: "component", type: i4.TableHeadCheckbox, selector: "[cdsTableHeadCheckbox], [ibmTableHeadCheckbox]", inputs: ["checked", "indeterminate", "skeleton", "name", "ariaLabel"], outputs: ["change"] }, { kind: "component", type: i5.TableHeadExpand, selector: "[cdsTableHeadExpand], [ibmTableHeadExpand]", inputs: ["showExpandAllToggle", "expanded"], outputs: ["expandedChange"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: TableHead, decorators: [{
            type: Component,
            args: [{ selector: "[cdsTableHead], [ibmTableHead]", template: `
	<ng-container *ngIf="model">
		<tr>
			<th
				cdsTableHeadExpand
				*ngIf="model.hasExpandableRows()"
				scope="col"
				[showExpandAllToggle]="showExpandAllToggle"
				[ngClass]="{'cds--table-expand-v2': stickyHeader}"
				[id]="model.getId('expand')"
				[expanded]="model.expandableRowsCount() === model.expandedRowsCount()"
				(expandedChange)="onExpandAllRowsChange($event)">
			</th>
			<th
				*ngIf="!skeleton && showSelectionColumn && enableSingleSelect"
				scope="col"
				[id]="model.getId('select')">
				<!-- add width 0; since the carbon styles don't seem to constrain this headers width -->
			</th>
			<th
				cdsTableHeadCheckbox
				*ngIf="!skeleton && showSelectionColumn && !enableSingleSelect"
				scope="col"
				[checked]="selectAllCheckbox"
				[indeterminate]="selectAllCheckboxSomeSelected"
				[ariaLabel]="getCheckboxHeaderLabel()"
				[skeleton]="skeleton"
				[name]="model.getHeaderId('select')"
				(change)="onSelectAllCheckboxChange()"
				[id]="model.getId('select')">
			</th>
			<ng-container *ngFor="let column of model.header; let i = index">
				<th
					*ngIf="column && column.visible"
					[ngStyle]="column.style"
					cdsTableHeadCell
					scope="col"
					[class]="column.className"
					[sortable]="sortable"
					[skeleton]="skeleton"
					[id]="model.getId(i)"
					[column]="column"
					[filterTitle]="getFilterTitle()"
					[attr.colspan]="column.colSpan"
					[attr.rowspan]="column.rowSpan"
					(sort)="sort.emit(i)">
				</th>
			</ng-container>
			<th *ngIf="!skeleton && stickyHeader && scrollbarWidth"
				scope="col"
				[ngStyle]="{'width': scrollbarWidth + 'px', 'padding': 0, 'border': 0}">
				<!--
					Scrollbar pushes body to the left so this header column is added to push
					the title bar the same amount and keep the header and body columns aligned.
				-->
			</th>
		</tr>
	</ng-container>
	<ng-content></ng-content>
	`, styles: [".cds--table-expand-v2{padding-left:2.5rem}\n"] }]
        }], ctorParameters: function () { return [{ type: i1.I18n }]; }, propDecorators: { model: [{
                type: Input
            }], showSelectionColumn: [{
                type: Input
            }], enableSingleSelect: [{
                type: Input
            }], selectAllCheckboxSomeSelected: [{
                type: Input
            }], selectAllCheckbox: [{
                type: Input
            }], skeleton: [{
                type: Input
            }], stickyHeader: [{
                type: Input
            }], showExpandAllToggle: [{
                type: Input
            }], sortable: [{
                type: Input
            }], checkboxHeaderLabel: [{
                type: Input
            }], sortDescendingLabel: [{
                type: Input
            }], sortAscendingLabel: [{
                type: Input
            }], filterTitle: [{
                type: Input
            }], sort: [{
                type: Output
            }], selectAll: [{
                type: Output
            }], deselectAll: [{
                type: Output
            }], expandAllRows: [{
                type: Output
            }], collapseAllRows: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFibGUtaGVhZC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvdGFibGUvaGVhZC90YWJsZS1oZWFkLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ04sU0FBUyxFQUNULEtBQUssRUFDTCxNQUFNLEVBQ04sWUFBWSxFQUVaLE1BQU0sZUFBZSxDQUFDO0FBR3ZCLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLGlDQUFpQyxDQUFDOzs7Ozs7O0FBS3BFOzs7Ozs7OztHQVFHO0FBc0VILE1BQU0sT0FBTyxTQUFTO0lBK0ZyQixZQUFzQixJQUFVO1FBQVYsU0FBSSxHQUFKLElBQUksQ0FBTTtRQTVGdkIsd0JBQW1CLEdBQUcsSUFBSSxDQUFDO1FBRTNCLHVCQUFrQixHQUFHLEtBQUssQ0FBQztRQUUzQixrQ0FBNkIsR0FBRyxLQUFLLENBQUM7UUFFdEMsc0JBQWlCLEdBQUcsS0FBSyxDQUFDO1FBRTFCLGFBQVEsR0FBRyxLQUFLLENBQUM7UUFFakIsaUJBQVksR0FBRyxLQUFLLENBQUM7UUFFckIsd0JBQW1CLEdBQUcsS0FBSyxDQUFDO1FBRXJDOzs7V0FHRztRQUNNLGFBQVEsR0FBRyxJQUFJLENBQUM7UUFzQ3pCOztXQUVHO1FBQ08sU0FBSSxHQUFHLElBQUksWUFBWSxFQUFVLENBQUM7UUFDNUM7Ozs7V0FJRztRQUNPLGNBQVMsR0FBRyxJQUFJLFlBQVksRUFBYyxDQUFDO1FBQ3JEOzs7O1dBSUc7UUFDTyxnQkFBVyxHQUFHLElBQUksWUFBWSxFQUFjLENBQUM7UUFDdkQ7Ozs7V0FJRztRQUNPLGtCQUFhLEdBQUcsSUFBSSxZQUFZLEVBQWMsQ0FBQztRQUN6RDs7OztXQUlHO1FBQ08sb0JBQWUsR0FBRyxJQUFJLFlBQVksRUFBYyxDQUFDO1FBRXBELG1CQUFjLEdBQUcsQ0FBQyxDQUFDO1FBRWhCLHlCQUFvQixHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsY0FB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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBMkRUOzJGQVFRLEtBQUs7c0JBQWIsS0FBSztnQkFFRyxtQkFBbUI7c0JBQTNCLEtBQUs7Z0JBRUcsa0JBQWtCO3NCQUExQixLQUFLO2dCQUVHLDZCQUE2QjtzQkFBckMsS0FBSztnQkFFRyxpQkFBaUI7c0JBQXpCLEtBQUs7Z0JBRUcsUUFBUTtzQkFBaEIsS0FBSztnQkFFRyxZQUFZO3NCQUFwQixLQUFLO2dCQUVHLG1CQUFtQjtzQkFBM0IsS0FBSztnQkFNRyxRQUFRO3NCQUFoQixLQUFLO2dCQUdGLG1CQUFtQjtzQkFEdEIsS0FBSztnQkFVRixtQkFBbUI7c0JBRHRCLEtBQUs7Z0JBVUYsa0JBQWtCO3NCQURyQixLQUFLO2dCQVVGLFdBQVc7c0JBRGQsS0FBSztnQkFZSSxJQUFJO3NCQUFiLE1BQU07Z0JBTUcsU0FBUztzQkFBbEIsTUFBTTtnQkFNRyxXQUFXO3NCQUFwQixNQUFNO2dCQU1HLGFBQWE7c0JBQXRCLE1BQU07Z0JBTUcsZUFBZTtzQkFBeEIsTUFBTSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG5cdENvbXBvbmVudCxcblx0SW5wdXQsXG5cdE91dHB1dCxcblx0RXZlbnRFbWl0dGVyLFxuXHRBZnRlclZpZXdJbml0XG59IGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XG5cbmltcG9ydCB7IFRhYmxlTW9kZWwgfSBmcm9tIFwiLi4vdGFibGUtbW9kZWwuY2xhc3NcIjtcbmltcG9ydCB7IGdldFNjcm9sbGJhcldpZHRoIH0gZnJvbSBcImNhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvdXRpbHNcIjtcbmltcG9ydCB7IEkxOG4sIE92ZXJyaWRhYmxlIH0gZnJvbSBcImNhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvaTE4blwiO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gXCJyeGpzXCI7XG5pbXBvcnQgeyBUYWJsZVJvd1NpemUgfSBmcm9tIFwiLi4vdGFibGUudHlwZXNcIjtcblxuLyoqXG4gKiBBIHN1YmNvbXBvbmVudCB0aGF0IGNyZWF0ZXMgdGhlIHRoZWFkIG9mIHRoZSB0YWJsZVxuICpcbiAqICMjIEJhc2ljIHVzYWdlXG4gKlxuICogYGBgaHRtbFxuICogXHQ8dGhlYWQgY2RzVGFibGVIZWFkIFttb2RlbF09XCJtb2RlbFwiPjwvdGhlYWQ+XG4gKiBgYGBcbiAqL1xuQENvbXBvbmVudCh7XG5cdC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpjb21wb25lbnQtc2VsZWN0b3Jcblx0c2VsZWN0b3I6IFwiW2Nkc1RhYmxlSGVhZF0sIFtpYm1UYWJsZUhlYWRdXCIsXG5cdHRlbXBsYXRlOiBgXG5cdDxuZy1jb250YWluZXIgKm5nSWY9XCJtb2RlbFwiPlxuXHRcdDx0cj5cblx0XHRcdDx0aFxuXHRcdFx0XHRjZHNUYWJsZUhlYWRFeHBhbmRcblx0XHRcdFx0Km5nSWY9XCJtb2RlbC5oYXNFeHBhbmRhYmxlUm93cygpXCJcblx0XHRcdFx0c2NvcGU9XCJjb2xcIlxuXHRcdFx0XHRbc2hvd0V4cGFuZEFsbFRvZ2dsZV09XCJzaG93RXhwYW5kQWxsVG9nZ2xlXCJcblx0XHRcdFx0W25nQ2xhc3NdPVwieydjZHMtLXRhYmxlLWV4cGFuZC12Mic6IHN0aWNreUhlYWRlcn1cIlxuXHRcdFx0XHRbaWRdPVwibW9kZWwuZ2V0SWQoJ2V4cGFuZCcpXCJcblx0XHRcdFx0W2V4cGFuZGVkXT1cIm1vZGVsLmV4cGFuZGFibGVSb3dzQ291bnQoKSA9PT0gbW9kZWwuZXhwYW5kZWRSb3dzQ291bnQoKVwiXG5cdFx0XHRcdChleHBhbmRlZENoYW5nZSk9XCJvbkV4cGFuZEFsbFJvd3NDaGFuZ2UoJGV2ZW50KVwiPlxuXHRcdFx0PC90aD5cblx0XHRcdDx0aFxuXHRcdFx0XHQqbmdJZj1cIiFza2VsZXRvbiAmJiBzaG93U2VsZWN0aW9uQ29sdW1uICYmIGVuYWJsZVNpbmdsZVNlbGVjdFwiXG5cdFx0XHRcdHNjb3BlPVwiY29sXCJcblx0XHRcdFx0W2lkXT1cIm1vZGVsLmdldElkKCdzZWxlY3QnKVwiPlxuXHRcdFx0XHQ8IS0tIGFkZCB3aWR0aCAwOyBzaW5jZSB0aGUgY2FyYm9uIHN0eWxlcyBkb24ndCBzZWVtIHRvIGNvbnN0cmFpbiB0aGlzIGhlYWRlcnMgd2lkdGggLS0+XG5cdFx0XHQ8L3RoPlxuXHRcdFx0PHRoXG5cdFx0XHRcdGNkc1RhYmxlSGVhZENoZWNrYm94XG5cdFx0XHRcdCpuZ0lmPVwiIXNrZWxldG9uICYmIHNob3dTZWxlY3Rpb25Db2x1bW4gJiYgIWVuYWJsZVNpbmdsZVNlbGVjdFwiXG5cdFx0XHRcdHNjb3BlPVwiY29sXCJcblx0XHRcdFx0W2NoZWNrZWRdPVwic2VsZWN0QWxsQ2hlY2tib3hcIlxuXHRcdFx0XHRbaW5kZXRlcm1pbmF0ZV09XCJzZWxlY3RBbGxDaGVja2JveFNvbWVTZWxlY3RlZFwiXG5cdFx0XHRcdFthcmlhTGFiZWxdPVwiZ2V0Q2hlY2tib3hIZWFkZXJMYWJlbCgpXCJcblx0XHRcdFx0W3NrZWxldG9uXT1cInNrZWxldG9uXCJcblx0XHRcdFx0W25hbWVdPVwibW9kZWwuZ2V0SGVhZGVySWQoJ3NlbGVjdCcpXCJcblx0XHRcdFx0KGNoYW5nZSk9XCJvblNlbGVjdEFsbENoZWNrYm94Q2hhbmdlKClcIlxuXHRcdFx0XHRbaWRdPVwibW9kZWwuZ2V0SWQoJ3NlbGVjdCcpXCI+XG5cdFx0XHQ8L3RoPlxuXHRcdFx0PG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgY29sdW1uIG9mIG1vZGVsLmhlYWRlcjsgbGV0IGkgPSBpbmRleFwiPlxuXHRcdFx0XHQ8dGhcblx0XHRcdFx0XHQqbmdJZj1cImNvbHVtbiAmJiBjb2x1bW4udmlzaWJsZVwiXG5cdFx0XHRcdFx0W25nU3R5bGVdPVwiY29sdW1uLnN0eWxlXCJcblx0XHRcdFx0XHRjZHNUYWJsZUhlYWRDZWxsXG5cdFx0XHRcdFx0c2NvcGU9XCJjb2xcIlxuXHRcdFx0XHRcdFtjbGFzc109XCJjb2x1bW4uY2xhc3NOYW1lXCJcblx0XHRcdFx0XHRbc29ydGFibGVdPVwic29ydGFibGVcIlxuXHRcdFx0XHRcdFtza2VsZXRvbl09XCJza2VsZXRvblwiXG5cdFx0XHRcdFx0W2lkXT1cIm1vZGVsLmdldElkKGkpXCJcblx0XHRcdFx0XHRbY29sdW1uXT1cImNvbHVtblwiXG5cdFx0XHRcdFx0W2ZpbHRlclRpdGxlXT1cImdldEZpbHRlclRpdGxlKClcIlxuXHRcdFx0XHRcdFthdHRyLmNvbHNwYW5dPVwiY29sdW1uLmNvbFNwYW5cIlxuXHRcdFx0XHRcdFthdHRyLnJvd3NwYW5dPVwiY29sdW1uLnJvd1NwYW5cIlxuXHRcdFx0XHRcdChzb3J0KT1cInNvcnQuZW1pdChpKVwiPlxuXHRcdFx0XHQ8L3RoPlxuXHRcdFx0PC9uZy1jb250YWluZXI+XG5cdFx0XHQ8dGggKm5nSWY9XCIhc2tlbGV0b24gJiYgc3RpY2t5SGVhZGVyICYmIHNjcm9sbGJhcldpZHRoXCJcblx0XHRcdFx0c2NvcGU9XCJjb2xcIlxuXHRcdFx0XHRbbmdTdHlsZV09XCJ7J3dpZHRoJzogc2Nyb2xsYmFyV2lkdGggKyAncHgnLCAncGFkZGluZyc6IDAsICdib3JkZXInOiAwfVwiPlxuXHRcdFx0XHQ8IS0tXG5cdFx0XHRcdFx0U2Nyb2xsYmFyIHB1c2hlcyBib2R5IHRvIHRoZSBsZWZ0IHNvIHRoaXMgaGVhZGVyIGNvbHVtbiBpcyBhZGRlZCB0byBwdXNoXG5cdFx0XHRcdFx0dGhlIHRpdGxlIGJhciB0aGUgc2FtZSBhbW91bnQgYW5kIGtlZXAgdGhlIGhlYWRlciBhbmQgYm9keSBjb2x1bW5zIGFsaWduZWQuXG5cdFx0XHRcdC0tPlxuXHRcdFx0PC90aD5cblx0XHQ8L3RyPlxuXHQ8L25nLWNvbnRhaW5lcj5cblx0PG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuXHRgLFxuXHRzdHlsZXM6IFtgXG5cdFx0LmNkcy0tdGFibGUtZXhwYW5kLXYyIHtcblx0XHRcdHBhZGRpbmctbGVmdDogMi41cmVtO1xuXHRcdH1cblx0YF1cbn0pXG5leHBvcnQgY2xhc3MgVGFibGVIZWFkIGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCB7XG5cdEBJbnB1dCgpIG1vZGVsOiBUYWJsZU1vZGVsO1xuXG5cdEBJbnB1dCgpIHNob3dTZWxlY3Rpb25Db2x1bW4gPSB0cnVlO1xuXG5cdEBJbnB1dCgpIGVuYWJsZVNpbmdsZVNlbGVjdCA9IGZhbHNlO1xuXG5cdEBJbnB1dCgpIHNlbGVjdEFsbENoZWNrYm94U29tZVNlbGVjdGVkID0gZmFsc2U7XG5cblx0QElucHV0KCkgc2VsZWN0QWxsQ2hlY2tib3ggPSBmYWxzZTtcblxuXHRASW5wdXQoKSBza2VsZXRvbiA9IGZhbHNlO1xuXG5cdEBJbnB1dCgpIHN0aWNreUhlYWRlciA9IGZhbHNlO1xuXG5cdEBJbnB1dCgpIHNob3dFeHBhbmRBbGxUb2dnbGUgPSBmYWxzZTtcblxuXHQvKipcblx0ICogU2V0dGluZyBzb3J0YWJsZSB0byBmYWxzZSB3aWxsIGRpc2FibGUgYWxsIGhlYWRlcnMgaW5jbHVkaW5nIGhlYWRlcnMgd2hpY2ggYXJlIHNvcnRhYmxlLiBJcyBpc1xuXHQgKiBwb3NzaWJsZSB0byBzZXQgdGhlIHNvcnRhYmxlIHN0YXRlIG9uIHRoZSBoZWFkZXIgaXRlbSB0byBkaXNhYmxlL2VuYWJsZSBzb3J0aW5nIGZvciBvbmx5IHNvbWUgaGVhZGVycy5cblx0ICovXG5cdEBJbnB1dCgpIHNvcnRhYmxlID0gdHJ1ZTtcblxuXHRASW5wdXQoKVxuXHRzZXQgY2hlY2tib3hIZWFkZXJMYWJlbCh2YWx1ZTogc3RyaW5nIHwgT2JzZXJ2YWJsZTxzdHJpbmc+KSB7XG5cdFx0dGhpcy5fY2hlY2tib3hIZWFkZXJMYWJlbC5vdmVycmlkZSh2YWx1ZSk7XG5cdH1cblxuXHRnZXQgY2hlY2tib3hIZWFkZXJMYWJlbCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2hlY2tib3hIZWFkZXJMYWJlbC52YWx1ZTtcblx0fVxuXG5cdEBJbnB1dCgpXG5cdHNldCBzb3J0RGVzY2VuZGluZ0xhYmVsKHZhbHVlOiBzdHJpbmcgfCBPYnNlcnZhYmxlPHN0cmluZz4pIHtcblx0XHR0aGlzLl9zb3J0RGVzY2VuZGluZ0xhYmVsLm92ZXJyaWRlKHZhbHVlKTtcblx0fVxuXG5cdGdldCBzb3J0RGVzY2VuZGluZ0xhYmVsKCkge1xuXHRcdHJldHVybiB0aGlzLl9zb3J0RGVzY2VuZGluZ0xhYmVsLnZhbHVlO1xuXHR9XG5cblx0QElucHV0KClcblx0c2V0IHNvcnRBc2NlbmRpbmdMYWJlbCh2YWx1ZTogc3RyaW5nIHwgT2JzZXJ2YWJsZTxzdHJpbmc+KSB7XG5cdFx0dGhpcy5fc29ydEFzY2VuZGluZ0xhYmVsLm92ZXJyaWRlKHZhbHVlKTtcblx0fVxuXG5cdGdldCBzb3J0QXNjZW5kaW5nTGFiZWwoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NvcnRBc2NlbmRpbmdMYWJlbC52YWx1ZTtcblx0fVxuXG5cdEBJbnB1dCgpXG5cdHNldCBmaWx0ZXJUaXRsZSh2YWx1ZTogc3RyaW5nIHwgT2JzZXJ2YWJsZTxzdHJpbmc+KSB7XG5cdFx0dGhpcy5fZmlsdGVyVGl0bGUub3ZlcnJpZGUodmFsdWUpO1xuXHR9XG5cblx0Z2V0IGZpbHRlclRpdGxlKCkge1xuXHRcdHJldHVybiB0aGlzLl9maWx0ZXJUaXRsZS52YWx1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBFbWl0cyBhbiBpbmRleCBvZiB0aGUgY29sdW1uIHRoYXQgd2FudHMgdG8gYmUgc29ydGVkLlxuXHQgKi9cblx0QE91dHB1dCgpIHNvcnQgPSBuZXcgRXZlbnRFbWl0dGVyPG51bWJlcj4oKTtcblx0LyoqXG5cdCAqIEVtaXRzIGlmIGFsbCByb3dzIGFyZSBzZWxlY3RlZC5cblx0ICpcblx0ICogQHBhcmFtIG1vZGVsXG5cdCAqL1xuXHRAT3V0cHV0KCkgc2VsZWN0QWxsID0gbmV3IEV2ZW50RW1pdHRlcjxUYWJsZU1vZGVsPigpO1xuXHQvKipcblx0ICogRW1pdHMgaWYgYWxsIHJvd3MgYXJlIGRlc2VsZWN0ZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSBtb2RlbFxuXHQgKi9cblx0QE91dHB1dCgpIGRlc2VsZWN0QWxsID0gbmV3IEV2ZW50RW1pdHRlcjxUYWJsZU1vZGVsPigpO1xuXHQvKipcblx0ICogRW1pdHMgaWYgYWxsIHJvd3MgYXJlIGV4cGFuZGVkLlxuXHQgKlxuXHQgKiBAcGFyYW0gbW9kZWxcblx0ICovXG5cdEBPdXRwdXQoKSBleHBhbmRBbGxSb3dzID0gbmV3IEV2ZW50RW1pdHRlcjxUYWJsZU1vZGVsPigpO1xuXHQvKipcblx0ICogRW1pdHMgaWYgYWxsIHJvd3MgYXJlIGNvbGxhcHNlZC5cblx0ICpcblx0ICogQHBhcmFtIG1vZGVsXG5cdCAqL1xuXHRAT3V0cHV0KCkgY29sbGFwc2VBbGxSb3dzID0gbmV3IEV2ZW50RW1pdHRlcjxUYWJsZU1vZGVsPigpO1xuXG5cdHB1YmxpYyBzY3JvbGxiYXJXaWR0aCA9IDA7XG5cblx0cHJvdGVjdGVkIF9jaGVja2JveEhlYWRlckxhYmVsID0gdGhpcy5pMThuLmdldE92ZXJyaWRhYmxlKFwiVEFCTEUuQ0hFQ0tCT1hfSEVBREVSXCIpO1xuXHRwcm90ZWN0ZWQgX3NvcnREZXNjZW5kaW5nTGFiZWwgPSB0aGlzLmkxOG4uZ2V0T3ZlcnJpZGFibGUoXCJUQUJMRS5TT1JUX0RFU0NFTkRJTkdcIik7XG5cdHByb3RlY3RlZCBfc29ydEFzY2VuZGluZ0xhYmVsID0gdGhpcy5pMThuLmdldE92ZXJyaWRhYmxlKFwiVEFCTEUuU09SVF9BU0NFTkRJTkdcIik7XG5cdHByb3RlY3RlZCBfZmlsdGVyVGl0bGUgPSB0aGlzLmkxOG4uZ2V0T3ZlcnJpZGFibGUoXCJUQUJMRS5GSUxURVJcIik7XG5cblx0Y29uc3RydWN0b3IocHJvdGVjdGVkIGkxOG46IEkxOG4pIHt9XG5cblx0bmdBZnRlclZpZXdJbml0KCkge1xuXHRcdHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0dGhpcy5zY3JvbGxiYXJXaWR0aCA9IGdldFNjcm9sbGJhcldpZHRoKCk7XG5cdFx0fSk7XG5cdH1cblxuXHRvblNlbGVjdEFsbENoZWNrYm94Q2hhbmdlKCkge1xuXHRcdGlmICghdGhpcy5zZWxlY3RBbGxDaGVja2JveCAmJiAhdGhpcy5zZWxlY3RBbGxDaGVja2JveFNvbWVTZWxlY3RlZCkge1xuXHRcdFx0dGhpcy5zZWxlY3RBbGwuZW1pdCh0aGlzLm1vZGVsKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5kZXNlbGVjdEFsbC5lbWl0KHRoaXMubW9kZWwpO1xuXHRcdH1cblx0fVxuXG5cdG9uRXhwYW5kQWxsUm93c0NoYW5nZShleHBhbmQ6IGJvb2xlYW4pIHtcblx0XHRpZiAoZXhwYW5kKSB7XG5cdFx0XHR0aGlzLmV4cGFuZEFsbFJvd3MuZW1pdCh0aGlzLm1vZGVsKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5jb2xsYXBzZUFsbFJvd3MuZW1pdCh0aGlzLm1vZGVsKTtcblx0XHR9XG5cdH1cblxuXHRnZXRDaGVja2JveEhlYWRlckxhYmVsKCk6IE9ic2VydmFibGU8c3RyaW5nPiB7XG5cdFx0cmV0dXJuIHRoaXMuX2NoZWNrYm94SGVhZGVyTGFiZWwuc3ViamVjdDtcblx0fVxuXG5cdGdldFNvcnREZXNjZW5kaW5nTGFiZWwoKTogT2JzZXJ2YWJsZTxzdHJpbmc+IHtcblx0XHRyZXR1cm4gdGhpcy5fc29ydERlc2NlbmRpbmdMYWJlbC5zdWJqZWN0O1xuXHR9XG5cblx0Z2V0U29ydEFzY2VuZGluZ0xhYmVsKCk6IE9ic2VydmFibGU8c3RyaW5nPiB7XG5cdFx0cmV0dXJuIHRoaXMuX3NvcnRBc2NlbmRpbmdMYWJlbC5zdWJqZWN0O1xuXHR9XG5cblx0Z2V0RmlsdGVyVGl0bGUoKTogT2JzZXJ2YWJsZTxzdHJpbmc+IHtcblx0XHRyZXR1cm4gdGhpcy5fZmlsdGVyVGl0bGUuc3ViamVjdDtcblx0fVxufVxuIl19