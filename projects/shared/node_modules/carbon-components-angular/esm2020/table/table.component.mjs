import { Component, Input, Output, EventEmitter, HostBinding } from "@angular/core";
import { Subscription, fromEvent } from "rxjs";
import { TableModel } from "./table-model.class";
import { TableHeaderItem } from "./table-header-item.class";
import { TableItem } from "./table-item.class";
import { getFocusElementList, tabbableSelectorIgnoreTabIndex } from "carbon-components-angular/common";
import { merge } from "carbon-components-angular/utils";
import { DataGridInteractionModel } from "./data-grid-interaction-model.class";
import { TableDomAdapter } from "./table-adapter.class";
import * as i0 from "@angular/core";
import * as i1 from "carbon-components-angular/i18n";
import * as i2 from "@angular/common";
import * as i3 from "./table.directive";
import * as i4 from "./head/table-head.component";
import * as i5 from "./body/table-body.component";
/**
 * Build your table with this component by extending things that differ from default.
 *
 * [See demo](../../?path=/story/components-table--basic)
 *
 * Instead of the usual write-your-own-html approach you had with `<table>`,
 * carbon table uses model-view-controller approach.
 *
 * Here, you create a view (with built-in controller) and provide it a model.
 * Changes you make to the model are reflected in the view. Provide same model you use
 * in the table to the `<cds-pagination>` components.
 * They provide a different view over the same data.
 *
 * ## Basic usage
 *
 * ```html
 * <cds-table [model]="model"></cds-table>
 * ```
 *
 * ```typescript
 * public model = new TableModel();
 *
 * this.model.data = [
 * 	[new TableItem({data: "asdf"}), new TableItem({data: "qwer"})],
 * 	[new TableItem({data: "csdf"}), new TableItem({data: "zwer"})],
 * 	[new TableItem({data: "bsdf"}), new TableItem({data: "swer"})],
 * 	[new TableItem({data: "csdf"}), new TableItem({data: "twer"})]
 * ];
 * ```
 *
 * ## Customization
 *
 * If you have custom data in your table, you need a way to display it. You can do that
 * by providing a template to `TableItem`.
 *
 * ```html
 * <ng-template #customTableItemTemplate let-data="data">
 * 	<a [routerLink]="data.link">{{data.name}} {{data.surname}}</a>
 * </ng-template>
 * ```
 *
 * ```typescript
 * customTableItemTemplate: TemplateRef<any>;
 *
 * this.customModel.data = [
 * 	[new TableItem({data: "asdf"}), new TableItem({data: {name: "Lessy", link: "/table"}, template: this.customTableItemTemplate})],
 * 	[new TableItem({data: "csdf"}), new TableItem({data: "swer"})],
 * 	[new TableItem({data: "bsdf"}), new TableItem({data: {name: "Alice", surname: "Bob"}, template: this.customTableItemTemplate})],
 * 	[new TableItem({data: "csdf"}), new TableItem({data: "twer"})],
 * ];
 * ```
 *
 * ### Sorting and filtering
 *
 * In case you need custom sorting and/or filtering you should subclass `TableHeaderItem`
 * and override needed functions.
 *
 * ```typescript
 * class FilterableHeaderItem extends TableHeaderItem {
 * 	// custom filter function
 * 	filter(item: TableItem): boolean {
 * 		if (typeof item.data === "string" && item.data.toLowerCase().indexOf(this.filterData.data.toLowerCase()) >= 0 ||
 * 		item.data.name && item.data.name.toLowerCase().indexOf(this.filterData.data.toLowerCase()) >= 0 ||
 * 		item.data.surname && item.data.surname.toLowerCase().indexOf(this.filterData.data.toLowerCase()) >= 0) {
 * 			return false;
 * 		}
 * 		return true;
 * 	}
 *
 * 	set filterCount(n) {}
 * 	get filterCount() {
 * 		return (this.filterData && this.filterData.data && this.filterData.data.length > 0) ? 1 : 0;
 * 	}
 *
 * 	// used for custom sorting
 * 	compare(one: TableItem, two: TableItem) {
 * 		const stringOne = (one.data.name || one.data.surname || one.data).toLowerCase();
 * 		const stringTwo = (two.data.name || two.data.surname || two.data).toLowerCase();
 *
 * 		if (stringOne > stringTwo) {
 * 			return 1;
 * 		} else if (stringOne < stringTwo) {
 * 			return -1;
 * 		} else {
 * 			return 0;
 * 		}
 * 	}
 * }
 * ```
 *
 * If you want to do your sorting on the backend or query for sorted data as a result of user
 * clicking the table header, check table [`sort`](#sort) output documentation
 *
 * See `TableHeaderItem` class for more information.
 *
 * ## No data template
 *
 * When table has no data to show, it can show a message you provide it instead.
 *
 * ```html
 * <cds-table [model]="model">No data.</cds-table>
 * ```
 *
 * ... will show `No data.` message, but you can get creative and provide any template you want
 * to replace table's default `tbody`.
 *
 * ## Use pagination as table footer
 *
 * ```html
 * <cds-pagination [model]="model" (selectPage)="selectPage($event)"></cds-pagination>
 * ```
 *
 * `selectPage()` function should fetch the data from backend, create new `data`, apply it to `model.data`,
 * and update `model.currentPage`.
 *
 * If the data your server returns is a two dimensional array of objects, it would look something like this:
 *
 * ```typescript
 * selectPage(page) {
 * 	this.getPage(page).then((data: Array<Array<any>>) => {
 * 		// set the data and update page
 * 		this.model.data = this.prepareData(data);
 * 		this.model.currentPage = page;
 * 	});
 * }
 *
 * protected prepareData(data: Array<Array<any>>) {
 * 	// create new data from the service data
 * 	let newData = [];
 * 	data.forEach(dataRow => {
 * 		let row = [];
 * 		dataRow.forEach(dataElement => {
 * 			row.push(new TableItem({
 * 				data: dataElement,
 * 				template: typeof dataElement === "string" ? undefined : this.paginationTableItemTemplate
 * 				// your template can handle all the data types so you don't have to conditionally set it
 * 				// you can also set different templates for different columns based on index
 * 			}));
 * 		});
 * 		newData.push(row);
 * 	});
 * 	return newData;
 * }
 * ```
 */
export class Table {
    /**
     * Creates an instance of Table.
     */
    constructor(elementRef, applicationRef, i18n) {
        this.elementRef = elementRef;
        this.applicationRef = applicationRef;
        this.i18n = i18n;
        /**
         * Size of the table rows.
         */
        this.size = "md";
        /**
         * Set to `true` for a loading table.
         */
        this.skeleton = false;
        /**
         * Setting sortable to false will disable all headers including headers which are sortable. Is is
         * possible to set the sortable state on the header item to disable/enable sorting for only some headers.
         */
        this.sortable = true;
        this.noBorder = true;
        /**
         * Set to `true` to show expansion toggle when table consists of row expansions
         */
        this.showExpandAllToggle = false;
        /**
         * Controls whether to show the selection checkboxes column or not.
         */
        this.showSelectionColumn = true;
        /**
         * Controls whether to enable multiple or single row selection.
         */
        this.enableSingleSelect = false;
        /**
         * Distance (in px) from the bottom that view has to reach before
         * `scrollLoad` event is emitted.
         */
        this.scrollLoadDistance = 0;
        /**
         * Set to `false` to remove table rows (zebra) stripes.
         */
        this.striped = true;
        /**
         * Allows table content to scroll horizontally
         */
        this.tableContent = true;
        /**
         * Set to `true` to stick the header to the top of the table
         */
        this.stickyHeader = false;
        /**
         * Emits an index of the column that wants to be sorted.
         *
         * If no observers are provided (default), table will attempt to do a simple sort of the data loaded
         * into the model.
         *
         * If an observer is provided, table will not attempt any sorting of its own and it is up to the observer
         * to sort the table. This is what you typically want if you're using a backend query to get the sorted
         * data or want to sort data across multiple pages.
         *
         * Usage:
         *
         * ```typescript
         * @Component({
         * 	selector: "app-table",
         * 	template: `
         * 		<cds-table
         * 			[model]="model"
         * 			(sort)="simpleSort($event)">
         * 			No data.
         * 		</cds-table>
         * 	`
         * })
         * export class TableApp implements OnInit, OnChanges {
         * 	@Input() model = new TableModel();
         *
         * 	ngOnInit() {
         * 		this.model.header = [
         * 			new TableHeaderItem({ data: "Name" }),
         * 			new TableHeaderItem({ data: "hwer" })
         * 		];
         *
         * 		this.model.data = [
         * 			[new TableItem({ data: "Name 1" }), new TableItem({ data: "qwer" })],
         * 			[new TableItem({ data: "Name 3" }), new TableItem({ data: "zwer" })],
         * 			[new TableItem({ data: "Name 2" }), new TableItem({ data: "swer" })],
         * 			[new TableItem({ data: "Name 4" }), new TableItem({data: "twer"})],
         * 			[new TableItem({ data: "Name 5" }), new TableItem({data: "twer"})],
         * 			[new TableItem({ data: "Name 6" }), new TableItem({data: "twer"})]
         * 		];
         * 	}
         *
         * 	simpleSort(index: number) {
         * 		// this function does a simple sort, which is the default for the table and if that's
         * 		// all you want, you don't need to do this.
         *
         * 		// here you can query your backend and update the model.data based on the result
         * 		if (this.model.header[index].sorted) {
         * 			// if already sorted flip sorting direction
         * 			this.model.header[index].ascending = this.model.header[index].descending;
         * 		}
         * 		this.model.sort(index);
         * 	}
         * }
         * ```
         */
        this.sort = new EventEmitter();
        /**
         * Emits if all rows are selected.
         *
         * @param model
         */
        this.selectAll = new EventEmitter();
        /**
         * Emits if all rows are deselected.
         *
         * @param model
         */
        this.deselectAll = new EventEmitter();
        /**
         * Emits if a single row is selected.
         *
         * @param ({model: this.model, selectedRowIndex: index})
         */
        this.selectRow = new EventEmitter();
        /**
         * Emits if a single row is deselected.
         *
         * @param ({model: this.model, deselectedRowIndex: index})
         */
        this.deselectRow = new EventEmitter();
        /**
         * Emits if a row item excluding expandButtons, checkboxes, or radios is clicked.
         */
        this.rowClick = new EventEmitter();
        /**
         * Emits when table requires more data to be loaded.
         */
        this.scrollLoad = new EventEmitter();
        /**
         * Controls if all checkboxes are viewed as selected.
         */
        this.selectAllCheckbox = false;
        /**
         * Controls the indeterminate state of the header checkbox.
         */
        this.selectAllCheckboxSomeSelected = false;
        this.isColumnDragging = false;
        this.columnDraggedHoverIndex = -1;
        this.columnDraggedPosition = "";
        this._isDataGrid = false;
        // flag to prevent getters/setters from querying the view before it's fully instantiated
        this.isViewReady = false;
        this.subscriptions = new Subscription();
        this._expandButtonAriaLabel = this.i18n.getOverridable("TABLE.EXPAND_BUTTON");
        this._sortDescendingLabel = this.i18n.getOverridable("TABLE.SORT_DESCENDING");
        this._sortAscendingLabel = this.i18n.getOverridable("TABLE.SORT_ASCENDING");
        this._checkboxHeaderLabel = this.i18n.getOverridable("TABLE.CHECKBOX_HEADER");
        this._checkboxRowLabel = this.i18n.getOverridable("TABLE.CHECKBOX_ROW");
        this._endOfDataText = this.i18n.getOverridable("TABLE.END_OF_DATA");
        this._scrollTopText = this.i18n.getOverridable("TABLE.SCROLL_TOP");
        this._filterTitle = this.i18n.getOverridable("TABLE.FILTER");
    }
    /**
     * Creates a skeleton model with a row and column count specified by the user
     *
     * Example:
     *
     * ```typescript
     * this.model = Table.skeletonModel(5, 5);
     * ```
     */
    static skeletonModel(rowCount, columnCount) {
        const model = new TableModel();
        let header = new Array();
        let data = new Array();
        let row = new Array();
        for (let i = 0; i < columnCount; i++) {
            header.push(new TableHeaderItem());
            row.push(new TableItem());
        }
        for (let i = 0; i < rowCount - 1; i++) {
            data.push(row);
        }
        model.header = header;
        model.data = data;
        return model;
    }
    static setTabIndex(element, index) {
        const focusElementList = getFocusElementList(element, tabbableSelectorIgnoreTabIndex);
        if (element.firstElementChild && element.firstElementChild.classList.contains("cds--table-sort") && focusElementList.length > 1) {
            focusElementList[1].tabIndex = index;
        }
        else if (focusElementList.length > 0) {
            focusElementList[0].tabIndex = index;
        }
        else {
            element.tabIndex = index;
        }
    }
    static focus(element) {
        const focusElementList = getFocusElementList(element, tabbableSelectorIgnoreTabIndex);
        if ((element.firstElementChild?.classList.contains("cds--table-sort") && focusElementList.length > 1) ||
            focusElementList.length > 0) {
            focusElementList[0].focus();
        }
        else {
            element.focus();
        }
    }
    /**
     * `TableModel` with data the table is to display.
     */
    set model(m) {
        if (this._model) {
            this.subscriptions.unsubscribe();
            // Need to create a new subscription instance here because unsubscribing prevents any new subscriptions
            // from being added for some reason. When a new model is set, none of the subscriptions would exist.
            this.subscriptions = new Subscription();
        }
        this._model = m;
        const rowsChange = this._model.rowsSelectedChange.subscribe(() => this.updateSelectAllCheckbox());
        const dataChange = this._model.dataChange.subscribe(() => {
            if (this.isDataGrid) {
                this.resetTabIndex();
            }
            this.updateSelectAllCheckbox();
        });
        this.subscriptions.add(rowsChange);
        this.subscriptions.add(dataChange);
        if (this.isDataGrid) {
            const expandedChange = this._model.rowsExpandedChange.subscribe(() => {
                // Allows the expanded row to have a focus state when it exists in the DOM
                setTimeout(() => {
                    const expandedRows = this.elementRef.nativeElement.querySelectorAll(".cds--expandable-row:not(.cds--parent-row)");
                    Array.from(expandedRows).forEach(row => {
                        if (row.firstElementChild.tabIndex === undefined || row.firstElementChild.tabIndex !== -1) {
                            row.firstElementChild.tabIndex = -1;
                        }
                    });
                });
            });
            this.subscriptions.add(expandedChange);
        }
    }
    get model() {
        return this._model;
    }
    /**
     * Set to `true` for a data grid with keyboard interactions.
     */
    set isDataGrid(value) {
        this._isDataGrid = value;
        if (this.isViewReady) {
            if (value) {
                this.enableDataGridInteractions();
            }
            else {
                this.disableDataGridInteractions();
            }
        }
    }
    get isDataGrid() {
        return this._isDataGrid;
    }
    /**
     * @todo - Enable column resize when Carbon officially supports feature
     * Set to `true` to enable users to resize columns.
     *
     * Works for columns with width set in pixels.
     *
     */
    // @Input() columnsResizable = false;
    /**
     * @todo - Enable columns drag & drop when Carbon officially supports feature
     * Set to `true` to enable users to drag and drop columns.
     *
     * Changing the column order in table changes table model. Be aware of it when you add additional data
     * to the model.
     *
     */
    // @Input() columnsDraggable = false;
    set expandButtonAriaLabel(value) {
        this._expandButtonAriaLabel.override(value);
    }
    get expandButtonAriaLabel() {
        return this._expandButtonAriaLabel.value;
    }
    set sortDescendingLabel(value) {
        this._sortDescendingLabel.override(value);
    }
    get sortDescendingLabel() {
        return this._sortDescendingLabel.value;
    }
    set sortAscendingLabel(value) {
        this._sortAscendingLabel.override(value);
    }
    get sortAscendingLabel() {
        return this._sortAscendingLabel.value;
    }
    /**
     * Expects an object that contains some or all of:
     * ```
     * {
     *		"FILTER": "Filter",
     *		"END_OF_DATA": "You've reached the end of your content",
     *		"SCROLL_TOP": "Scroll to top",
     *		"CHECKBOX_HEADER": "Select all rows",
     *		"CHECKBOX_ROW": "Select row"
     * }
     * ```
     */
    set translations(value) {
        const valueWithDefaults = merge(this.i18n.getMultiple("TABLE"), value);
        this._filterTitle.override(valueWithDefaults.FILTER);
        this._endOfDataText.override(valueWithDefaults.END_OF_DATA);
        this._scrollTopText.override(valueWithDefaults.SCROLL_TOP);
        this._checkboxHeaderLabel.override(valueWithDefaults.CHECKBOX_HEADER);
        this._checkboxRowLabel.override(valueWithDefaults.CHECKBOX_ROW);
    }
    get noData() {
        return !this.model.data ||
            this.model.data.length === 0 ||
            this.model.data.length === 1 && this.model.data[0].length === 0;
    }
    ngOnInit() {
        // Manually trigger check to see if all checkboxes are selected
        // This is since subscription is made AFTER checkboxes are selected
        this.updateSelectAllCheckbox();
    }
    ngAfterViewInit() {
        this.isViewReady = true;
        if (this.isDataGrid) {
            this.enableDataGridInteractions();
        }
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
        if (this.positionSubscription) {
            this.positionSubscription.unsubscribe();
        }
    }
    enableDataGridInteractions() {
        // if we have an `interactioModel` we've already enabled datagrid
        if (this.interactionModel) {
            return;
        }
        const table = this.elementRef.nativeElement.querySelector("table");
        const tableAdapter = new TableDomAdapter(table);
        const keydownEventStream = fromEvent(table, "keydown");
        const clickEventStream = fromEvent(table, "click");
        this.interactionModel = new DataGridInteractionModel(keydownEventStream, clickEventStream, tableAdapter);
        this.positionSubscription = this.interactionModel.position.subscribe(event => {
            const [currentRow, currentColumn] = event.current;
            const [previousRow, previousColumn] = event.previous;
            const currentElement = tableAdapter.getCell(currentRow, currentColumn);
            Table.setTabIndex(currentElement, 0);
            // if the model has just initialized don't focus or reset anything
            if (previousRow === -1 || previousColumn === -1) {
                return;
            }
            // Make the previous cell unfocusable (if it's not the current)
            if (previousRow !== currentRow || previousColumn !== currentColumn) {
                const previousElement = tableAdapter.getCell(previousRow, previousColumn);
                Table.setTabIndex(previousElement, -1);
            }
            Table.focus(currentElement);
        });
        // call this after assigning `this.interactionModel` since it depends on it
        this.resetTabIndex();
    }
    disableDataGridInteractions() {
        // unsubscribe first so we don't cause the focus to fly around
        if (this.positionSubscription) {
            this.positionSubscription.unsubscribe();
        }
        // undo tab indexing (also resets the model)
        this.resetTabIndex(0);
        // null out the model ref
        this.interactionModel = null;
    }
    onSelectAll() {
        this.model.selectAll(true);
        this.selectAll.emit(this.model);
    }
    onDeselectAll() {
        this.model.selectAll(false);
        this.deselectAll.emit(this.model);
    }
    onSelectRow(event) {
        // check for the existence of the selectedRowIndex property
        if (Object.keys(event).includes("selectedRowIndex")) {
            if (this.enableSingleSelect) {
                this.model.selectAll(false);
            }
            this.model.selectRow(event.selectedRowIndex, true);
            this.selectRow.emit(event);
        }
        else {
            this.model.selectRow(event.deselectedRowIndex, false);
            this.deselectRow.emit(event);
        }
    }
    onRowClick(index) {
        this.rowClick.emit(index);
    }
    updateSelectAllCheckbox() {
        const selectedRowsCount = this.model.selectedRowsCount();
        if (selectedRowsCount <= 0) {
            // reset select all checkbox if nothing selected
            this.selectAllCheckbox = false;
            this.selectAllCheckboxSomeSelected = false;
        }
        else if (selectedRowsCount < this.model.data.length) {
            this.selectAllCheckbox = true;
            this.selectAllCheckboxSomeSelected = true;
        }
        else {
            this.selectAllCheckbox = true;
            this.selectAllCheckboxSomeSelected = false;
        }
    }
    resetTabIndex(newTabIndex = -1) {
        // ensure the view is ready for the reset before we preform the actual reset
        setTimeout(() => {
            // reset all the tabIndexes we can find
            const focusElementList = getFocusElementList(this.elementRef.nativeElement, tabbableSelectorIgnoreTabIndex);
            if (focusElementList) {
                focusElementList.forEach(tabbable => {
                    tabbable.tabIndex = newTabIndex;
                });
            }
            // reset interaction model positions and tabIndexes
            if (this.interactionModel) {
                this.interactionModel.resetTabIndexes(newTabIndex);
            }
        });
    }
    columnResizeStart(event, column) {
        this.columnResizeWidth = parseInt(column.style.width, 10);
        this.columnResizeMouseX = event.clientX;
        event.preventDefault();
        this.mouseMoveSubscription = fromEvent(document.body, "mousemove").subscribe(event => {
            this.columnResizeProgress(event, column);
        });
        this.mouseUpSubscription = fromEvent(document.body, "mouseup").subscribe(event => {
            this.columnResizeEnd(event, column);
        });
    }
    columnResizeProgress(event, column) {
        const move = event.clientX - this.columnResizeMouseX;
        column.style.width = `${this.columnResizeWidth + move}px`;
    }
    columnResizeEnd(event, column) {
        this.mouseMoveSubscription.unsubscribe();
        this.mouseUpSubscription.unsubscribe();
    }
    /**
     * Triggered when the user scrolls on the `<tbody>` element.
     * Emits the `scrollLoad` event.
     */
    onScroll(event) {
        const distanceFromBottom = event.target.scrollHeight - event.target.clientHeight - event.target.scrollTop;
        if (distanceFromBottom <= this.scrollLoadDistance) {
            this.scrollLoad.emit(this.model);
        }
        else {
            this.model.isEnd = false;
        }
    }
    columnDragStart(event, columnIndex) {
        this.isColumnDragging = true;
        this.columnDraggedHoverIndex = columnIndex;
        event.dataTransfer.setData("columnIndex", JSON.stringify(columnIndex));
    }
    columnDragEnd(event, columnIndex) {
        this.isColumnDragging = false;
        this.columnDraggedHoverIndex = -1;
    }
    columnDragEnter(event, position, columnIndex) {
        this.columnDraggedPosition = position;
        this.columnDraggedHoverIndex = columnIndex;
    }
    columnDragLeave(event, position, columnIndex) {
        this.columnDraggedPosition = "";
    }
    columnDragover(event, position, columnIndex) {
        this.columnDraggedHoverIndex = columnIndex;
        this.columnDraggedPosition = position;
        // needed to tell browser to allow dropping
        event.preventDefault();
    }
    columnDrop(event, position, columnIndex) {
        this.isColumnDragging = false;
        this.columnDraggedHoverIndex = -1;
        this.columnDraggedPosition = "";
        this.model.moveColumn(parseInt(event.dataTransfer.getData("columnIndex"), 10), columnIndex + (position === "right" ? 1 : 0));
    }
    doSort(index) {
        if (this.sort.observers.length === 0) {
            // no sort provided so do the simple sort
            this.model.cycleSortState(index);
            this.model.sort(index);
        }
        this.sort.emit(index);
    }
    /**
     * Triggered when the user scrolls on the `<tbody>` element.
     * Emits the `scrollLoad` event.
     */
    scrollToTop(event) {
        event.target.parentElement.parentElement.parentElement.parentElement.children[1].scrollTop = 0;
        this.model.isEnd = false;
    }
    getSelectionLabelValue(row) {
        if (!this.selectionLabelColumn) {
            return { value: this.i18n.get().TABLE.ROW };
        }
        return { value: row[this.selectionLabelColumn].data };
    }
    getExpandButtonAriaLabel() {
        return this._expandButtonAriaLabel.subject;
    }
    getSortDescendingLabel() {
        return this._sortDescendingLabel.subject;
    }
    getSortAscendingLabel() {
        return this._sortAscendingLabel.subject;
    }
    getCheckboxHeaderLabel() {
        return this._checkboxHeaderLabel.subject;
    }
    getCheckboxRowLabel() {
        return this._checkboxRowLabel.subject;
    }
    getEndOfDataText() {
        return this._endOfDataText.subject;
    }
    getScrollTopText() {
        return this._scrollTopText.subject;
    }
    getFilterTitle() {
        return this._filterTitle.subject;
    }
}
Table.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: Table, deps: [{ token: i0.ElementRef }, { token: i0.ApplicationRef }, { token: i1.I18n }], target: i0.ɵɵFactoryTarget.Component });
Table.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.3.0", type: Table, selector: "cds-table, ibm-table", inputs: { ariaLabelledby: "ariaLabelledby", ariaDescribedby: "ariaDescribedby", model: "model", size: "size", skeleton: "skeleton", isDataGrid: "isDataGrid", sortable: "sortable", noBorder: "noBorder", showExpandAllToggle: "showExpandAllToggle", showSelectionColumn: "showSelectionColumn", enableSingleSelect: "enableSingleSelect", scrollLoadDistance: "scrollLoadDistance", expandButtonAriaLabel: "expandButtonAriaLabel", sortDescendingLabel: "sortDescendingLabel", sortAscendingLabel: "sortAscendingLabel", translations: "translations", striped: "striped", stickyHeader: "stickyHeader", footerTemplate: "footerTemplate", selectionLabelColumn: "selectionLabelColumn" }, outputs: { sort: "sort", selectAll: "selectAll", deselectAll: "deselectAll", selectRow: "selectRow", deselectRow: "deselectRow", rowClick: "rowClick", scrollLoad: "scrollLoad" }, host: { properties: { "class.cds--data-table-content": "this.tableContent", "class.cds--data-table_inner-container": "this.stickyHeader" } }, ngImport: i0, template: `
	<table
		cdsTable
		[sortable]="sortable"
		[noBorder]="noBorder"
		[ngClass]="{'cds--data-table--sticky-header': stickyHeader}"
		[size]="size"
		[striped]="striped"
		[skeleton]="skeleton"
		[attr.aria-labelledby]="ariaLabelledby"
		[attr.aria-describedby]="ariaDescribedby">
		<thead
			cdsTableHead
			[sortable]="sortable"
			(deselectAll)="onDeselectAll()"
			(selectAll)="onSelectAll()"
			(expandAllRows)="model.expandAllRows(true)"
			(collapseAllRows)="model.expandAllRows(false)"
			(sort)="doSort($event)"
			[checkboxHeaderLabel]="getCheckboxHeaderLabel()"
			[filterTitle]="getFilterTitle()"
			[model]="model"
			[selectAllCheckbox]="selectAllCheckbox"
			[selectAllCheckboxSomeSelected]="selectAllCheckboxSomeSelected"
			[showSelectionColumn]="showSelectionColumn"
			[enableSingleSelect]="enableSingleSelect"
			[showExpandAllToggle]="showExpandAllToggle"
			[skeleton]="skeleton"
			[sortAscendingLabel]="sortAscendingLabel"
			[sortDescendingLabel]="sortDescendingLabel"
			[stickyHeader]="stickyHeader">
		</thead>
		<tbody
			cdsTableBody
			(deselectRow)="onSelectRow($event)"
			(scroll)="onScroll($event)"
			(selectRow)="onSelectRow($event)"
			[checkboxRowLabel]="getCheckboxRowLabel()"
			[enableSingleSelect]="enableSingleSelect"
			(rowClick)="onRowClick($event)"
			[expandButtonAriaLabel]="expandButtonAriaLabel"
			[model]="model"
			[size]="size"
			[ngStyle]="{'overflow-y': 'scroll'}"
			[selectionLabelColumn]="selectionLabelColumn"
			[showSelectionColumn]="showSelectionColumn"
			[skeleton]="skeleton"
			*ngIf="!noData; else noDataTemplate">
		</tbody>
		<ng-template #noDataTemplate><ng-content></ng-content></ng-template>
		<tfoot>
			<ng-template
				[ngTemplateOutlet]="footerTemplate">
			</ng-template>
			<tr *ngIf="this.model.isLoading">
				<td class="table_loading-indicator">
					<div class="cds--loading cds--loading--small">
						<svg class="cds--loading__svg" viewBox="-75 -75 150 150">
							<circle class="cds--loading__stroke" cx="0" cy="0" r="37.5" />
						</svg>
					</div>
				</td>
			</tr>
			<tr *ngIf="this.model.isEnd">
				<td class="table_end-indicator">
					<h5>{{getEndOfDataText() | async}}</h5>
					<button (click)="scrollToTop($event)" class="btn--secondary-sm">
						{{getScrollTopText() | async}}
					</button>
				</td>
			</tr>
		</tfoot>
	</table>
	`, isInline: true, styles: [":host{display:block}\n"], dependencies: [{ kind: "directive", type: i2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i2.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: i2.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "directive", type: i3.TableDirective, selector: "[cdsTable], [ibmTable]", inputs: ["sortable", "noBorder", "striped", "skeleton", "size"] }, { kind: "component", type: i4.TableHead, selector: "[cdsTableHead], [ibmTableHead]", inputs: ["model", "showSelectionColumn", "enableSingleSelect", "selectAllCheckboxSomeSelected", "selectAllCheckbox", "skeleton", "stickyHeader", "showExpandAllToggle", "sortable", "checkboxHeaderLabel", "sortDescendingLabel", "sortAscendingLabel", "filterTitle"], outputs: ["sort", "selectAll", "deselectAll", "expandAllRows", "collapseAllRows"] }, { kind: "component", type: i5.TableBody, selector: "[cdsTableBody], [ibmTableBody]", inputs: ["model", "enableSingleSelect", "expandButtonAriaLabel", "checkboxRowLabel", "showSelectionColumn", "size", "selectionLabelColumn", "skeleton"], outputs: ["selectRow", "deselectRow", "rowClick"] }, { kind: "pipe", type: i2.AsyncPipe, name: "async" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: Table, decorators: [{
            type: Component,
            args: [{ selector: "cds-table, ibm-table", template: `
	<table
		cdsTable
		[sortable]="sortable"
		[noBorder]="noBorder"
		[ngClass]="{'cds--data-table--sticky-header': stickyHeader}"
		[size]="size"
		[striped]="striped"
		[skeleton]="skeleton"
		[attr.aria-labelledby]="ariaLabelledby"
		[attr.aria-describedby]="ariaDescribedby">
		<thead
			cdsTableHead
			[sortable]="sortable"
			(deselectAll)="onDeselectAll()"
			(selectAll)="onSelectAll()"
			(expandAllRows)="model.expandAllRows(true)"
			(collapseAllRows)="model.expandAllRows(false)"
			(sort)="doSort($event)"
			[checkboxHeaderLabel]="getCheckboxHeaderLabel()"
			[filterTitle]="getFilterTitle()"
			[model]="model"
			[selectAllCheckbox]="selectAllCheckbox"
			[selectAllCheckboxSomeSelected]="selectAllCheckboxSomeSelected"
			[showSelectionColumn]="showSelectionColumn"
			[enableSingleSelect]="enableSingleSelect"
			[showExpandAllToggle]="showExpandAllToggle"
			[skeleton]="skeleton"
			[sortAscendingLabel]="sortAscendingLabel"
			[sortDescendingLabel]="sortDescendingLabel"
			[stickyHeader]="stickyHeader">
		</thead>
		<tbody
			cdsTableBody
			(deselectRow)="onSelectRow($event)"
			(scroll)="onScroll($event)"
			(selectRow)="onSelectRow($event)"
			[checkboxRowLabel]="getCheckboxRowLabel()"
			[enableSingleSelect]="enableSingleSelect"
			(rowClick)="onRowClick($event)"
			[expandButtonAriaLabel]="expandButtonAriaLabel"
			[model]="model"
			[size]="size"
			[ngStyle]="{'overflow-y': 'scroll'}"
			[selectionLabelColumn]="selectionLabelColumn"
			[showSelectionColumn]="showSelectionColumn"
			[skeleton]="skeleton"
			*ngIf="!noData; else noDataTemplate">
		</tbody>
		<ng-template #noDataTemplate><ng-content></ng-content></ng-template>
		<tfoot>
			<ng-template
				[ngTemplateOutlet]="footerTemplate">
			</ng-template>
			<tr *ngIf="this.model.isLoading">
				<td class="table_loading-indicator">
					<div class="cds--loading cds--loading--small">
						<svg class="cds--loading__svg" viewBox="-75 -75 150 150">
							<circle class="cds--loading__stroke" cx="0" cy="0" r="37.5" />
						</svg>
					</div>
				</td>
			</tr>
			<tr *ngIf="this.model.isEnd">
				<td class="table_end-indicator">
					<h5>{{getEndOfDataText() | async}}</h5>
					<button (click)="scrollToTop($event)" class="btn--secondary-sm">
						{{getScrollTopText() | async}}
					</button>
				</td>
			</tr>
		</tfoot>
	</table>
	`, styles: [":host{display:block}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.ApplicationRef }, { type: i1.I18n }]; }, propDecorators: { ariaLabelledby: [{
                type: Input
            }], ariaDescribedby: [{
                type: Input
            }], model: [{
                type: Input
            }], size: [{
                type: Input
            }], skeleton: [{
                type: Input
            }], isDataGrid: [{
                type: Input
            }], sortable: [{
                type: Input
            }], noBorder: [{
                type: Input
            }], showExpandAllToggle: [{
                type: Input
            }], showSelectionColumn: [{
                type: Input
            }], enableSingleSelect: [{
                type: Input
            }], scrollLoadDistance: [{
                type: Input
            }], expandButtonAriaLabel: [{
                type: Input
            }], sortDescendingLabel: [{
                type: Input
            }], sortAscendingLabel: [{
                type: Input
            }], translations: [{
                type: Input
            }], striped: [{
                type: Input
            }], tableContent: [{
                type: HostBinding,
                args: ["class.cds--data-table-content"]
            }], stickyHeader: [{
                type: HostBinding,
                args: ["class.cds--data-table_inner-container"]
            }, {
                type: Input
            }], footerTemplate: [{
                type: Input
            }], selectionLabelColumn: [{
                type: Input
            }], sort: [{
                type: Output
            }], selectAll: [{
                type: Output
            }], deselectAll: [{
                type: Output
            }], selectRow: [{
                type: Output
            }], deselectRow: [{
                type: Output
            }], rowClick: [{
                type: Output
            }], scrollLoad: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFibGUuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3RhYmxlL3RhYmxlLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ04sU0FBUyxFQUVULEtBQUssRUFFTCxNQUFNLEVBQ04sWUFBWSxFQUtaLFdBQVcsRUFDWCxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsWUFBWSxFQUFFLFNBQVMsRUFBYyxNQUFNLE1BQU0sQ0FBQztBQUUzRCxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDakQsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBQzVELE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUUvQyxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsOEJBQThCLEVBQUUsTUFBTSxrQ0FBa0MsQ0FBQztBQUV2RyxPQUFPLEVBQUUsS0FBSyxFQUFFLE1BQU0saUNBQWlDLENBQUM7QUFDeEQsT0FBTyxFQUFFLHdCQUF3QixFQUFFLE1BQU0scUNBQXFDLENBQUM7QUFDL0UsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLHVCQUF1QixDQUFDOzs7Ozs7O0FBR3hEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FnSkc7QUFtRkgsTUFBTSxPQUFPLEtBQUs7SUE2WWpCOztPQUVHO0lBQ0gsWUFDVyxVQUFzQixFQUN0QixjQUE4QixFQUM5QixJQUFVO1FBRlYsZUFBVSxHQUFWLFVBQVUsQ0FBWTtRQUN0QixtQkFBYyxHQUFkLGNBQWMsQ0FBZ0I7UUFDOUIsU0FBSSxHQUFKLElBQUksQ0FBTTtRQXpTckI7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QkFBcEIsTUFBTTtnQkFPRyxTQUFTO3NCQUFsQixNQUFNO2dCQU9HLFdBQVc7c0JBQXBCLE1BQU07Z0JBS0csUUFBUTtzQkFBakIsTUFBTTtnQkFLRyxVQUFVO3NCQUFuQixNQUFNIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcblx0Q29tcG9uZW50LFxuXHRBcHBsaWNhdGlvblJlZixcblx0SW5wdXQsXG5cdE9uSW5pdCxcblx0T3V0cHV0LFxuXHRFdmVudEVtaXR0ZXIsXG5cdEVsZW1lbnRSZWYsXG5cdEFmdGVyVmlld0luaXQsXG5cdFRlbXBsYXRlUmVmLFxuXHRPbkRlc3Ryb3ksXG5cdEhvc3RCaW5kaW5nXG59IGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24sIGZyb21FdmVudCwgT2JzZXJ2YWJsZSB9IGZyb20gXCJyeGpzXCI7XG5cbmltcG9ydCB7IFRhYmxlTW9kZWwgfSBmcm9tIFwiLi90YWJsZS1tb2RlbC5jbGFzc1wiO1xuaW1wb3J0IHsgVGFibGVIZWFkZXJJdGVtIH0gZnJvbSBcIi4vdGFibGUtaGVhZGVyLWl0ZW0uY2xhc3NcIjtcbmltcG9ydCB7IFRhYmxlSXRlbSB9IGZyb20gXCIuL3RhYmxlLWl0ZW0uY2xhc3NcIjtcblxuaW1wb3J0IHsgZ2V0Rm9jdXNFbGVtZW50TGlzdCwgdGFiYmFibGVTZWxlY3Rvcklnbm9yZVRhYkluZGV4IH0gZnJvbSBcImNhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvY29tbW9uXCI7XG5pbXBvcnQgeyBJMThuLCBPdmVycmlkYWJsZSB9IGZyb20gXCJjYXJib24tY29tcG9uZW50cy1hbmd1bGFyL2kxOG5cIjtcbmltcG9ydCB7IG1lcmdlIH0gZnJvbSBcImNhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvdXRpbHNcIjtcbmltcG9ydCB7IERhdGFHcmlkSW50ZXJhY3Rpb25Nb2RlbCB9IGZyb20gXCIuL2RhdGEtZ3JpZC1pbnRlcmFjdGlvbi1tb2RlbC5jbGFzc1wiO1xuaW1wb3J0IHsgVGFibGVEb21BZGFwdGVyIH0gZnJvbSBcIi4vdGFibGUtYWRhcHRlci5jbGFzc1wiO1xuaW1wb3J0IHsgVGFibGVSb3dTaXplIH0gZnJvbSBcIi4vdGFibGUudHlwZXNcIjtcblxuLyoqXG4gKiBCdWlsZCB5b3VyIHRhYmxlIHdpdGggdGhpcyBjb21wb25lbnQgYnkgZXh0ZW5kaW5nIHRoaW5ncyB0aGF0IGRpZmZlciBmcm9tIGRlZmF1bHQuXG4gKlxuICogW1NlZSBkZW1vXSguLi8uLi8/cGF0aD0vc3RvcnkvY29tcG9uZW50cy10YWJsZS0tYmFzaWMpXG4gKlxuICogSW5zdGVhZCBvZiB0aGUgdXN1YWwgd3JpdGUteW91ci1vd24taHRtbCBhcHByb2FjaCB5b3UgaGFkIHdpdGggYDx0YWJsZT5gLFxuICogY2FyYm9uIHRhYmxlIHVzZXMgbW9kZWwtdmlldy1jb250cm9sbGVyIGFwcHJvYWNoLlxuICpcbiAqIEhlcmUsIHlvdSBjcmVhdGUgYSB2aWV3ICh3aXRoIGJ1aWx0LWluIGNvbnRyb2xsZXIpIGFuZCBwcm92aWRlIGl0IGEgbW9kZWwuXG4gKiBDaGFuZ2VzIHlvdSBtYWtlIHRvIHRoZSBtb2RlbCBhcmUgcmVmbGVjdGVkIGluIHRoZSB2aWV3LiBQcm92aWRlIHNhbWUgbW9kZWwgeW91IHVzZVxuICogaW4gdGhlIHRhYmxlIHRvIHRoZSBgPGNkcy1wYWdpbmF0aW9uPmAgY29tcG9uZW50cy5cbiAqIFRoZXkgcHJvdmlkZSBhIGRpZmZlcmVudCB2aWV3IG92ZXIgdGhlIHNhbWUgZGF0YS5cbiAqXG4gKiAjIyBCYXNpYyB1c2FnZVxuICpcbiAqIGBgYGh0bWxcbiAqIDxjZHMtdGFibGUgW21vZGVsXT1cIm1vZGVsXCI+PC9jZHMtdGFibGU+XG4gKiBgYGBcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBwdWJsaWMgbW9kZWwgPSBuZXcgVGFibGVNb2RlbCgpO1xuICpcbiAqIHRoaXMubW9kZWwuZGF0YSA9IFtcbiAqIFx0W25ldyBUYWJsZUl0ZW0oe2RhdGE6IFwiYXNkZlwifSksIG5ldyBUYWJsZUl0ZW0oe2RhdGE6IFwicXdlclwifSldLFxuICogXHRbbmV3IFRhYmxlSXRlbSh7ZGF0YTogXCJjc2RmXCJ9KSwgbmV3IFRhYmxlSXRlbSh7ZGF0YTogXCJ6d2VyXCJ9KV0sXG4gKiBcdFtuZXcgVGFibGVJdGVtKHtkYXRhOiBcImJzZGZcIn0pLCBuZXcgVGFibGVJdGVtKHtkYXRhOiBcInN3ZXJcIn0pXSxcbiAqIFx0W25ldyBUYWJsZUl0ZW0oe2RhdGE6IFwiY3NkZlwifSksIG5ldyBUYWJsZUl0ZW0oe2RhdGE6IFwidHdlclwifSldXG4gKiBdO1xuICogYGBgXG4gKlxuICogIyMgQ3VzdG9taXphdGlvblxuICpcbiAqIElmIHlvdSBoYXZlIGN1c3RvbSBkYXRhIGluIHlvdXIgdGFibGUsIHlvdSBuZWVkIGEgd2F5IHRvIGRpc3BsYXkgaXQuIFlvdSBjYW4gZG8gdGhhdFxuICogYnkgcHJvdmlkaW5nIGEgdGVtcGxhdGUgdG8gYFRhYmxlSXRlbWAuXG4gKlxuICogYGBgaHRtbFxuICogPG5nLXRlbXBsYXRlICNjdXN0b21UYWJsZUl0ZW1UZW1wbGF0ZSBsZXQtZGF0YT1cImRhdGFcIj5cbiAqIFx0PGEgW3JvdXRlckxpbmtdPVwiZGF0YS5saW5rXCI+e3tkYXRhLm5hbWV9fSB7e2RhdGEuc3VybmFtZX19PC9hPlxuICogPC9uZy10ZW1wbGF0ZT5cbiAqIGBgYFxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGN1c3RvbVRhYmxlSXRlbVRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICpcbiAqIHRoaXMuY3VzdG9tTW9kZWwuZGF0YSA9IFtcbiAqIFx0W25ldyBUYWJsZUl0ZW0oe2RhdGE6IFwiYXNkZlwifSksIG5ldyBUYWJsZUl0ZW0oe2RhdGE6IHtuYW1lOiBcIkxlc3N5XCIsIGxpbms6IFwiL3RhYmxlXCJ9LCB0ZW1wbGF0ZTogdGhpcy5jdXN0b21UYWJsZUl0ZW1UZW1wbGF0ZX0pXSxcbiAqIFx0W25ldyBUYWJsZUl0ZW0oe2RhdGE6IFwiY3NkZlwifSksIG5ldyBUYWJsZUl0ZW0oe2RhdGE6IFwic3dlclwifSldLFxuICogXHRbbmV3IFRhYmxlSXRlbSh7ZGF0YTogXCJic2RmXCJ9KSwgbmV3IFRhYmxlSXRlbSh7ZGF0YToge25hbWU6IFwiQWxpY2VcIiwgc3VybmFtZTogXCJCb2JcIn0sIHRlbXBsYXRlOiB0aGlzLmN1c3RvbVRhYmxlSXRlbVRlbXBsYXRlfSldLFxuICogXHRbbmV3IFRhYmxlSXRlbSh7ZGF0YTogXCJjc2RmXCJ9KSwgbmV3IFRhYmxlSXRlbSh7ZGF0YTogXCJ0d2VyXCJ9KV0sXG4gKiBdO1xuICogYGBgXG4gKlxuICogIyMjIFNvcnRpbmcgYW5kIGZpbHRlcmluZ1xuICpcbiAqIEluIGNhc2UgeW91IG5lZWQgY3VzdG9tIHNvcnRpbmcgYW5kL29yIGZpbHRlcmluZyB5b3Ugc2hvdWxkIHN1YmNsYXNzIGBUYWJsZUhlYWRlckl0ZW1gXG4gKiBhbmQgb3ZlcnJpZGUgbmVlZGVkIGZ1bmN0aW9ucy5cbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjbGFzcyBGaWx0ZXJhYmxlSGVhZGVySXRlbSBleHRlbmRzIFRhYmxlSGVhZGVySXRlbSB7XG4gKiBcdC8vIGN1c3RvbSBmaWx0ZXIgZnVuY3Rpb25cbiAqIFx0ZmlsdGVyKGl0ZW06IFRhYmxlSXRlbSk6IGJvb2xlYW4ge1xuICogXHRcdGlmICh0eXBlb2YgaXRlbS5kYXRhID09PSBcInN0cmluZ1wiICYmIGl0ZW0uZGF0YS50b0xvd2VyQ2FzZSgpLmluZGV4T2YodGhpcy5maWx0ZXJEYXRhLmRhdGEudG9Mb3dlckNhc2UoKSkgPj0gMCB8fFxuICogXHRcdGl0ZW0uZGF0YS5uYW1lICYmIGl0ZW0uZGF0YS5uYW1lLnRvTG93ZXJDYXNlKCkuaW5kZXhPZih0aGlzLmZpbHRlckRhdGEuZGF0YS50b0xvd2VyQ2FzZSgpKSA+PSAwIHx8XG4gKiBcdFx0aXRlbS5kYXRhLnN1cm5hbWUgJiYgaXRlbS5kYXRhLnN1cm5hbWUudG9Mb3dlckNhc2UoKS5pbmRleE9mKHRoaXMuZmlsdGVyRGF0YS5kYXRhLnRvTG93ZXJDYXNlKCkpID49IDApIHtcbiAqIFx0XHRcdHJldHVybiBmYWxzZTtcbiAqIFx0XHR9XG4gKiBcdFx0cmV0dXJuIHRydWU7XG4gKiBcdH1cbiAqXG4gKiBcdHNldCBmaWx0ZXJDb3VudChuKSB7fVxuICogXHRnZXQgZmlsdGVyQ291bnQoKSB7XG4gKiBcdFx0cmV0dXJuICh0aGlzLmZpbHRlckRhdGEgJiYgdGhpcy5maWx0ZXJEYXRhLmRhdGEgJiYgdGhpcy5maWx0ZXJEYXRhLmRhdGEubGVuZ3RoID4gMCkgPyAxIDogMDtcbiAqIFx0fVxuICpcbiAqIFx0Ly8gdXNlZCBmb3IgY3VzdG9tIHNvcnRpbmdcbiAqIFx0Y29tcGFyZShvbmU6IFRhYmxlSXRlbSwgdHdvOiBUYWJsZUl0ZW0pIHtcbiAqIFx0XHRjb25zdCBzdHJpbmdPbmUgPSAob25lLmRhdGEubmFtZSB8fCBvbmUuZGF0YS5zdXJuYW1lIHx8IG9uZS5kYXRhKS50b0xvd2VyQ2FzZSgpO1xuICogXHRcdGNvbnN0IHN0cmluZ1R3byA9ICh0d28uZGF0YS5uYW1lIHx8IHR3by5kYXRhLnN1cm5hbWUgfHwgdHdvLmRhdGEpLnRvTG93ZXJDYXNlKCk7XG4gKlxuICogXHRcdGlmIChzdHJpbmdPbmUgPiBzdHJpbmdUd28pIHtcbiAqIFx0XHRcdHJldHVybiAxO1xuICogXHRcdH0gZWxzZSBpZiAoc3RyaW5nT25lIDwgc3RyaW5nVHdvKSB7XG4gKiBcdFx0XHRyZXR1cm4gLTE7XG4gKiBcdFx0fSBlbHNlIHtcbiAqIFx0XHRcdHJldHVybiAwO1xuICogXHRcdH1cbiAqIFx0fVxuICogfVxuICogYGBgXG4gKlxuICogSWYgeW91IHdhbnQgdG8gZG8geW91ciBzb3J0aW5nIG9uIHRoZSBiYWNrZW5kIG9yIHF1ZXJ5IGZvciBzb3J0ZWQgZGF0YSBhcyBhIHJlc3VsdCBvZiB1c2VyXG4gKiBjbGlja2luZyB0aGUgdGFibGUgaGVhZGVyLCBjaGVjayB0YWJsZSBbYHNvcnRgXSgjc29ydCkgb3V0cHV0IGRvY3VtZW50YXRpb25cbiAqXG4gKiBTZWUgYFRhYmxlSGVhZGVySXRlbWAgY2xhc3MgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogIyMgTm8gZGF0YSB0ZW1wbGF0ZVxuICpcbiAqIFdoZW4gdGFibGUgaGFzIG5vIGRhdGEgdG8gc2hvdywgaXQgY2FuIHNob3cgYSBtZXNzYWdlIHlvdSBwcm92aWRlIGl0IGluc3RlYWQuXG4gKlxuICogYGBgaHRtbFxuICogPGNkcy10YWJsZSBbbW9kZWxdPVwibW9kZWxcIj5ObyBkYXRhLjwvY2RzLXRhYmxlPlxuICogYGBgXG4gKlxuICogLi4uIHdpbGwgc2hvdyBgTm8gZGF0YS5gIG1lc3NhZ2UsIGJ1dCB5b3UgY2FuIGdldCBjcmVhdGl2ZSBhbmQgcHJvdmlkZSBhbnkgdGVtcGxhdGUgeW91IHdhbnRcbiAqIHRvIHJlcGxhY2UgdGFibGUncyBkZWZhdWx0IGB0Ym9keWAuXG4gKlxuICogIyMgVXNlIHBhZ2luYXRpb24gYXMgdGFibGUgZm9vdGVyXG4gKlxuICogYGBgaHRtbFxuICogPGNkcy1wYWdpbmF0aW9uIFttb2RlbF09XCJtb2RlbFwiIChzZWxlY3RQYWdlKT1cInNlbGVjdFBhZ2UoJGV2ZW50KVwiPjwvY2RzLXBhZ2luYXRpb24+XG4gKiBgYGBcbiAqXG4gKiBgc2VsZWN0UGFnZSgpYCBmdW5jdGlvbiBzaG91bGQgZmV0Y2ggdGhlIGRhdGEgZnJvbSBiYWNrZW5kLCBjcmVhdGUgbmV3IGBkYXRhYCwgYXBwbHkgaXQgdG8gYG1vZGVsLmRhdGFgLFxuICogYW5kIHVwZGF0ZSBgbW9kZWwuY3VycmVudFBhZ2VgLlxuICpcbiAqIElmIHRoZSBkYXRhIHlvdXIgc2VydmVyIHJldHVybnMgaXMgYSB0d28gZGltZW5zaW9uYWwgYXJyYXkgb2Ygb2JqZWN0cywgaXQgd291bGQgbG9vayBzb21ldGhpbmcgbGlrZSB0aGlzOlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIHNlbGVjdFBhZ2UocGFnZSkge1xuICogXHR0aGlzLmdldFBhZ2UocGFnZSkudGhlbigoZGF0YTogQXJyYXk8QXJyYXk8YW55Pj4pID0+IHtcbiAqIFx0XHQvLyBzZXQgdGhlIGRhdGEgYW5kIHVwZGF0ZSBwYWdlXG4gKiBcdFx0dGhpcy5tb2RlbC5kYXRhID0gdGhpcy5wcmVwYXJlRGF0YShkYXRhKTtcbiAqIFx0XHR0aGlzLm1vZGVsLmN1cnJlbnRQYWdlID0gcGFnZTtcbiAqIFx0fSk7XG4gKiB9XG4gKlxuICogcHJvdGVjdGVkIHByZXBhcmVEYXRhKGRhdGE6IEFycmF5PEFycmF5PGFueT4+KSB7XG4gKiBcdC8vIGNyZWF0ZSBuZXcgZGF0YSBmcm9tIHRoZSBzZXJ2aWNlIGRhdGFcbiAqIFx0bGV0IG5ld0RhdGEgPSBbXTtcbiAqIFx0ZGF0YS5mb3JFYWNoKGRhdGFSb3cgPT4ge1xuICogXHRcdGxldCByb3cgPSBbXTtcbiAqIFx0XHRkYXRhUm93LmZvckVhY2goZGF0YUVsZW1lbnQgPT4ge1xuICogXHRcdFx0cm93LnB1c2gobmV3IFRhYmxlSXRlbSh7XG4gKiBcdFx0XHRcdGRhdGE6IGRhdGFFbGVtZW50LFxuICogXHRcdFx0XHR0ZW1wbGF0ZTogdHlwZW9mIGRhdGFFbGVtZW50ID09PSBcInN0cmluZ1wiID8gdW5kZWZpbmVkIDogdGhpcy5wYWdpbmF0aW9uVGFibGVJdGVtVGVtcGxhdGVcbiAqIFx0XHRcdFx0Ly8geW91ciB0ZW1wbGF0ZSBjYW4gaGFuZGxlIGFsbCB0aGUgZGF0YSB0eXBlcyBzbyB5b3UgZG9uJ3QgaGF2ZSB0byBjb25kaXRpb25hbGx5IHNldCBpdFxuICogXHRcdFx0XHQvLyB5b3UgY2FuIGFsc28gc2V0IGRpZmZlcmVudCB0ZW1wbGF0ZXMgZm9yIGRpZmZlcmVudCBjb2x1bW5zIGJhc2VkIG9uIGluZGV4XG4gKiBcdFx0XHR9KSk7XG4gKiBcdFx0fSk7XG4gKiBcdFx0bmV3RGF0YS5wdXNoKHJvdyk7XG4gKiBcdH0pO1xuICogXHRyZXR1cm4gbmV3RGF0YTtcbiAqIH1cbiAqIGBgYFxuICovXG5AQ29tcG9uZW50KHtcblx0c2VsZWN0b3I6IFwiY2RzLXRhYmxlLCBpYm0tdGFibGVcIixcblx0dGVtcGxhdGU6IGBcblx0PHRhYmxlXG5cdFx0Y2RzVGFibGVcblx0XHRbc29ydGFibGVdPVwic29ydGFibGVcIlxuXHRcdFtub0JvcmRlcl09XCJub0JvcmRlclwiXG5cdFx0W25nQ2xhc3NdPVwieydjZHMtLWRhdGEtdGFibGUtLXN0aWNreS1oZWFkZXInOiBzdGlja3lIZWFkZXJ9XCJcblx0XHRbc2l6ZV09XCJzaXplXCJcblx0XHRbc3RyaXBlZF09XCJzdHJpcGVkXCJcblx0XHRbc2tlbGV0b25dPVwic2tlbGV0b25cIlxuXHRcdFthdHRyLmFyaWEtbGFiZWxsZWRieV09XCJhcmlhTGFiZWxsZWRieVwiXG5cdFx0W2F0dHIuYXJpYS1kZXNjcmliZWRieV09XCJhcmlhRGVzY3JpYmVkYnlcIj5cblx0XHQ8dGhlYWRcblx0XHRcdGNkc1RhYmxlSGVhZFxuXHRcdFx0W3NvcnRhYmxlXT1cInNvcnRhYmxlXCJcblx0XHRcdChkZXNlbGVjdEFsbCk9XCJvbkRlc2VsZWN0QWxsKClcIlxuXHRcdFx0KHNlbGVjdEFsbCk9XCJvblNlbGVjdEFsbCgpXCJcblx0XHRcdChleHBhbmRBbGxSb3dzKT1cIm1vZGVsLmV4cGFuZEFsbFJvd3ModHJ1ZSlcIlxuXHRcdFx0KGNvbGxhcHNlQWxsUm93cyk9XCJtb2RlbC5leHBhbmRBbGxSb3dzKGZhbHNlKVwiXG5cdFx0XHQoc29ydCk9XCJkb1NvcnQoJGV2ZW50KVwiXG5cdFx0XHRbY2hlY2tib3hIZWFkZXJMYWJlbF09XCJnZXRDaGVja2JveEhlYWRlckxhYmVsKClcIlxuXHRcdFx0W2ZpbHRlclRpdGxlXT1cImdldEZpbHRlclRpdGxlKClcIlxuXHRcdFx0W21vZGVsXT1cIm1vZGVsXCJcblx0XHRcdFtzZWxlY3RBbGxDaGVja2JveF09XCJzZWxlY3RBbGxDaGVja2JveFwiXG5cdFx0XHRbc2VsZWN0QWxsQ2hlY2tib3hTb21lU2VsZWN0ZWRdPVwic2VsZWN0QWxsQ2hlY2tib3hTb21lU2VsZWN0ZWRcIlxuXHRcdFx0W3Nob3dTZWxlY3Rpb25Db2x1bW5dPVwic2hvd1NlbGVjdGlvbkNvbHVtblwiXG5cdFx0XHRbZW5hYmxlU2luZ2xlU2VsZWN0XT1cImVuYWJsZVNpbmdsZVNlbGVjdFwiXG5cdFx0XHRbc2hvd0V4cGFuZEFsbFRvZ2dsZV09XCJzaG93RXhwYW5kQWxsVG9nZ2xlXCJcblx0XHRcdFtza2VsZXRvbl09XCJza2VsZXRvblwiXG5cdFx0XHRbc29ydEFzY2VuZGluZ0xhYmVsXT1cInNvcnRBc2NlbmRpbmdMYWJlbFwiXG5cdFx0XHRbc29ydERlc2NlbmRpbmdMYWJlbF09XCJzb3J0RGVzY2VuZGluZ0xhYmVsXCJcblx0XHRcdFtzdGlja3lIZWFkZXJdPVwic3RpY2t5SGVhZGVyXCI+XG5cdFx0PC90aGVhZD5cblx0XHQ8dGJvZHlcblx0XHRcdGNkc1RhYmxlQm9keVxuXHRcdFx0KGRlc2VsZWN0Um93KT1cIm9uU2VsZWN0Um93KCRldmVudClcIlxuXHRcdFx0KHNjcm9sbCk9XCJvblNjcm9sbCgkZXZlbnQpXCJcblx0XHRcdChzZWxlY3RSb3cpPVwib25TZWxlY3RSb3coJGV2ZW50KVwiXG5cdFx0XHRbY2hlY2tib3hSb3dMYWJlbF09XCJnZXRDaGVja2JveFJvd0xhYmVsKClcIlxuXHRcdFx0W2VuYWJsZVNpbmdsZVNlbGVjdF09XCJlbmFibGVTaW5nbGVTZWxlY3RcIlxuXHRcdFx0KHJvd0NsaWNrKT1cIm9uUm93Q2xpY2soJGV2ZW50KVwiXG5cdFx0XHRbZXhwYW5kQnV0dG9uQXJpYUxhYmVsXT1cImV4cGFuZEJ1dHRvbkFyaWFMYWJlbFwiXG5cdFx0XHRbbW9kZWxdPVwibW9kZWxcIlxuXHRcdFx0W3NpemVdPVwic2l6ZVwiXG5cdFx0XHRbbmdTdHlsZV09XCJ7J292ZXJmbG93LXknOiAnc2Nyb2xsJ31cIlxuXHRcdFx0W3NlbGVjdGlvbkxhYmVsQ29sdW1uXT1cInNlbGVjdGlvbkxhYmVsQ29sdW1uXCJcblx0XHRcdFtzaG93U2VsZWN0aW9uQ29sdW1uXT1cInNob3dTZWxlY3Rpb25Db2x1bW5cIlxuXHRcdFx0W3NrZWxldG9uXT1cInNrZWxldG9uXCJcblx0XHRcdCpuZ0lmPVwiIW5vRGF0YTsgZWxzZSBub0RhdGFUZW1wbGF0ZVwiPlxuXHRcdDwvdGJvZHk+XG5cdFx0PG5nLXRlbXBsYXRlICNub0RhdGFUZW1wbGF0ZT48bmctY29udGVudD48L25nLWNvbnRlbnQ+PC9uZy10ZW1wbGF0ZT5cblx0XHQ8dGZvb3Q+XG5cdFx0XHQ8bmctdGVtcGxhdGVcblx0XHRcdFx0W25nVGVtcGxhdGVPdXRsZXRdPVwiZm9vdGVyVGVtcGxhdGVcIj5cblx0XHRcdDwvbmctdGVtcGxhdGU+XG5cdFx0XHQ8dHIgKm5nSWY9XCJ0aGlzLm1vZGVsLmlzTG9hZGluZ1wiPlxuXHRcdFx0XHQ8dGQgY2xhc3M9XCJ0YWJsZV9sb2FkaW5nLWluZGljYXRvclwiPlxuXHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJjZHMtLWxvYWRpbmcgY2RzLS1sb2FkaW5nLS1zbWFsbFwiPlxuXHRcdFx0XHRcdFx0PHN2ZyBjbGFzcz1cImNkcy0tbG9hZGluZ19fc3ZnXCIgdmlld0JveD1cIi03NSAtNzUgMTUwIDE1MFwiPlxuXHRcdFx0XHRcdFx0XHQ8Y2lyY2xlIGNsYXNzPVwiY2RzLS1sb2FkaW5nX19zdHJva2VcIiBjeD1cIjBcIiBjeT1cIjBcIiByPVwiMzcuNVwiIC8+XG5cdFx0XHRcdFx0XHQ8L3N2Zz5cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PC90ZD5cblx0XHRcdDwvdHI+XG5cdFx0XHQ8dHIgKm5nSWY9XCJ0aGlzLm1vZGVsLmlzRW5kXCI+XG5cdFx0XHRcdDx0ZCBjbGFzcz1cInRhYmxlX2VuZC1pbmRpY2F0b3JcIj5cblx0XHRcdFx0XHQ8aDU+e3tnZXRFbmRPZkRhdGFUZXh0KCkgfCBhc3luY319PC9oNT5cblx0XHRcdFx0XHQ8YnV0dG9uIChjbGljayk9XCJzY3JvbGxUb1RvcCgkZXZlbnQpXCIgY2xhc3M9XCJidG4tLXNlY29uZGFyeS1zbVwiPlxuXHRcdFx0XHRcdFx0e3tnZXRTY3JvbGxUb3BUZXh0KCkgfCBhc3luY319XG5cdFx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHRcdDwvdGQ+XG5cdFx0XHQ8L3RyPlxuXHRcdDwvdGZvb3Q+XG5cdDwvdGFibGU+XG5cdGAsXG5cdHN0eWxlczogW2Bcblx0XHQ6aG9zdCB7XG5cdFx0XHRkaXNwbGF5OiBibG9jaztcblx0XHR9XG5cdGBdXG59KVxuZXhwb3J0IGNsYXNzIFRhYmxlIGltcGxlbWVudHMgT25Jbml0LCBBZnRlclZpZXdJbml0LCBPbkRlc3Ryb3kge1xuXHQvKipcblx0ICogQ3JlYXRlcyBhIHNrZWxldG9uIG1vZGVsIHdpdGggYSByb3cgYW5kIGNvbHVtbiBjb3VudCBzcGVjaWZpZWQgYnkgdGhlIHVzZXJcblx0ICpcblx0ICogRXhhbXBsZTpcblx0ICpcblx0ICogYGBgdHlwZXNjcmlwdFxuXHQgKiB0aGlzLm1vZGVsID0gVGFibGUuc2tlbGV0b25Nb2RlbCg1LCA1KTtcblx0ICogYGBgXG5cdCAqL1xuXHRzdGF0aWMgc2tlbGV0b25Nb2RlbChyb3dDb3VudDogbnVtYmVyLCBjb2x1bW5Db3VudDogbnVtYmVyKSB7XG5cdFx0Y29uc3QgbW9kZWwgPSBuZXcgVGFibGVNb2RlbCgpO1xuXHRcdGxldCBoZWFkZXIgPSBuZXcgQXJyYXk8VGFibGVIZWFkZXJJdGVtPigpO1xuXHRcdGxldCBkYXRhID0gbmV3IEFycmF5PEFycmF5PFRhYmxlSXRlbT4+KCk7XG5cdFx0bGV0IHJvdyA9IG5ldyBBcnJheTxUYWJsZUl0ZW0+KCk7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGNvbHVtbkNvdW50OyBpKyspIHtcblx0XHRcdGhlYWRlci5wdXNoKG5ldyBUYWJsZUhlYWRlckl0ZW0oKSk7XG5cdFx0XHRyb3cucHVzaChuZXcgVGFibGVJdGVtKCkpO1xuXHRcdH1cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHJvd0NvdW50IC0gMTsgaSsrKSB7XG5cdFx0XHRkYXRhLnB1c2gocm93KTtcblx0XHR9XG5cblx0XHRtb2RlbC5oZWFkZXIgPSBoZWFkZXI7XG5cdFx0bW9kZWwuZGF0YSA9IGRhdGE7XG5cdFx0cmV0dXJuIG1vZGVsO1xuXHR9XG5cblx0c3RhdGljIHNldFRhYkluZGV4KGVsZW1lbnQ6IEhUTUxFbGVtZW50LCBpbmRleDogLTEgfCAwKSB7XG5cdFx0Y29uc3QgZm9jdXNFbGVtZW50TGlzdCA9IGdldEZvY3VzRWxlbWVudExpc3QoZWxlbWVudCwgdGFiYmFibGVTZWxlY3Rvcklnbm9yZVRhYkluZGV4KTtcblx0XHRpZiAoZWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZCAmJiBlbGVtZW50LmZpcnN0RWxlbWVudENoaWxkLmNsYXNzTGlzdC5jb250YWlucyhcImNkcy0tdGFibGUtc29ydFwiKSAmJiBmb2N1c0VsZW1lbnRMaXN0Lmxlbmd0aCA+IDEpIHtcblx0XHRcdGZvY3VzRWxlbWVudExpc3RbMV0udGFiSW5kZXggPSBpbmRleDtcblx0XHR9IGVsc2UgaWYgKGZvY3VzRWxlbWVudExpc3QubGVuZ3RoID4gMCkge1xuXHRcdFx0Zm9jdXNFbGVtZW50TGlzdFswXS50YWJJbmRleCA9IGluZGV4O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlbGVtZW50LnRhYkluZGV4ID0gaW5kZXg7XG5cdFx0fVxuXHR9XG5cblx0c3RhdGljIGZvY3VzKGVsZW1lbnQ6IEhUTUxFbGVtZW50KSB7XG5cdFx0Y29uc3QgZm9jdXNFbGVtZW50TGlzdCA9IGdldEZvY3VzRWxlbWVudExpc3QoZWxlbWVudCwgdGFiYmFibGVTZWxlY3Rvcklnbm9yZVRhYkluZGV4KTtcblx0XHRpZiAoXG5cdFx0XHQoZWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZD8uY2xhc3NMaXN0LmNvbnRhaW5zKFwiY2RzLS10YWJsZS1zb3J0XCIpICYmIGZvY3VzRWxlbWVudExpc3QubGVuZ3RoID4gMSkgfHxcblx0XHRcdGZvY3VzRWxlbWVudExpc3QubGVuZ3RoID4gMFxuXHRcdCkge1xuXHRcdFx0Zm9jdXNFbGVtZW50TGlzdFswXS5mb2N1cygpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlbGVtZW50LmZvY3VzKCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIElkIG9mIHRoZSB0YWJsZSBoZWFkZXIgdGl0bGUgZWxlbWVudFxuXHQgKi9cblx0QElucHV0KCkgYXJpYUxhYmVsbGVkYnk6IHN0cmluZztcblx0LyoqXG5cdCAqIElkIG9mIHRoZSB0YWJsZSBoZWFkZXIgZGVzY3JpcHRpb24gZWxlbWVudFxuXHQgKi9cblx0QElucHV0KCkgYXJpYURlc2NyaWJlZGJ5OiBzdHJpbmc7XG5cblx0LyoqXG5cdCAqIGBUYWJsZU1vZGVsYCB3aXRoIGRhdGEgdGhlIHRhYmxlIGlzIHRvIGRpc3BsYXkuXG5cdCAqL1xuXHRASW5wdXQoKVxuXHRzZXQgbW9kZWwobTogVGFibGVNb2RlbCkge1xuXHRcdGlmICh0aGlzLl9tb2RlbCkge1xuXHRcdFx0dGhpcy5zdWJzY3JpcHRpb25zLnVuc3Vic2NyaWJlKCk7XG5cdFx0XHQvLyBOZWVkIHRvIGNyZWF0ZSBhIG5ldyBzdWJzY3JpcHRpb24gaW5zdGFuY2UgaGVyZSBiZWNhdXNlIHVuc3Vic2NyaWJpbmcgcHJldmVudHMgYW55IG5ldyBzdWJzY3JpcHRpb25zXG5cdFx0XHQvLyBmcm9tIGJlaW5nIGFkZGVkIGZvciBzb21lIHJlYXNvbi4gV2hlbiBhIG5ldyBtb2RlbCBpcyBzZXQsIG5vbmUgb2YgdGhlIHN1YnNjcmlwdGlvbnMgd291bGQgZXhpc3QuXG5cdFx0XHR0aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fbW9kZWwgPSBtO1xuXG5cdFx0Y29uc3Qgcm93c0NoYW5nZSA9IHRoaXMuX21vZGVsLnJvd3NTZWxlY3RlZENoYW5nZS5zdWJzY3JpYmUoKCkgPT4gdGhpcy51cGRhdGVTZWxlY3RBbGxDaGVja2JveCgpKTtcblx0XHRjb25zdCBkYXRhQ2hhbmdlID0gdGhpcy5fbW9kZWwuZGF0YUNoYW5nZS5zdWJzY3JpYmUoKCkgPT4ge1xuXHRcdFx0aWYgKHRoaXMuaXNEYXRhR3JpZCkge1xuXHRcdFx0XHR0aGlzLnJlc2V0VGFiSW5kZXgoKTtcblx0XHRcdH1cblx0XHRcdHRoaXMudXBkYXRlU2VsZWN0QWxsQ2hlY2tib3goKTtcblx0XHR9KTtcblxuXHRcdHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQocm93c0NoYW5nZSk7XG5cdFx0dGhpcy5zdWJzY3JpcHRpb25zLmFkZChkYXRhQ2hhbmdlKTtcblxuXHRcdGlmICh0aGlzLmlzRGF0YUdyaWQpIHtcblx0XHRcdGNvbnN0IGV4cGFuZGVkQ2hhbmdlID0gdGhpcy5fbW9kZWwucm93c0V4cGFuZGVkQ2hhbmdlLnN1YnNjcmliZSgoKSA9PiB7XG5cdFx0XHRcdC8vIEFsbG93cyB0aGUgZXhwYW5kZWQgcm93IHRvIGhhdmUgYSBmb2N1cyBzdGF0ZSB3aGVuIGl0IGV4aXN0cyBpbiB0aGUgRE9NXG5cdFx0XHRcdHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IGV4cGFuZGVkUm93cyA9IHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuY2RzLS1leHBhbmRhYmxlLXJvdzpub3QoLmNkcy0tcGFyZW50LXJvdylcIik7XG5cdFx0XHRcdFx0QXJyYXkuZnJvbTxhbnk+KGV4cGFuZGVkUm93cykuZm9yRWFjaChyb3cgPT4ge1xuXHRcdFx0XHRcdFx0aWYgKHJvdy5maXJzdEVsZW1lbnRDaGlsZC50YWJJbmRleCA9PT0gdW5kZWZpbmVkIHx8IHJvdy5maXJzdEVsZW1lbnRDaGlsZC50YWJJbmRleCAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdFx0cm93LmZpcnN0RWxlbWVudENoaWxkLnRhYkluZGV4ID0gLTE7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKGV4cGFuZGVkQ2hhbmdlKTtcblx0XHR9XG5cdH1cblxuXHRnZXQgbW9kZWwoKTogVGFibGVNb2RlbCB7XG5cdFx0cmV0dXJuIHRoaXMuX21vZGVsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNpemUgb2YgdGhlIHRhYmxlIHJvd3MuXG5cdCAqL1xuXHRASW5wdXQoKSBzaXplOiBUYWJsZVJvd1NpemUgPSBcIm1kXCI7XG5cdC8qKlxuXHQgKiBTZXQgdG8gYHRydWVgIGZvciBhIGxvYWRpbmcgdGFibGUuXG5cdCAqL1xuXHRASW5wdXQoKSBza2VsZXRvbiA9IGZhbHNlO1xuXHQvKipcblx0ICogU2V0IHRvIGB0cnVlYCBmb3IgYSBkYXRhIGdyaWQgd2l0aCBrZXlib2FyZCBpbnRlcmFjdGlvbnMuXG5cdCAqL1xuXHRASW5wdXQoKSBzZXQgaXNEYXRhR3JpZCh2YWx1ZTogYm9vbGVhbikge1xuXHRcdHRoaXMuX2lzRGF0YUdyaWQgPSB2YWx1ZTtcblx0XHRpZiAodGhpcy5pc1ZpZXdSZWFkeSkge1xuXHRcdFx0aWYgKHZhbHVlKSB7XG5cdFx0XHRcdHRoaXMuZW5hYmxlRGF0YUdyaWRJbnRlcmFjdGlvbnMoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuZGlzYWJsZURhdGFHcmlkSW50ZXJhY3Rpb25zKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHRpbmcgc29ydGFibGUgdG8gZmFsc2Ugd2lsbCBkaXNhYmxlIGFsbCBoZWFkZXJzIGluY2x1ZGluZyBoZWFkZXJzIHdoaWNoIGFyZSBzb3J0YWJsZS4gSXMgaXNcblx0ICogcG9zc2libGUgdG8gc2V0IHRoZSBzb3J0YWJsZSBzdGF0ZSBvbiB0aGUgaGVhZGVyIGl0ZW0gdG8gZGlzYWJsZS9lbmFibGUgc29ydGluZyBmb3Igb25seSBzb21lIGhlYWRlcnMuXG5cdCAqL1xuXHRASW5wdXQoKSBzb3J0YWJsZSA9IHRydWU7XG5cblx0QElucHV0KCkgbm9Cb3JkZXIgPSB0cnVlO1xuXG5cdC8qKlxuXHQgKiBTZXQgdG8gYHRydWVgIHRvIHNob3cgZXhwYW5zaW9uIHRvZ2dsZSB3aGVuIHRhYmxlIGNvbnNpc3RzIG9mIHJvdyBleHBhbnNpb25zXG5cdCAqL1xuXHRASW5wdXQoKSBzaG93RXhwYW5kQWxsVG9nZ2xlID0gZmFsc2U7XG5cblx0Z2V0IGlzRGF0YUdyaWQoKTogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIHRoaXMuX2lzRGF0YUdyaWQ7XG5cdH1cblxuXHQvKipcblx0ICogQ29udHJvbHMgd2hldGhlciB0byBzaG93IHRoZSBzZWxlY3Rpb24gY2hlY2tib3hlcyBjb2x1bW4gb3Igbm90LlxuXHQgKi9cblx0QElucHV0KCkgc2hvd1NlbGVjdGlvbkNvbHVtbiA9IHRydWU7XG5cblx0LyoqXG5cdCAqIENvbnRyb2xzIHdoZXRoZXIgdG8gZW5hYmxlIG11bHRpcGxlIG9yIHNpbmdsZSByb3cgc2VsZWN0aW9uLlxuXHQgKi9cblx0QElucHV0KCkgZW5hYmxlU2luZ2xlU2VsZWN0ID0gZmFsc2U7XG5cblx0LyoqXG5cdCAqIERpc3RhbmNlIChpbiBweCkgZnJvbSB0aGUgYm90dG9tIHRoYXQgdmlldyBoYXMgdG8gcmVhY2ggYmVmb3JlXG5cdCAqIGBzY3JvbGxMb2FkYCBldmVudCBpcyBlbWl0dGVkLlxuXHQgKi9cblx0QElucHV0KCkgc2Nyb2xsTG9hZERpc3RhbmNlID0gMDtcblxuXHQvKipcblx0ICogQHRvZG8gLSBFbmFibGUgY29sdW1uIHJlc2l6ZSB3aGVuIENhcmJvbiBvZmZpY2lhbGx5IHN1cHBvcnRzIGZlYXR1cmVcblx0ICogU2V0IHRvIGB0cnVlYCB0byBlbmFibGUgdXNlcnMgdG8gcmVzaXplIGNvbHVtbnMuXG5cdCAqXG5cdCAqIFdvcmtzIGZvciBjb2x1bW5zIHdpdGggd2lkdGggc2V0IGluIHBpeGVscy5cblx0ICpcblx0ICovXG5cdC8vIEBJbnB1dCgpIGNvbHVtbnNSZXNpemFibGUgPSBmYWxzZTtcblxuXHQvKipcblx0ICogQHRvZG8gLSBFbmFibGUgY29sdW1ucyBkcmFnICYgZHJvcCB3aGVuIENhcmJvbiBvZmZpY2lhbGx5IHN1cHBvcnRzIGZlYXR1cmVcblx0ICogU2V0IHRvIGB0cnVlYCB0byBlbmFibGUgdXNlcnMgdG8gZHJhZyBhbmQgZHJvcCBjb2x1bW5zLlxuXHQgKlxuXHQgKiBDaGFuZ2luZyB0aGUgY29sdW1uIG9yZGVyIGluIHRhYmxlIGNoYW5nZXMgdGFibGUgbW9kZWwuIEJlIGF3YXJlIG9mIGl0IHdoZW4geW91IGFkZCBhZGRpdGlvbmFsIGRhdGFcblx0ICogdG8gdGhlIG1vZGVsLlxuXHQgKlxuXHQgKi9cblx0Ly8gQElucHV0KCkgY29sdW1uc0RyYWdnYWJsZSA9IGZhbHNlO1xuXG5cdEBJbnB1dCgpXG5cdHNldCBleHBhbmRCdXR0b25BcmlhTGFiZWwodmFsdWU6IHN0cmluZyB8IE9ic2VydmFibGU8c3RyaW5nPikge1xuXHRcdHRoaXMuX2V4cGFuZEJ1dHRvbkFyaWFMYWJlbC5vdmVycmlkZSh2YWx1ZSk7XG5cdH1cblx0Z2V0IGV4cGFuZEJ1dHRvbkFyaWFMYWJlbCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZXhwYW5kQnV0dG9uQXJpYUxhYmVsLnZhbHVlO1xuXHR9XG5cdEBJbnB1dCgpXG5cdHNldCBzb3J0RGVzY2VuZGluZ0xhYmVsKHZhbHVlOiBzdHJpbmcgfCBPYnNlcnZhYmxlPHN0cmluZz4pIHtcblx0XHR0aGlzLl9zb3J0RGVzY2VuZGluZ0xhYmVsLm92ZXJyaWRlKHZhbHVlKTtcblx0fVxuXHRnZXQgc29ydERlc2NlbmRpbmdMYWJlbCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fc29ydERlc2NlbmRpbmdMYWJlbC52YWx1ZTtcblx0fVxuXHRASW5wdXQoKVxuXHRzZXQgc29ydEFzY2VuZGluZ0xhYmVsKHZhbHVlOiBzdHJpbmcgfCBPYnNlcnZhYmxlPHN0cmluZz4pIHtcblx0XHR0aGlzLl9zb3J0QXNjZW5kaW5nTGFiZWwub3ZlcnJpZGUodmFsdWUpO1xuXHR9XG5cdGdldCBzb3J0QXNjZW5kaW5nTGFiZWwoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NvcnRBc2NlbmRpbmdMYWJlbC52YWx1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBFeHBlY3RzIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIHNvbWUgb3IgYWxsIG9mOlxuXHQgKiBgYGBcblx0ICoge1xuXHQgKlx0XHRcIkZJTFRFUlwiOiBcIkZpbHRlclwiLFxuXHQgKlx0XHRcIkVORF9PRl9EQVRBXCI6IFwiWW91J3ZlIHJlYWNoZWQgdGhlIGVuZCBvZiB5b3VyIGNvbnRlbnRcIixcblx0ICpcdFx0XCJTQ1JPTExfVE9QXCI6IFwiU2Nyb2xsIHRvIHRvcFwiLFxuXHQgKlx0XHRcIkNIRUNLQk9YX0hFQURFUlwiOiBcIlNlbGVjdCBhbGwgcm93c1wiLFxuXHQgKlx0XHRcIkNIRUNLQk9YX1JPV1wiOiBcIlNlbGVjdCByb3dcIlxuXHQgKiB9XG5cdCAqIGBgYFxuXHQgKi9cblx0QElucHV0KClcblx0c2V0IHRyYW5zbGF0aW9ucyh2YWx1ZSkge1xuXHRcdGNvbnN0IHZhbHVlV2l0aERlZmF1bHRzID0gbWVyZ2UodGhpcy5pMThuLmdldE11bHRpcGxlKFwiVEFCTEVcIiksIHZhbHVlKTtcblx0XHR0aGlzLl9maWx0ZXJUaXRsZS5vdmVycmlkZSh2YWx1ZVdpdGhEZWZhdWx0cy5GSUxURVIpO1xuXHRcdHRoaXMuX2VuZE9mRGF0YVRleHQub3ZlcnJpZGUodmFsdWVXaXRoRGVmYXVsdHMuRU5EX09GX0RBVEEpO1xuXHRcdHRoaXMuX3Njcm9sbFRvcFRleHQub3ZlcnJpZGUodmFsdWVXaXRoRGVmYXVsdHMuU0NST0xMX1RPUCk7XG5cdFx0dGhpcy5fY2hlY2tib3hIZWFkZXJMYWJlbC5vdmVycmlkZSh2YWx1ZVdpdGhEZWZhdWx0cy5DSEVDS0JPWF9IRUFERVIpO1xuXHRcdHRoaXMuX2NoZWNrYm94Um93TGFiZWwub3ZlcnJpZGUodmFsdWVXaXRoRGVmYXVsdHMuQ0hFQ0tCT1hfUk9XKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXQgdG8gYGZhbHNlYCB0byByZW1vdmUgdGFibGUgcm93cyAoemVicmEpIHN0cmlwZXMuXG5cdCAqL1xuXHRASW5wdXQoKSBzdHJpcGVkID0gdHJ1ZTtcblxuXHQvKipcblx0ICogQWxsb3dzIHRhYmxlIGNvbnRlbnQgdG8gc2Nyb2xsIGhvcml6b250YWxseVxuXHQgKi9cblx0QEhvc3RCaW5kaW5nKFwiY2xhc3MuY2RzLS1kYXRhLXRhYmxlLWNvbnRlbnRcIikgdGFibGVDb250ZW50ID0gdHJ1ZTtcblxuXHQvKipcblx0ICogU2V0IHRvIGB0cnVlYCB0byBzdGljayB0aGUgaGVhZGVyIHRvIHRoZSB0b3Agb2YgdGhlIHRhYmxlXG5cdCAqL1xuXHRASG9zdEJpbmRpbmcoXCJjbGFzcy5jZHMtLWRhdGEtdGFibGVfaW5uZXItY29udGFpbmVyXCIpIEBJbnB1dCgpIHN0aWNreUhlYWRlciA9IGZhbHNlO1xuXG5cdC8qKlxuXHQgKiBTZXQgZm9vdGVyIHRlbXBsYXRlIHRvIGN1c3RvbWl6ZSB3aGF0IGlzIGRpc3BsYXllZCBpbiB0aGUgdGZvb3Qgc2VjdGlvbiBvZiB0aGUgdGFibGVcblx0ICovXG5cdEBJbnB1dCgpIGZvb3RlclRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG5cdC8qKlxuXHQgKiBVc2VkIHRvIHBvcHVsYXRlIHRoZSByb3cgc2VsZWN0aW9uIGNoZWNrYm94IGxhYmVsIHdpdGggYSB1c2VmdWwgdmFsdWUgaWYgc2V0LlxuXHQgKlxuXHQgKiBFeGFtcGxlOlxuXHQgKiBgYGBcblx0ICogPGNkcy10YWJsZSBbc2VsZWN0aW9uTGFiZWxDb2x1bW5dPVwiMFwiPjwvY2RzLXRhYmxlPlxuXHQgKiA8IS0tIHJlc3VsdHMgaW4gYXJpYS1sYWJlbD1cIlNlbGVjdCBmaXJzdCBjb2x1bW4gdmFsdWVcIlxuXHQgKiAod2hlcmUgXCJmaXJzdCBjb2x1bW4gdmFsdWVcIiBpcyB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGNvbHVtbiBpbiB0aGUgcm93IC0tPlxuXHQgKiBgYGBcblx0ICovXG5cdEBJbnB1dCgpIHNlbGVjdGlvbkxhYmVsQ29sdW1uOiBudW1iZXI7XG5cblx0LyoqXG5cdCAqIEVtaXRzIGFuIGluZGV4IG9mIHRoZSBjb2x1bW4gdGhhdCB3YW50cyB0byBiZSBzb3J0ZWQuXG5cdCAqXG5cdCAqIElmIG5vIG9ic2VydmVycyBhcmUgcHJvdmlkZWQgKGRlZmF1bHQpLCB0YWJsZSB3aWxsIGF0dGVtcHQgdG8gZG8gYSBzaW1wbGUgc29ydCBvZiB0aGUgZGF0YSBsb2FkZWRcblx0ICogaW50byB0aGUgbW9kZWwuXG5cdCAqXG5cdCAqIElmIGFuIG9ic2VydmVyIGlzIHByb3ZpZGVkLCB0YWJsZSB3aWxsIG5vdCBhdHRlbXB0IGFueSBzb3J0aW5nIG9mIGl0cyBvd24gYW5kIGl0IGlzIHVwIHRvIHRoZSBvYnNlcnZlclxuXHQgKiB0byBzb3J0IHRoZSB0YWJsZS4gVGhpcyBpcyB3aGF0IHlvdSB0eXBpY2FsbHkgd2FudCBpZiB5b3UncmUgdXNpbmcgYSBiYWNrZW5kIHF1ZXJ5IHRvIGdldCB0aGUgc29ydGVkXG5cdCAqIGRhdGEgb3Igd2FudCB0byBzb3J0IGRhdGEgYWNyb3NzIG11bHRpcGxlIHBhZ2VzLlxuXHQgKlxuXHQgKiBVc2FnZTpcblx0ICpcblx0ICogYGBgdHlwZXNjcmlwdFxuXHQgKiBAQ29tcG9uZW50KHtcblx0ICogXHRzZWxlY3RvcjogXCJhcHAtdGFibGVcIixcblx0ICogXHR0ZW1wbGF0ZTogYFxuXHQgKiBcdFx0PGNkcy10YWJsZVxuXHQgKiBcdFx0XHRbbW9kZWxdPVwibW9kZWxcIlxuXHQgKiBcdFx0XHQoc29ydCk9XCJzaW1wbGVTb3J0KCRldmVudClcIj5cblx0ICogXHRcdFx0Tm8gZGF0YS5cblx0ICogXHRcdDwvY2RzLXRhYmxlPlxuXHQgKiBcdGBcblx0ICogfSlcblx0ICogZXhwb3J0IGNsYXNzIFRhYmxlQXBwIGltcGxlbWVudHMgT25Jbml0LCBPbkNoYW5nZXMge1xuXHQgKiBcdEBJbnB1dCgpIG1vZGVsID0gbmV3IFRhYmxlTW9kZWwoKTtcblx0ICpcblx0ICogXHRuZ09uSW5pdCgpIHtcblx0ICogXHRcdHRoaXMubW9kZWwuaGVhZGVyID0gW1xuXHQgKiBcdFx0XHRuZXcgVGFibGVIZWFkZXJJdGVtKHsgZGF0YTogXCJOYW1lXCIgfSksXG5cdCAqIFx0XHRcdG5ldyBUYWJsZUhlYWRlckl0ZW0oeyBkYXRhOiBcImh3ZXJcIiB9KVxuXHQgKiBcdFx0XTtcblx0ICpcblx0ICogXHRcdHRoaXMubW9kZWwuZGF0YSA9IFtcblx0ICogXHRcdFx0W25ldyBUYWJsZUl0ZW0oeyBkYXRhOiBcIk5hbWUgMVwiIH0pLCBuZXcgVGFibGVJdGVtKHsgZGF0YTogXCJxd2VyXCIgfSldLFxuXHQgKiBcdFx0XHRbbmV3IFRhYmxlSXRlbSh7IGRhdGE6IFwiTmFtZSAzXCIgfSksIG5ldyBUYWJsZUl0ZW0oeyBkYXRhOiBcInp3ZXJcIiB9KV0sXG5cdCAqIFx0XHRcdFtuZXcgVGFibGVJdGVtKHsgZGF0YTogXCJOYW1lIDJcIiB9KSwgbmV3IFRhYmxlSXRlbSh7IGRhdGE6IFwic3dlclwiIH0pXSxcblx0ICogXHRcdFx0W25ldyBUYWJsZUl0ZW0oeyBkYXRhOiBcIk5hbWUgNFwiIH0pLCBuZXcgVGFibGVJdGVtKHtkYXRhOiBcInR3ZXJcIn0pXSxcblx0ICogXHRcdFx0W25ldyBUYWJsZUl0ZW0oeyBkYXRhOiBcIk5hbWUgNVwiIH0pLCBuZXcgVGFibGVJdGVtKHtkYXRhOiBcInR3ZXJcIn0pXSxcblx0ICogXHRcdFx0W25ldyBUYWJsZUl0ZW0oeyBkYXRhOiBcIk5hbWUgNlwiIH0pLCBuZXcgVGFibGVJdGVtKHtkYXRhOiBcInR3ZXJcIn0pXVxuXHQgKiBcdFx0XTtcblx0ICogXHR9XG5cdCAqXG5cdCAqIFx0c2ltcGxlU29ydChpbmRleDogbnVtYmVyKSB7XG5cdCAqIFx0XHQvLyB0aGlzIGZ1bmN0aW9uIGRvZXMgYSBzaW1wbGUgc29ydCwgd2hpY2ggaXMgdGhlIGRlZmF1bHQgZm9yIHRoZSB0YWJsZSBhbmQgaWYgdGhhdCdzXG5cdCAqIFx0XHQvLyBhbGwgeW91IHdhbnQsIHlvdSBkb24ndCBuZWVkIHRvIGRvIHRoaXMuXG5cdCAqXG5cdCAqIFx0XHQvLyBoZXJlIHlvdSBjYW4gcXVlcnkgeW91ciBiYWNrZW5kIGFuZCB1cGRhdGUgdGhlIG1vZGVsLmRhdGEgYmFzZWQgb24gdGhlIHJlc3VsdFxuXHQgKiBcdFx0aWYgKHRoaXMubW9kZWwuaGVhZGVyW2luZGV4XS5zb3J0ZWQpIHtcblx0ICogXHRcdFx0Ly8gaWYgYWxyZWFkeSBzb3J0ZWQgZmxpcCBzb3J0aW5nIGRpcmVjdGlvblxuXHQgKiBcdFx0XHR0aGlzLm1vZGVsLmhlYWRlcltpbmRleF0uYXNjZW5kaW5nID0gdGhpcy5tb2RlbC5oZWFkZXJbaW5kZXhdLmRlc2NlbmRpbmc7XG5cdCAqIFx0XHR9XG5cdCAqIFx0XHR0aGlzLm1vZGVsLnNvcnQoaW5kZXgpO1xuXHQgKiBcdH1cblx0ICogfVxuXHQgKiBgYGBcblx0ICovXG5cdEBPdXRwdXQoKSBzb3J0ID0gbmV3IEV2ZW50RW1pdHRlcjxudW1iZXI+KCk7XG5cblx0LyoqXG5cdCAqIEVtaXRzIGlmIGFsbCByb3dzIGFyZSBzZWxlY3RlZC5cblx0ICpcblx0ICogQHBhcmFtIG1vZGVsXG5cdCAqL1xuXHRAT3V0cHV0KCkgc2VsZWN0QWxsID0gbmV3IEV2ZW50RW1pdHRlcjxPYmplY3Q+KCk7XG5cblx0LyoqXG5cdCAqIEVtaXRzIGlmIGFsbCByb3dzIGFyZSBkZXNlbGVjdGVkLlxuXHQgKlxuXHQgKiBAcGFyYW0gbW9kZWxcblx0ICovXG5cdEBPdXRwdXQoKSBkZXNlbGVjdEFsbCA9IG5ldyBFdmVudEVtaXR0ZXI8T2JqZWN0PigpO1xuXG5cdC8qKlxuXHQgKiBFbWl0cyBpZiBhIHNpbmdsZSByb3cgaXMgc2VsZWN0ZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSAoe21vZGVsOiB0aGlzLm1vZGVsLCBzZWxlY3RlZFJvd0luZGV4OiBpbmRleH0pXG5cdCAqL1xuXHRAT3V0cHV0KCkgc2VsZWN0Um93ID0gbmV3IEV2ZW50RW1pdHRlcjxPYmplY3Q+KCk7XG5cblx0LyoqXG5cdCAqIEVtaXRzIGlmIGEgc2luZ2xlIHJvdyBpcyBkZXNlbGVjdGVkLlxuXHQgKlxuXHQgKiBAcGFyYW0gKHttb2RlbDogdGhpcy5tb2RlbCwgZGVzZWxlY3RlZFJvd0luZGV4OiBpbmRleH0pXG5cdCAqL1xuXHRAT3V0cHV0KCkgZGVzZWxlY3RSb3cgPSBuZXcgRXZlbnRFbWl0dGVyPE9iamVjdD4oKTtcblxuXHQvKipcblx0ICogRW1pdHMgaWYgYSByb3cgaXRlbSBleGNsdWRpbmcgZXhwYW5kQnV0dG9ucywgY2hlY2tib3hlcywgb3IgcmFkaW9zIGlzIGNsaWNrZWQuXG5cdCAqL1xuXHRAT3V0cHV0KCkgcm93Q2xpY2sgPSBuZXcgRXZlbnRFbWl0dGVyPG51bWJlcj4oKTtcblxuXHQvKipcblx0ICogRW1pdHMgd2hlbiB0YWJsZSByZXF1aXJlcyBtb3JlIGRhdGEgdG8gYmUgbG9hZGVkLlxuXHQgKi9cblx0QE91dHB1dCgpIHNjcm9sbExvYWQgPSBuZXcgRXZlbnRFbWl0dGVyPFRhYmxlTW9kZWw+KCk7XG5cblx0LyoqXG5cdCAqIENvbnRyb2xzIGlmIGFsbCBjaGVja2JveGVzIGFyZSB2aWV3ZWQgYXMgc2VsZWN0ZWQuXG5cdCAqL1xuXHRzZWxlY3RBbGxDaGVja2JveCA9IGZhbHNlO1xuXG5cdC8qKlxuXHQgKiBDb250cm9scyB0aGUgaW5kZXRlcm1pbmF0ZSBzdGF0ZSBvZiB0aGUgaGVhZGVyIGNoZWNrYm94LlxuXHQgKi9cblx0c2VsZWN0QWxsQ2hlY2tib3hTb21lU2VsZWN0ZWQgPSBmYWxzZTtcblxuXHRnZXQgbm9EYXRhKCkge1xuXHRcdHJldHVybiAhdGhpcy5tb2RlbC5kYXRhIHx8XG5cdFx0XHR0aGlzLm1vZGVsLmRhdGEubGVuZ3RoID09PSAwIHx8XG5cdFx0XHR0aGlzLm1vZGVsLmRhdGEubGVuZ3RoID09PSAxICYmIHRoaXMubW9kZWwuZGF0YVswXS5sZW5ndGggPT09IDA7XG5cdH1cblxuXHRwdWJsaWMgaXNDb2x1bW5EcmFnZ2luZyA9IGZhbHNlO1xuXHRwdWJsaWMgY29sdW1uRHJhZ2dlZEhvdmVySW5kZXggPSAtMTtcblx0cHVibGljIGNvbHVtbkRyYWdnZWRQb3NpdGlvbiA9IFwiXCI7XG5cblx0cHJvdGVjdGVkIF9tb2RlbDogVGFibGVNb2RlbDtcblx0cHJvdGVjdGVkIF9pc0RhdGFHcmlkID0gZmFsc2U7XG5cdC8vIGZsYWcgdG8gcHJldmVudCBnZXR0ZXJzL3NldHRlcnMgZnJvbSBxdWVyeWluZyB0aGUgdmlldyBiZWZvcmUgaXQncyBmdWxseSBpbnN0YW50aWF0ZWRcblx0cHJvdGVjdGVkIGlzVmlld1JlYWR5ID0gZmFsc2U7XG5cblx0cHJvdGVjdGVkIHN1YnNjcmlwdGlvbnMgPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG5cdHByb3RlY3RlZCBwb3NpdGlvblN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG5cdHByb3RlY3RlZCBpbnRlcmFjdGlvbk1vZGVsOiBEYXRhR3JpZEludGVyYWN0aW9uTW9kZWw7XG5cdHByb3RlY3RlZCBpbnRlcmFjdGlvblBvc2l0aW9uU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cblx0cHJvdGVjdGVkIF9leHBhbmRCdXR0b25BcmlhTGFiZWwgPSB0aGlzLmkxOG4uZ2V0T3ZlcnJpZGFibGUoXCJUQUJMRS5FWFBBTkRfQlVUVE9OXCIpO1xuXHRwcm90ZWN0ZWQgX3NvcnREZXNjZW5kaW5nTGFiZWwgPSB0aGlzLmkxOG4uZ2V0T3ZlcnJpZGFibGUoXCJUQUJMRS5TT1JUX0RFU0NFTkRJTkdcIik7XG5cdHByb3RlY3RlZCBfc29ydEFzY2VuZGluZ0xhYmVsID0gdGhpcy5pMThuLmdldE92ZXJyaWRhYmxlKFwiVEFCTEUuU09SVF9BU0NFTkRJTkdcIik7XG5cdHByb3RlY3RlZCBfY2hlY2tib3hIZWFkZXJMYWJlbCA9IHRoaXMuaTE4bi5nZXRPdmVycmlkYWJsZShcIlRBQkxFLkNIRUNLQk9YX0hFQURFUlwiKTtcblx0cHJvdGVjdGVkIF9jaGVja2JveFJvd0xhYmVsID0gdGhpcy5pMThuLmdldE92ZXJyaWRhYmxlKFwiVEFCTEUuQ0hFQ0tCT1hfUk9XXCIpO1xuXHRwcm90ZWN0ZWQgX2VuZE9mRGF0YVRleHQgPSB0aGlzLmkxOG4uZ2V0T3ZlcnJpZGFibGUoXCJUQUJMRS5FTkRfT0ZfREFUQVwiKTtcblx0cHJvdGVjdGVkIF9zY3JvbGxUb3BUZXh0ID0gdGhpcy5pMThuLmdldE92ZXJyaWRhYmxlKFwiVEFCTEUuU0NST0xMX1RPUFwiKTtcblx0cHJvdGVjdGVkIF9maWx0ZXJUaXRsZSA9IHRoaXMuaTE4bi5nZXRPdmVycmlkYWJsZShcIlRBQkxFLkZJTFRFUlwiKTtcblxuXHRwcm90ZWN0ZWQgY29sdW1uUmVzaXplV2lkdGg6IG51bWJlcjtcblx0cHJvdGVjdGVkIGNvbHVtblJlc2l6ZU1vdXNlWDogbnVtYmVyO1xuXHRwcm90ZWN0ZWQgbW91c2VNb3ZlU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cdHByb3RlY3RlZCBtb3VzZVVwU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgVGFibGUuXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcihcblx0XHRwcm90ZWN0ZWQgZWxlbWVudFJlZjogRWxlbWVudFJlZixcblx0XHRwcm90ZWN0ZWQgYXBwbGljYXRpb25SZWY6IEFwcGxpY2F0aW9uUmVmLFxuXHRcdHByb3RlY3RlZCBpMThuOiBJMThuXG5cdCkgeyB9XG5cblx0bmdPbkluaXQoKSB7XG5cdFx0Ly8gTWFudWFsbHkgdHJpZ2dlciBjaGVjayB0byBzZWUgaWYgYWxsIGNoZWNrYm94ZXMgYXJlIHNlbGVjdGVkXG5cdFx0Ly8gVGhpcyBpcyBzaW5jZSBzdWJzY3JpcHRpb24gaXMgbWFkZSBBRlRFUiBjaGVja2JveGVzIGFyZSBzZWxlY3RlZFxuXHRcdHRoaXMudXBkYXRlU2VsZWN0QWxsQ2hlY2tib3goKTtcblx0fVxuXG5cdG5nQWZ0ZXJWaWV3SW5pdCgpIHtcblx0XHR0aGlzLmlzVmlld1JlYWR5ID0gdHJ1ZTtcblx0XHRpZiAodGhpcy5pc0RhdGFHcmlkKSB7XG5cdFx0XHR0aGlzLmVuYWJsZURhdGFHcmlkSW50ZXJhY3Rpb25zKCk7XG5cdFx0fVxuXHR9XG5cblx0bmdPbkRlc3Ryb3koKSB7XG5cdFx0dGhpcy5zdWJzY3JpcHRpb25zLnVuc3Vic2NyaWJlKCk7XG5cdFx0aWYgKHRoaXMucG9zaXRpb25TdWJzY3JpcHRpb24pIHtcblx0XHRcdHRoaXMucG9zaXRpb25TdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcblx0XHR9XG5cdH1cblxuXHRlbmFibGVEYXRhR3JpZEludGVyYWN0aW9ucygpIHtcblx0XHQvLyBpZiB3ZSBoYXZlIGFuIGBpbnRlcmFjdGlvTW9kZWxgIHdlJ3ZlIGFscmVhZHkgZW5hYmxlZCBkYXRhZ3JpZFxuXHRcdGlmICh0aGlzLmludGVyYWN0aW9uTW9kZWwpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0Y29uc3QgdGFibGUgPSB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKFwidGFibGVcIikgYXMgSFRNTFRhYmxlRWxlbWVudDtcblx0XHRjb25zdCB0YWJsZUFkYXB0ZXIgPSBuZXcgVGFibGVEb21BZGFwdGVyKHRhYmxlKTtcblx0XHRjb25zdCBrZXlkb3duRXZlbnRTdHJlYW0gPSBmcm9tRXZlbnQ8S2V5Ym9hcmRFdmVudD4odGFibGUsIFwia2V5ZG93blwiKTtcblx0XHRjb25zdCBjbGlja0V2ZW50U3RyZWFtID0gZnJvbUV2ZW50PE1vdXNlRXZlbnQ+KHRhYmxlLCBcImNsaWNrXCIpO1xuXHRcdHRoaXMuaW50ZXJhY3Rpb25Nb2RlbCA9IG5ldyBEYXRhR3JpZEludGVyYWN0aW9uTW9kZWwoa2V5ZG93bkV2ZW50U3RyZWFtLCBjbGlja0V2ZW50U3RyZWFtLCB0YWJsZUFkYXB0ZXIpO1xuXHRcdHRoaXMucG9zaXRpb25TdWJzY3JpcHRpb24gPSB0aGlzLmludGVyYWN0aW9uTW9kZWwucG9zaXRpb24uc3Vic2NyaWJlKGV2ZW50ID0+IHtcblx0XHRcdGNvbnN0IFtjdXJyZW50Um93LCBjdXJyZW50Q29sdW1uXSA9IGV2ZW50LmN1cnJlbnQ7XG5cdFx0XHRjb25zdCBbcHJldmlvdXNSb3csIHByZXZpb3VzQ29sdW1uXSA9IGV2ZW50LnByZXZpb3VzO1xuXG5cdFx0XHRjb25zdCBjdXJyZW50RWxlbWVudCA9IHRhYmxlQWRhcHRlci5nZXRDZWxsKGN1cnJlbnRSb3csIGN1cnJlbnRDb2x1bW4pO1xuXHRcdFx0VGFibGUuc2V0VGFiSW5kZXgoY3VycmVudEVsZW1lbnQsIDApO1xuXG5cdFx0XHQvLyBpZiB0aGUgbW9kZWwgaGFzIGp1c3QgaW5pdGlhbGl6ZWQgZG9uJ3QgZm9jdXMgb3IgcmVzZXQgYW55dGhpbmdcblx0XHRcdGlmIChwcmV2aW91c1JvdyA9PT0gLTEgfHwgcHJldmlvdXNDb2x1bW4gPT09IC0xKSB7IHJldHVybjsgfVxuXHRcdFx0Ly8gTWFrZSB0aGUgcHJldmlvdXMgY2VsbCB1bmZvY3VzYWJsZSAoaWYgaXQncyBub3QgdGhlIGN1cnJlbnQpXG5cdFx0XHRpZiAocHJldmlvdXNSb3cgIT09IGN1cnJlbnRSb3cgfHwgcHJldmlvdXNDb2x1bW4gIT09IGN1cnJlbnRDb2x1bW4pIHtcblx0XHRcdFx0Y29uc3QgcHJldmlvdXNFbGVtZW50ID0gdGFibGVBZGFwdGVyLmdldENlbGwocHJldmlvdXNSb3csIHByZXZpb3VzQ29sdW1uKTtcblx0XHRcdFx0VGFibGUuc2V0VGFiSW5kZXgocHJldmlvdXNFbGVtZW50LCAtMSk7XG5cdFx0XHR9XG5cdFx0XHRUYWJsZS5mb2N1cyhjdXJyZW50RWxlbWVudCk7XG5cdFx0fSk7XG5cdFx0Ly8gY2FsbCB0aGlzIGFmdGVyIGFzc2lnbmluZyBgdGhpcy5pbnRlcmFjdGlvbk1vZGVsYCBzaW5jZSBpdCBkZXBlbmRzIG9uIGl0XG5cdFx0dGhpcy5yZXNldFRhYkluZGV4KCk7XG5cdH1cblxuXHRkaXNhYmxlRGF0YUdyaWRJbnRlcmFjdGlvbnMoKSB7XG5cdFx0Ly8gdW5zdWJzY3JpYmUgZmlyc3Qgc28gd2UgZG9uJ3QgY2F1c2UgdGhlIGZvY3VzIHRvIGZseSBhcm91bmRcblx0XHRpZiAodGhpcy5wb3NpdGlvblN1YnNjcmlwdGlvbikge1xuXHRcdFx0dGhpcy5wb3NpdGlvblN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuXHRcdH1cblx0XHQvLyB1bmRvIHRhYiBpbmRleGluZyAoYWxzbyByZXNldHMgdGhlIG1vZGVsKVxuXHRcdHRoaXMucmVzZXRUYWJJbmRleCgwKTtcblx0XHQvLyBudWxsIG91dCB0aGUgbW9kZWwgcmVmXG5cdFx0dGhpcy5pbnRlcmFjdGlvbk1vZGVsID0gbnVsbDtcblx0fVxuXG5cdG9uU2VsZWN0QWxsKCkge1xuXHRcdHRoaXMubW9kZWwuc2VsZWN0QWxsKHRydWUpO1xuXHRcdHRoaXMuc2VsZWN0QWxsLmVtaXQodGhpcy5tb2RlbCk7XG5cdH1cblxuXHRvbkRlc2VsZWN0QWxsKCkge1xuXHRcdHRoaXMubW9kZWwuc2VsZWN0QWxsKGZhbHNlKTtcblx0XHR0aGlzLmRlc2VsZWN0QWxsLmVtaXQodGhpcy5tb2RlbCk7XG5cdH1cblxuXHRvblNlbGVjdFJvdyhldmVudCkge1xuXHRcdC8vIGNoZWNrIGZvciB0aGUgZXhpc3RlbmNlIG9mIHRoZSBzZWxlY3RlZFJvd0luZGV4IHByb3BlcnR5XG5cdFx0aWYgKE9iamVjdC5rZXlzKGV2ZW50KS5pbmNsdWRlcyhcInNlbGVjdGVkUm93SW5kZXhcIikpIHtcblx0XHRcdGlmICh0aGlzLmVuYWJsZVNpbmdsZVNlbGVjdCkge1xuXHRcdFx0XHR0aGlzLm1vZGVsLnNlbGVjdEFsbChmYWxzZSk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLm1vZGVsLnNlbGVjdFJvdyhldmVudC5zZWxlY3RlZFJvd0luZGV4LCB0cnVlKTtcblx0XHRcdHRoaXMuc2VsZWN0Um93LmVtaXQoZXZlbnQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLm1vZGVsLnNlbGVjdFJvdyhldmVudC5kZXNlbGVjdGVkUm93SW5kZXgsIGZhbHNlKTtcblx0XHRcdHRoaXMuZGVzZWxlY3RSb3cuZW1pdChldmVudCk7XG5cdFx0fVxuXHR9XG5cblx0b25Sb3dDbGljayhpbmRleDogbnVtYmVyKSB7XG5cdFx0dGhpcy5yb3dDbGljay5lbWl0KGluZGV4KTtcblx0fVxuXG5cdHVwZGF0ZVNlbGVjdEFsbENoZWNrYm94KCkge1xuXHRcdGNvbnN0IHNlbGVjdGVkUm93c0NvdW50ID0gdGhpcy5tb2RlbC5zZWxlY3RlZFJvd3NDb3VudCgpO1xuXG5cdFx0aWYgKHNlbGVjdGVkUm93c0NvdW50IDw9IDApIHtcblx0XHRcdC8vIHJlc2V0IHNlbGVjdCBhbGwgY2hlY2tib3ggaWYgbm90aGluZyBzZWxlY3RlZFxuXHRcdFx0dGhpcy5zZWxlY3RBbGxDaGVja2JveCA9IGZhbHNlO1xuXHRcdFx0dGhpcy5zZWxlY3RBbGxDaGVja2JveFNvbWVTZWxlY3RlZCA9IGZhbHNlO1xuXHRcdH0gZWxzZSBpZiAoc2VsZWN0ZWRSb3dzQ291bnQgPCB0aGlzLm1vZGVsLmRhdGEubGVuZ3RoKSB7XG5cdFx0XHR0aGlzLnNlbGVjdEFsbENoZWNrYm94ID0gdHJ1ZTtcblx0XHRcdHRoaXMuc2VsZWN0QWxsQ2hlY2tib3hTb21lU2VsZWN0ZWQgPSB0cnVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnNlbGVjdEFsbENoZWNrYm94ID0gdHJ1ZTtcblx0XHRcdHRoaXMuc2VsZWN0QWxsQ2hlY2tib3hTb21lU2VsZWN0ZWQgPSBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHRyZXNldFRhYkluZGV4KG5ld1RhYkluZGV4ID0gLTEpIHtcblx0XHQvLyBlbnN1cmUgdGhlIHZpZXcgaXMgcmVhZHkgZm9yIHRoZSByZXNldCBiZWZvcmUgd2UgcHJlZm9ybSB0aGUgYWN0dWFsIHJlc2V0XG5cdFx0c2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHQvLyByZXNldCBhbGwgdGhlIHRhYkluZGV4ZXMgd2UgY2FuIGZpbmRcblx0XHRcdGNvbnN0IGZvY3VzRWxlbWVudExpc3QgPSBnZXRGb2N1c0VsZW1lbnRMaXN0KHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCB0YWJiYWJsZVNlbGVjdG9ySWdub3JlVGFiSW5kZXgpO1xuXHRcdFx0aWYgKGZvY3VzRWxlbWVudExpc3QpIHtcblx0XHRcdFx0Zm9jdXNFbGVtZW50TGlzdC5mb3JFYWNoKHRhYmJhYmxlID0+IHtcblx0XHRcdFx0XHR0YWJiYWJsZS50YWJJbmRleCA9IG5ld1RhYkluZGV4O1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdC8vIHJlc2V0IGludGVyYWN0aW9uIG1vZGVsIHBvc2l0aW9ucyBhbmQgdGFiSW5kZXhlc1xuXHRcdFx0aWYgKHRoaXMuaW50ZXJhY3Rpb25Nb2RlbCkge1xuXHRcdFx0XHR0aGlzLmludGVyYWN0aW9uTW9kZWwucmVzZXRUYWJJbmRleGVzKG5ld1RhYkluZGV4KTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdGNvbHVtblJlc2l6ZVN0YXJ0KGV2ZW50LCBjb2x1bW4pIHtcblx0XHR0aGlzLmNvbHVtblJlc2l6ZVdpZHRoID0gcGFyc2VJbnQoY29sdW1uLnN0eWxlLndpZHRoLCAxMCk7XG5cdFx0dGhpcy5jb2x1bW5SZXNpemVNb3VzZVggPSBldmVudC5jbGllbnRYO1xuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHR0aGlzLm1vdXNlTW92ZVN1YnNjcmlwdGlvbiA9IGZyb21FdmVudChkb2N1bWVudC5ib2R5LCBcIm1vdXNlbW92ZVwiKS5zdWJzY3JpYmUoZXZlbnQgPT4ge1xuXHRcdFx0dGhpcy5jb2x1bW5SZXNpemVQcm9ncmVzcyhldmVudCwgY29sdW1uKTtcblx0XHR9KTtcblx0XHR0aGlzLm1vdXNlVXBTdWJzY3JpcHRpb24gPSBmcm9tRXZlbnQoZG9jdW1lbnQuYm9keSwgXCJtb3VzZXVwXCIpLnN1YnNjcmliZShldmVudCA9PiB7XG5cdFx0XHR0aGlzLmNvbHVtblJlc2l6ZUVuZChldmVudCwgY29sdW1uKTtcblx0XHR9KTtcblx0fVxuXG5cdGNvbHVtblJlc2l6ZVByb2dyZXNzKGV2ZW50LCBjb2x1bW4pIHtcblx0XHRjb25zdCBtb3ZlID0gZXZlbnQuY2xpZW50WCAtIHRoaXMuY29sdW1uUmVzaXplTW91c2VYO1xuXHRcdGNvbHVtbi5zdHlsZS53aWR0aCA9IGAke3RoaXMuY29sdW1uUmVzaXplV2lkdGggKyBtb3ZlfXB4YDtcblx0fVxuXG5cdGNvbHVtblJlc2l6ZUVuZChldmVudCwgY29sdW1uKSB7XG5cdFx0dGhpcy5tb3VzZU1vdmVTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcblx0XHR0aGlzLm1vdXNlVXBTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUcmlnZ2VyZWQgd2hlbiB0aGUgdXNlciBzY3JvbGxzIG9uIHRoZSBgPHRib2R5PmAgZWxlbWVudC5cblx0ICogRW1pdHMgdGhlIGBzY3JvbGxMb2FkYCBldmVudC5cblx0ICovXG5cdG9uU2Nyb2xsKGV2ZW50KSB7XG5cdFx0Y29uc3QgZGlzdGFuY2VGcm9tQm90dG9tID0gZXZlbnQudGFyZ2V0LnNjcm9sbEhlaWdodCAtIGV2ZW50LnRhcmdldC5jbGllbnRIZWlnaHQgLSBldmVudC50YXJnZXQuc2Nyb2xsVG9wO1xuXG5cdFx0aWYgKGRpc3RhbmNlRnJvbUJvdHRvbSA8PSB0aGlzLnNjcm9sbExvYWREaXN0YW5jZSkge1xuXHRcdFx0dGhpcy5zY3JvbGxMb2FkLmVtaXQodGhpcy5tb2RlbCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMubW9kZWwuaXNFbmQgPSBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHRjb2x1bW5EcmFnU3RhcnQoZXZlbnQsIGNvbHVtbkluZGV4KSB7XG5cdFx0dGhpcy5pc0NvbHVtbkRyYWdnaW5nID0gdHJ1ZTtcblx0XHR0aGlzLmNvbHVtbkRyYWdnZWRIb3ZlckluZGV4ID0gY29sdW1uSW5kZXg7XG5cdFx0ZXZlbnQuZGF0YVRyYW5zZmVyLnNldERhdGEoXCJjb2x1bW5JbmRleFwiLCBKU09OLnN0cmluZ2lmeShjb2x1bW5JbmRleCkpO1xuXHR9XG5cblx0Y29sdW1uRHJhZ0VuZChldmVudCwgY29sdW1uSW5kZXgpIHtcblx0XHR0aGlzLmlzQ29sdW1uRHJhZ2dpbmcgPSBmYWxzZTtcblx0XHR0aGlzLmNvbHVtbkRyYWdnZWRIb3ZlckluZGV4ID0gLTE7XG5cdH1cblxuXHRjb2x1bW5EcmFnRW50ZXIoZXZlbnQsIHBvc2l0aW9uLCBjb2x1bW5JbmRleCkge1xuXHRcdHRoaXMuY29sdW1uRHJhZ2dlZFBvc2l0aW9uID0gcG9zaXRpb247XG5cdFx0dGhpcy5jb2x1bW5EcmFnZ2VkSG92ZXJJbmRleCA9IGNvbHVtbkluZGV4O1xuXHR9XG5cblx0Y29sdW1uRHJhZ0xlYXZlKGV2ZW50LCBwb3NpdGlvbiwgY29sdW1uSW5kZXgpIHtcblx0XHR0aGlzLmNvbHVtbkRyYWdnZWRQb3NpdGlvbiA9IFwiXCI7XG5cdH1cblxuXHRjb2x1bW5EcmFnb3ZlcihldmVudCwgcG9zaXRpb24sIGNvbHVtbkluZGV4KSB7XG5cdFx0dGhpcy5jb2x1bW5EcmFnZ2VkSG92ZXJJbmRleCA9IGNvbHVtbkluZGV4O1xuXHRcdHRoaXMuY29sdW1uRHJhZ2dlZFBvc2l0aW9uID0gcG9zaXRpb247XG5cblx0XHQvLyBuZWVkZWQgdG8gdGVsbCBicm93c2VyIHRvIGFsbG93IGRyb3BwaW5nXG5cdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0fVxuXG5cdGNvbHVtbkRyb3AoZXZlbnQsIHBvc2l0aW9uLCBjb2x1bW5JbmRleCkge1xuXHRcdHRoaXMuaXNDb2x1bW5EcmFnZ2luZyA9IGZhbHNlO1xuXHRcdHRoaXMuY29sdW1uRHJhZ2dlZEhvdmVySW5kZXggPSAtMTtcblx0XHR0aGlzLmNvbHVtbkRyYWdnZWRQb3NpdGlvbiA9IFwiXCI7XG5cblx0XHR0aGlzLm1vZGVsLm1vdmVDb2x1bW4oXG5cdFx0XHRwYXJzZUludChldmVudC5kYXRhVHJhbnNmZXIuZ2V0RGF0YShcImNvbHVtbkluZGV4XCIpLCAxMCksXG5cdFx0XHRjb2x1bW5JbmRleCArIChwb3NpdGlvbiA9PT0gXCJyaWdodFwiID8gMSA6IDApXG5cdFx0KTtcblx0fVxuXG5cdGRvU29ydChpbmRleDogbnVtYmVyKSB7XG5cdFx0aWYgKHRoaXMuc29ydC5vYnNlcnZlcnMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHQvLyBubyBzb3J0IHByb3ZpZGVkIHNvIGRvIHRoZSBzaW1wbGUgc29ydFxuXHRcdFx0dGhpcy5tb2RlbC5jeWNsZVNvcnRTdGF0ZShpbmRleCk7XG5cdFx0XHR0aGlzLm1vZGVsLnNvcnQoaW5kZXgpO1xuXHRcdH1cblxuXHRcdHRoaXMuc29ydC5lbWl0KGluZGV4KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUcmlnZ2VyZWQgd2hlbiB0aGUgdXNlciBzY3JvbGxzIG9uIHRoZSBgPHRib2R5PmAgZWxlbWVudC5cblx0ICogRW1pdHMgdGhlIGBzY3JvbGxMb2FkYCBldmVudC5cblx0ICovXG5cdHNjcm9sbFRvVG9wKGV2ZW50KSB7XG5cdFx0ZXZlbnQudGFyZ2V0LnBhcmVudEVsZW1lbnQucGFyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50LnBhcmVudEVsZW1lbnQuY2hpbGRyZW5bMV0uc2Nyb2xsVG9wID0gMDtcblx0XHR0aGlzLm1vZGVsLmlzRW5kID0gZmFsc2U7XG5cdH1cblxuXHRnZXRTZWxlY3Rpb25MYWJlbFZhbHVlKHJvdzogVGFibGVJdGVtW10pIHtcblx0XHRpZiAoIXRoaXMuc2VsZWN0aW9uTGFiZWxDb2x1bW4pIHtcblx0XHRcdHJldHVybiB7IHZhbHVlOiB0aGlzLmkxOG4uZ2V0KCkuVEFCTEUuUk9XIH07XG5cdFx0fVxuXHRcdHJldHVybiB7IHZhbHVlOiByb3dbdGhpcy5zZWxlY3Rpb25MYWJlbENvbHVtbl0uZGF0YSB9O1xuXHR9XG5cblx0Z2V0RXhwYW5kQnV0dG9uQXJpYUxhYmVsKCkge1xuXHRcdHJldHVybiB0aGlzLl9leHBhbmRCdXR0b25BcmlhTGFiZWwuc3ViamVjdDtcblx0fVxuXHRnZXRTb3J0RGVzY2VuZGluZ0xhYmVsKCkge1xuXHRcdHJldHVybiB0aGlzLl9zb3J0RGVzY2VuZGluZ0xhYmVsLnN1YmplY3Q7XG5cdH1cblx0Z2V0U29ydEFzY2VuZGluZ0xhYmVsKCkge1xuXHRcdHJldHVybiB0aGlzLl9zb3J0QXNjZW5kaW5nTGFiZWwuc3ViamVjdDtcblx0fVxuXG5cdGdldENoZWNrYm94SGVhZGVyTGFiZWwoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NoZWNrYm94SGVhZGVyTGFiZWwuc3ViamVjdDtcblx0fVxuXG5cdGdldENoZWNrYm94Um93TGFiZWwoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NoZWNrYm94Um93TGFiZWwuc3ViamVjdDtcblx0fVxuXG5cdGdldEVuZE9mRGF0YVRleHQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2VuZE9mRGF0YVRleHQuc3ViamVjdDtcblx0fVxuXG5cdGdldFNjcm9sbFRvcFRleHQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Njcm9sbFRvcFRleHQuc3ViamVjdDtcblx0fVxuXG5cdGdldEZpbHRlclRpdGxlKCkge1xuXHRcdHJldHVybiB0aGlzLl9maWx0ZXJUaXRsZS5zdWJqZWN0O1xuXHR9XG59XG4iXX0=