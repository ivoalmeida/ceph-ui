import { EventEmitter } from "@angular/core";
import { TableHeaderItem } from "./table-header-item.class";
import { TableItem } from "./table-item.class";
import { Subject } from "rxjs";
/**
 * TableModel represents a data model for two-dimensional data. It's used for all things table
 * (table component, table toolbar, pagination, etc)
 *
 * TableModel manages its internal data integrity very well if you use the provided helper
 * functions for modifying rows and columns and assigning header and data in that order.
 *
 * It also provides direct access to the data so you can read and modify it.
 * If you change the structure of the data (by directly pushing into the arrays or otherwise),
 * keep in mind to keep the data structure intact.
 *
 * Header length and length of every line in the data should be equal.
 *
 * If they are not consistent, unexpected things will happen.
 *
 * Use the provided functions when in doubt.
 */
export class TableModel {
    constructor() {
        this.dataChange = new EventEmitter();
        this.rowsSelectedChange = new EventEmitter();
        this.rowsExpandedChange = new EventEmitter();
        this.rowsExpandedAllChange = new EventEmitter();
        this.rowsCollapsedAllChange = new EventEmitter();
        /**
         * Gets emitted when `selectAll` is called. Emits false if all rows are deselected and true if
         * all rows are selected.
         */
        this.selectAllChange = new Subject();
        /**
         * Contains information about selection state of rows in the table.
         */
        this.rowsSelected = [];
        /**
         * Contains information about expanded state of rows in the table.
         */
        this.rowsExpanded = [];
        /**
         * Contains information about initial index of rows in the table
         */
        this.rowsIndices = [];
        /**
         * Contains information about the context of the row.
         *
         * It affects styling of the row to reflect the context.
         *
         * string can be one of `"success" | "warning" | "info" | "error" | ""` and it's
         * empty or undefined by default
         */
        this.rowsContext = [];
        /**
         * Contains class name(s) of the row.
         *
         * It affects styling of the row to reflect the appended class name(s).
         *
         * It's empty or undefined by default
         */
        this.rowsClass = [];
        /**
         * Contains information about the header cells of the table.
         */
        this.header = [];
        /**
         * Tracks the current page.
         */
        this.currentPage = 1;
        /**
         * Length of page.
         */
        this.pageLength = 10;
        /**
         * Set to true when there is no more data to load in the table
         */
        this.isEnd = false;
        /**
         * Set to true when lazy loading to show loading indicator
         */
        this.isLoading = false;
        /**
         * Used in `data`
         */
        this._data = [[]];
        /**
         * The number of models instantiated, this is to make sure each table has a different
         * model count for unique id generation.
         */
        this.tableModelCount = 0;
        this.tableModelCount = TableModel.COUNT++;
    }
    /**
     * Sets data of the table.
     *
     * Make sure all rows are the same length to keep the column count accurate.
     */
    set data(newData) {
        if (!newData || (Array.isArray(newData) && newData.length === 0)) {
            newData = [[]];
        }
        this._data = newData;
        // init rowsSelected
        this.rowsSelected = new Array(this._data.length).fill(false);
        this.rowsExpanded = new Array(this._data.length).fill(false);
        // init rows indices
        this.rowsIndices = [...Array(this._data.length).keys()];
        // init rowsContext
        this.rowsContext = new Array(this._data.length);
        // init rowsClass
        this.rowsClass = new Array(this._data.length);
        // only create a fresh header if necessary (header doesn't exist or differs in length)
        if (this.header == null || (this.header.length !== this._data[0].length && this._data[0].length > 0)) {
            let header = new Array();
            for (let i = 0; i < this._data[0].length; i++) {
                header.push(new TableHeaderItem());
            }
            this.header = header;
        }
        this.dataChange.emit();
    }
    /**
     * Gets the full data.
     *
     * You can use it to alter individual `TableItem`s but if you need to change
     * table structure, use `addRow()` and/or `addColumn()`
     */
    get data() {
        return this._data;
    }
    /**
     * Manually set data length in case the data in the table doesn't
     * correctly reflect all the data that table is to display.
     *
     * Example: if you have multiple pages of data that table will display
     * but you're loading one at a time.
     *
     * Set to `null` to reset to default behavior.
     */
    set totalDataLength(length) {
        // if this function is called without a parameter we need to set to null to avoid having undefined != null
        this._totalDataLength = isNaN(length) ? null : length;
    }
    /**
     * Total length of data that table has access to, or the amount manually set
     */
    get totalDataLength() {
        // if manually set data length
        if (this._totalDataLength !== null && this._totalDataLength >= 0) {
            return this._totalDataLength;
        }
        // if empty dataset
        if (this.data && this.data.length === 1 && this.data[0].length === 0) {
            return 0;
        }
        return this.data.length;
    }
    /**
     * Returns an id for the given column
     *
     * @param column the column to generate an id for
     * @param row the row of the header to generate an id for
     */
    getId(column, row = 0) {
        return `table-header-${row}-${column}-${this.tableModelCount}`;
    }
    /**
     * Returns the id of the header. Used to link the cells with headers (or headers with headers)
     *
     * @param column the column to start getting headers for
     * @param colSpan the number of columns to get headers for (defaults to 1)
     */
    getHeaderId(column, colSpan = 1) {
        if (column === "select" || column === "expand") {
            return this.getId(column);
        }
        let ids = [];
        for (let i = column; i >= 0; i--) {
            if (this.header[i]) {
                for (let j = 0; j < colSpan; j++) {
                    ids.push(this.getId(i + j));
                }
                break;
            }
        }
        return ids.join(" ");
    }
    /**
     * Finds closest header by trying the `column` and then working its way to the left
     *
     * @param column the target column
     */
    getHeader(column) {
        if (!this.header) {
            return null;
        }
        for (let i = column; i >= 0; i--) {
            const headerCell = this.header[i];
            if (headerCell) {
                return headerCell;
            }
        }
        return null;
    }
    /**
     * Returns how many rows is currently selected
     */
    selectedRowsCount() {
        let count = 0;
        if (this.rowsSelected) {
            this.rowsSelected.forEach(rowSelected => {
                if (rowSelected) {
                    count++;
                }
            });
        }
        return count;
    }
    /**
     * Returns how many rows is currently expanded
     */
    expandedRowsCount() {
        let count = 0;
        if (this.rowsExpanded) {
            this.rowsExpanded.forEach(rowExpanded => {
                if (rowExpanded) {
                    count++;
                }
            });
        }
        return count;
    }
    /**
     * Returns `index`th row of the table.
     *
     * Negative index starts from the end. -1 being the last element.
     *
     * @param index
     */
    row(index) {
        return this.data[this.realRowIndex(index)];
    }
    /**
     * Adds a row to the `index`th row or appends to table if index not provided.
     *
     * If row is shorter than other rows or not provided, it will be padded with
     * empty `TableItem` elements.
     *
     * If row is longer than other rows, others will be extended to match so no data is lost.
     *
     * If called on an empty table with no parameters, it creates a 1x1 table.
     *
     * Negative index starts from the end. -1 being the last element.
     *
     * @param [row]
     * @param [index]
     */
    addRow(row, index) {
        // if table empty create table with row
        if (!this.data || this.data.length === 0 || this.data[0].length === 0) {
            let newData = new Array();
            newData.push(row ? row : [new TableItem()]); // row or one empty one column row
            this.data = newData;
            return;
        }
        let realRow = row;
        const columnCount = this.data[0].length;
        if (row == null) {
            realRow = new Array();
            for (let i = 0; i < columnCount; i++) {
                realRow.push(new TableItem());
            }
        }
        if (realRow.length < columnCount) {
            // extend the length of realRow
            const difference = columnCount - realRow.length;
            for (let i = 0; i < difference; i++) {
                realRow.push(new TableItem());
            }
        }
        else if (realRow.length > columnCount) {
            // extend the length of header
            let difference = realRow.length - this.header.length;
            for (let j = 0; j < difference; j++) {
                this.header.push(new TableHeaderItem());
            }
            // extend the length of every other row
            for (let i = 0; i < this.data.length; i++) {
                let currentRow = this.data[i];
                difference = realRow.length - currentRow.length;
                for (let j = 0; j < difference; j++) {
                    currentRow.push(new TableItem());
                }
            }
        }
        if (index == null) {
            this.data.push(realRow);
            // update rowsSelected property for length
            this.rowsSelected.push(false);
            // update rowsExpanded property for length
            this.rowsExpanded.push(false);
            // update rowsContext property for length
            this.rowsContext.push(undefined);
            // update rowsClass property for length
            this.rowsClass.push(undefined);
            // update rowsIndices property for length
            this.rowsIndices.push(this.data.length - 1);
        }
        else {
            const ri = this.realRowIndex(index);
            this.data.splice(ri, 0, realRow);
            // update rowsSelected property for length
            this.rowsSelected.splice(ri, 0, false);
            // update rowsExpanded property for length
            this.rowsExpanded.splice(ri, 0, false);
            // update rowsContext property for length
            this.rowsContext.splice(ri, 0, undefined);
            // update rowsClass property for length
            this.rowsClass.splice(ri, 0, undefined);
            // update rowsIndices property for length
            this.rowsIndices.splice(ri, 0, this.data.length - 1);
        }
        this.dataChange.emit();
    }
    /**
     * Deletes `index`th row.
     *
     * Negative index starts from the end. -1 being the last element.
     *
     * @param index
     */
    deleteRow(index) {
        const rri = this.realRowIndex(index);
        this.data.splice(rri, 1);
        this.rowsSelected.splice(rri, 1);
        this.rowsExpanded.splice(rri, 1);
        this.rowsContext.splice(rri, 1);
        this.rowsClass.splice(rri, 1);
        const rowIndex = this.rowsIndices[rri];
        this.rowsIndices.splice(rri, 1);
        this.rowsIndices = this.rowsIndices.map((value) => (value > rowIndex) ? --value : value);
        this.dataChange.emit();
    }
    /**
     * Deletes all rows.
     */
    deleteAllRows() {
        this.data = [];
    }
    hasExpandableRows() {
        return this.data.some(data => data.some(d => d && d.expandedData)); // checking for some in 2D array
    }
    /**
     * Number of rows that can be expanded.
     *
     * @returns number
     */
    expandableRowsCount() {
        return this.data.reduce((counter, _, index) => {
            counter = (this.isRowExpandable(index)) ? counter + 1 : counter;
            return counter;
        }, 0);
    }
    isRowExpandable(index) {
        return this.data[index].some(d => d && d.expandedData);
    }
    isRowExpanded(index) {
        return this.rowsExpanded[index];
    }
    getRowContext(index) {
        return this.rowsContext[index];
    }
    /**
     * Returns `index`th column of the table.
     *
     * Negative index starts from the end. -1 being the last element.
     *
     * @param index
     */
    column(index) {
        let column = new Array();
        const ri = this.realColumnIndex(index);
        const rc = this.data.length;
        for (let i = 0; i < rc; i++) {
            const row = this.data[i];
            column.push(row[ri]);
        }
        return column;
    }
    /**
     * Adds a column to the `index`th column or appends to table if index not provided.
     *
     * If column is shorter than other columns or not provided, it will be padded with
     * empty `TableItem` elements.
     *
     * If column is longer than other columns, others will be extended to match so no data is lost.
     *
     * If called on an empty table with no parameters, it creates a 1x1 table.
     *
     * Negative index starts from the end. -1 being the last element.
     *
     * @param [column]
     * @param [index]
     */
    addColumn(column, index) {
        // if table empty create table with row
        if (!this.data || this.data.length === 0 || this.data[0].length === 0) {
            let newData = new Array();
            if (column == null) {
                newData.push([new TableItem()]);
            }
            else {
                for (let i = 0; i < column.length; i++) {
                    let item = column[i];
                    newData.push([item]);
                }
            }
            this.data = newData;
            return;
        }
        let rc = this.data.length; // row count
        let ci = this.realColumnIndex(index);
        // append missing rows
        for (let i = 0; column != null && i < column.length - rc; i++) {
            this.addRow();
        }
        rc = this.data.length;
        if (index == null) {
            // append to end
            for (let i = 0; i < rc; i++) {
                let row = this.data[i];
                row.push(column == null || column[i] == null ? new TableItem() : column[i]);
            }
            // update header if not already set by user
            if (this.header.length < this.data[0].length) {
                this.header.push(new TableHeaderItem());
            }
        }
        else {
            if (index >= this.data[0].length) {
                // if trying to append
                ci++;
            }
            // insert
            for (let i = 0; i < rc; i++) {
                let row = this.data[i];
                row.splice(ci, 0, column == null || column[i] == null ? new TableItem() : column[i]);
            }
            // update header if not already set by user
            if (this.header.length < this.data[0].length) {
                this.header.splice(ci, 0, new TableHeaderItem());
            }
        }
        this.dataChange.emit();
    }
    /**
     * Deletes `index`th column.
     *
     * Negative index starts from the end. -1 being the last element.
     *
     * @param index
     */
    deleteColumn(index) {
        const rci = this.realColumnIndex(index);
        const rowCount = this.data.length;
        for (let i = 0; i < rowCount; i++) {
            this.data[i].splice(rci, 1);
        }
        // update header if not already set by user
        if (this.header.length > this.data[0].length) {
            this.header.splice(rci, 1);
        }
        this.dataChange.emit();
    }
    moveColumn(indexFrom, indexTo) {
        const headerFrom = this.header[indexFrom];
        this.addColumn(this.column(indexFrom), indexTo);
        this.deleteColumn(indexFrom + (indexTo < indexFrom ? 1 : 0));
        this.header[indexTo + (indexTo > indexFrom ? -1 : 0)] = headerFrom;
    }
    /**
     * cycle through the three sort states
     * @param index
     */
    cycleSortState(index) {
        // no sort provided so do the simple sort
        switch (this.header[index].sortDirection) {
            case "ASCENDING":
                this.header[index].sortDirection = "DESCENDING";
                break;
            case "DESCENDING":
                this.header[index].sortDirection = "NONE";
                break;
            default:
                this.header[index].sortDirection = "ASCENDING";
                break;
        }
    }
    /**
     * Sorts the data currently present in the model based on `compare()`
     *
     * Direction is set by `ascending` and `descending` properties of `TableHeaderItem`
     * in `index`th column.
     *
     * @param index The column based on which it's sorting
     */
    sort(index) {
        this.pushRowStateToModelData();
        const headerSorted = this.header[index].sorted;
        // We only allow sorting by a single column, so reset sort state for all columns before specifying new sort state
        this.header.forEach(column => column.sorted = false);
        if (this.header[index].sortDirection === "NONE" && headerSorted) {
            // Restore initial order of rows
            const oldData = this._data;
            this._data = [];
            for (let i = 0; i < this.rowsIndices.length; i++) {
                const ri = this.rowsIndices[i];
                this._data[ri] = oldData[i];
            }
        }
        else {
            const descending = this.header[index].sortDirection === "DESCENDING" ? -1 : 1;
            this.data.sort((a, b) => {
                return descending * this.header[index].compare(a[index], b[index]);
            });
            this.header[index].sorted = true;
        }
        this.popRowStateFromModelData();
    }
    /**
     * Appends `rowsSelected` and `rowsExpanded` info to model data.
     *
     * When sorting rows, do this first so information about row selection
     * gets sorted with the other row info.
     *
     * Call `popRowSelectionFromModelData()` after sorting to make everything
     * right with the world again.
     */
    pushRowStateToModelData() {
        for (let i = 0; i < this.data.length; i++) {
            const rowSelectedMark = new TableItem();
            rowSelectedMark.data = this.rowsSelected[i];
            this.data[i].push(rowSelectedMark);
            const rowExpandedMark = new TableItem();
            rowExpandedMark.data = this.rowsExpanded[i];
            this.data[i].push(rowExpandedMark);
            const rowContext = new TableItem();
            rowContext.data = this.rowsContext[i];
            this.data[i].push(rowContext);
            const rowClass = new TableItem();
            rowClass.data = this.rowsClass[i];
            this.data[i].push(rowClass);
            const rowIndex = new TableItem();
            rowIndex.data = this.rowsIndices[i];
            this.data[i].push(rowIndex);
        }
    }
    /**
     * Restores `rowsSelected` from data pushed by `pushRowSelectionToModelData()`
     *
     * Call after sorting data (if you previously pushed to maintain selection order)
     * to make everything right with the world again.
     */
    popRowStateFromModelData() {
        for (let i = 0; i < this.data.length; i++) {
            this.rowsIndices[i] = this.data[i].pop().data;
            this.rowsClass[i] = this.data[i].pop().data;
            this.rowsContext[i] = this.data[i].pop().data;
            this.rowsExpanded[i] = !!this.data[i].pop().data;
            this.rowsSelected[i] = !!this.data[i].pop().data;
        }
    }
    /**
     * Checks if row is filtered out.
     *
     * @param index
     * @returns true if any of the filters in header filters out the `index`th row
     */
    isRowFiltered(index) {
        const realIndex = this.realRowIndex(index);
        return this.header.some((item, i) => item && item.filter(this.row(realIndex)[i]));
    }
    /**
     * Select/deselect `index`th row based on value
     *
     * @param index index of the row to select
     * @param value state to set the row to. Defaults to `true`
     */
    selectRow(index, value = true) {
        if (this.isRowDisabled(index)) {
            return;
        }
        this.rowsSelected[index] = value;
        this.rowsSelectedChange.emit(index);
    }
    /**
     * Selects or deselects all rows in the model
     *
     * @param value state to set all rows to. Defaults to `true`
     */
    selectAll(value = true) {
        if (this.data.length >= 1 && this.data[0].length >= 1) {
            for (let i = 0; i < this.rowsSelected.length; i++) {
                this.selectRow(i, value);
            }
        }
        this.selectAllChange.next(value);
    }
    isRowSelected(index) {
        return this.rowsSelected[index];
    }
    /**
     * Checks if row is disabled or not.
     */
    isRowDisabled(index) {
        const row = this.data[index];
        return !!row.disabled;
    }
    /**
     * Expands/Collapses `index`th row based on value
     *
     * @param index index of the row to expand or collapse
     * @param value expanded state of the row. `true` is expanded and `false` is collapsed
     */
    expandRow(index, value = true) {
        this.rowsExpanded[index] = value;
        this.rowsExpandedChange.emit(index);
    }
    /**
     * Expands / collapses all rows
     *
     * @param value expanded state of the rows. `true` is expanded and `false` is collapsed
     */
    expandAllRows(value = true) {
        if (this.data.length > 0) {
            for (let i = 0; i < this.data.length; i++) {
                if (this.isRowExpandable(i)) {
                    this.rowsExpanded[i] = value;
                }
            }
            if (value) {
                this.rowsExpandedAllChange.emit();
            }
            else {
                this.rowsCollapsedAllChange.emit();
            }
        }
    }
    /**
     * Gets the true index of a row based on it's relative position.
     * Like in Python, positive numbers start from the top and
     * negative numbers start from the bottom.
     *
     * @param index
     */
    realRowIndex(index) {
        return this.realIndex(index, this.data.length);
    }
    /**
     * Gets the true index of a column based on it's relative position.
     * Like in Python, positive numbers start from the top and
     * negative numbers start from the bottom.
     *
     * @param index
     */
    realColumnIndex(index) {
        return this.realIndex(index, this.data[0].length);
    }
    /**
     * Generic function to calculate the real index of something.
     * Used by `realRowIndex()` and `realColumnIndex()`
     *
     * @param index
     * @param length
     */
    realIndex(index, length) {
        if (index == null) {
            return length - 1;
        }
        else if (index >= 0) {
            return index >= length ? length - 1 : index;
        }
        else {
            return -index >= length ? 0 : length + index;
        }
    }
}
/**
 * The number of models instantiated, used for (among other things) unique id generation
 */
TableModel.COUNT = 0;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFibGUtbW9kZWwuY2xhc3MuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvdGFibGUvdGFibGUtbW9kZWwuY2xhc3MudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUc3QyxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFDNUQsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBRS9DLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFJL0I7Ozs7Ozs7Ozs7Ozs7Ozs7R0FnQkc7QUFDSCxNQUFNLE9BQU8sVUFBVTtJQXdLdEI7UUEvSEEsZUFBVSxHQUFHLElBQUksWUFBWSxFQUFFLENBQUM7UUFDaEMsdUJBQWtCLEdBQUcsSUFBSSxZQUFZLEVBQVUsQ0FBQztRQUNoRCx1QkFBa0IsR0FBRyxJQUFJLFlBQVksRUFBVSxDQUFDO1FBQ2hELDBCQUFxQixHQUFHLElBQUksWUFBWSxFQUFFLENBQUM7UUFDM0MsMkJBQXNCLEdBQUcsSUFBSSxZQUFZLEVBQUUsQ0FBQztRQUM1Qzs7O1dBR0c7UUFDSCxvQkFBZSxHQUFHLElBQUksT0FBTyxFQUFXLENBQUM7UUFZekM7O1dBRUc7UUFDSCxpQkFBWSxHQUFjLEVBQUUsQ0FBQztRQUU3Qjs7V0FFRztRQUNILGlCQUFZLEdBQWMsRUFBRSxDQUFDO1FBRTdCOztXQUVHO1FBQ0gsZ0JBQVcsR0FBYSxFQUFFLENBQUM7UUFFM0I7Ozs7Ozs7V0FPRztRQUNILGdCQUFXLEdBQWEsRUFBRSxDQUFDO1FBRTNCOzs7Ozs7V0FNRztRQUNILGNBQVMsR0FBYSxFQUFFLENBQUM7UUFFekI7O1dBRUc7UUFDSCxXQUFNLEdBQXNCLEVBQUUsQ0FBQztRQUUvQjs7V0FFRztRQUNILGdCQUFXLEdBQUcsQ0FBQyxDQUFDO1FBRWhCOztXQUVHO1FBQ0gsZUFBVSxHQUFHLEVBQUUs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O0lBQ25ELENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDTyxTQUFTLENBQUMsS0FBYSxFQUFFLE1BQWM7UUFDaEQsSUFBSSxLQUFLLElBQUksSUFBSSxFQUFFO1lBQ2xCLE9BQU8sTUFBTSxHQUFHLENBQUMsQ0FBQztTQUNsQjthQUFNLElBQUksS0FBSyxJQUFJLENBQUMsRUFBRTtZQUN0QixPQUFPLEtBQUssSUFBSSxNQUFNLENBQUMsQ0FBQyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQztTQUM1QzthQUFNO1lBQ04sT0FBTyxDQUFDLEtBQUssSUFBSSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQztTQUM3QztJQUNGLENBQUM7O0FBdHZCRDs7R0FFRztBQUNjLGdCQUFLLEdBQUcsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcblxuaW1wb3J0IHsgUGFnaW5hdGlvbk1vZGVsIH0gZnJvbSBcImNhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvcGFnaW5hdGlvblwiO1xuaW1wb3J0IHsgVGFibGVIZWFkZXJJdGVtIH0gZnJvbSBcIi4vdGFibGUtaGVhZGVyLWl0ZW0uY2xhc3NcIjtcbmltcG9ydCB7IFRhYmxlSXRlbSB9IGZyb20gXCIuL3RhYmxlLWl0ZW0uY2xhc3NcIjtcbmltcG9ydCB7IFRhYmxlUm93IH0gZnJvbSBcIi4vdGFibGUtcm93LmNsYXNzXCI7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSBcInJ4anNcIjtcblxuZXhwb3J0IHR5cGUgSGVhZGVyVHlwZSA9IG51bWJlciB8IFwic2VsZWN0XCIgfCBcImV4cGFuZFwiO1xuXG4vKipcbiAqIFRhYmxlTW9kZWwgcmVwcmVzZW50cyBhIGRhdGEgbW9kZWwgZm9yIHR3by1kaW1lbnNpb25hbCBkYXRhLiBJdCdzIHVzZWQgZm9yIGFsbCB0aGluZ3MgdGFibGVcbiAqICh0YWJsZSBjb21wb25lbnQsIHRhYmxlIHRvb2xiYXIsIHBhZ2luYXRpb24sIGV0YylcbiAqXG4gKiBUYWJsZU1vZGVsIG1hbmFnZXMgaXRzIGludGVybmFsIGRhdGEgaW50ZWdyaXR5IHZlcnkgd2VsbCBpZiB5b3UgdXNlIHRoZSBwcm92aWRlZCBoZWxwZXJcbiAqIGZ1bmN0aW9ucyBmb3IgbW9kaWZ5aW5nIHJvd3MgYW5kIGNvbHVtbnMgYW5kIGFzc2lnbmluZyBoZWFkZXIgYW5kIGRhdGEgaW4gdGhhdCBvcmRlci5cbiAqXG4gKiBJdCBhbHNvIHByb3ZpZGVzIGRpcmVjdCBhY2Nlc3MgdG8gdGhlIGRhdGEgc28geW91IGNhbiByZWFkIGFuZCBtb2RpZnkgaXQuXG4gKiBJZiB5b3UgY2hhbmdlIHRoZSBzdHJ1Y3R1cmUgb2YgdGhlIGRhdGEgKGJ5IGRpcmVjdGx5IHB1c2hpbmcgaW50byB0aGUgYXJyYXlzIG9yIG90aGVyd2lzZSksXG4gKiBrZWVwIGluIG1pbmQgdG8ga2VlcCB0aGUgZGF0YSBzdHJ1Y3R1cmUgaW50YWN0LlxuICpcbiAqIEhlYWRlciBsZW5ndGggYW5kIGxlbmd0aCBvZiBldmVyeSBsaW5lIGluIHRoZSBkYXRhIHNob3VsZCBiZSBlcXVhbC5cbiAqXG4gKiBJZiB0aGV5IGFyZSBub3QgY29uc2lzdGVudCwgdW5leHBlY3RlZCB0aGluZ3Mgd2lsbCBoYXBwZW4uXG4gKlxuICogVXNlIHRoZSBwcm92aWRlZCBmdW5jdGlvbnMgd2hlbiBpbiBkb3VidC5cbiAqL1xuZXhwb3J0IGNsYXNzIFRhYmxlTW9kZWwgaW1wbGVtZW50cyBQYWdpbmF0aW9uTW9kZWwge1xuXHQvKipcblx0ICogVGhlIG51bWJlciBvZiBtb2RlbHMgaW5zdGFudGlhdGVkLCB1c2VkIGZvciAoYW1vbmcgb3RoZXIgdGhpbmdzKSB1bmlxdWUgaWQgZ2VuZXJhdGlvblxuXHQgKi9cblx0cHJvdGVjdGVkIHN0YXRpYyBDT1VOVCA9IDA7XG5cblx0LyoqXG5cdCAqIFNldHMgZGF0YSBvZiB0aGUgdGFibGUuXG5cdCAqXG5cdCAqIE1ha2Ugc3VyZSBhbGwgcm93cyBhcmUgdGhlIHNhbWUgbGVuZ3RoIHRvIGtlZXAgdGhlIGNvbHVtbiBjb3VudCBhY2N1cmF0ZS5cblx0ICovXG5cdHNldCBkYXRhKG5ld0RhdGE6IFRhYmxlSXRlbVtdW10pIHtcblx0XHRpZiAoIW5ld0RhdGEgfHwgKEFycmF5LmlzQXJyYXkobmV3RGF0YSkgJiYgbmV3RGF0YS5sZW5ndGggPT09IDApKSB7XG5cdFx0XHRuZXdEYXRhID0gW1tdXTtcblx0XHR9XG5cblx0XHR0aGlzLl9kYXRhID0gbmV3RGF0YTtcblxuXHRcdC8vIGluaXQgcm93c1NlbGVjdGVkXG5cdFx0dGhpcy5yb3dzU2VsZWN0ZWQgPSBuZXcgQXJyYXk8Ym9vbGVhbj4odGhpcy5fZGF0YS5sZW5ndGgpLmZpbGwoZmFsc2UpO1xuXHRcdHRoaXMucm93c0V4cGFuZGVkID0gbmV3IEFycmF5PGJvb2xlYW4+KHRoaXMuX2RhdGEubGVuZ3RoKS5maWxsKGZhbHNlKTtcblx0XHQvLyBpbml0IHJvd3MgaW5kaWNlc1xuXHRcdHRoaXMucm93c0luZGljZXMgPSBbLi4uQXJyYXkodGhpcy5fZGF0YS5sZW5ndGgpLmtleXMoKV07XG5cdFx0Ly8gaW5pdCByb3dzQ29udGV4dFxuXHRcdHRoaXMucm93c0NvbnRleHQgPSBuZXcgQXJyYXk8c3RyaW5nPih0aGlzLl9kYXRhLmxlbmd0aCk7XG5cblx0XHQvLyBpbml0IHJvd3NDbGFzc1xuXHRcdHRoaXMucm93c0NsYXNzID0gbmV3IEFycmF5PHN0cmluZz4odGhpcy5fZGF0YS5sZW5ndGgpO1xuXG5cdFx0Ly8gb25seSBjcmVhdGUgYSBmcmVzaCBoZWFkZXIgaWYgbmVjZXNzYXJ5IChoZWFkZXIgZG9lc24ndCBleGlzdCBvciBkaWZmZXJzIGluIGxlbmd0aClcblx0XHRpZiAodGhpcy5oZWFkZXIgPT0gbnVsbCB8fCAodGhpcy5oZWFkZXIubGVuZ3RoICE9PSB0aGlzLl9kYXRhWzBdLmxlbmd0aCAmJiB0aGlzLl9kYXRhWzBdLmxlbmd0aCA+IDApKSB7XG5cdFx0XHRsZXQgaGVhZGVyID0gbmV3IEFycmF5PFRhYmxlSGVhZGVySXRlbT4oKTtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fZGF0YVswXS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRoZWFkZXIucHVzaChuZXcgVGFibGVIZWFkZXJJdGVtKCkpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5oZWFkZXIgPSBoZWFkZXI7XG5cdFx0fVxuXG5cdFx0dGhpcy5kYXRhQ2hhbmdlLmVtaXQoKTtcblx0fVxuXG5cdGRhdGFDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cdHJvd3NTZWxlY3RlZENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPigpO1xuXHRyb3dzRXhwYW5kZWRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPG51bWJlcj4oKTtcblx0cm93c0V4cGFuZGVkQWxsQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXHRyb3dzQ29sbGFwc2VkQWxsQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXHQvKipcblx0ICogR2V0cyBlbWl0dGVkIHdoZW4gYHNlbGVjdEFsbGAgaXMgY2FsbGVkLiBFbWl0cyBmYWxzZSBpZiBhbGwgcm93cyBhcmUgZGVzZWxlY3RlZCBhbmQgdHJ1ZSBpZlxuXHQgKiBhbGwgcm93cyBhcmUgc2VsZWN0ZWQuXG5cdCAqL1xuXHRzZWxlY3RBbGxDaGFuZ2UgPSBuZXcgU3ViamVjdDxib29sZWFuPigpO1xuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBmdWxsIGRhdGEuXG5cdCAqXG5cdCAqIFlvdSBjYW4gdXNlIGl0IHRvIGFsdGVyIGluZGl2aWR1YWwgYFRhYmxlSXRlbWBzIGJ1dCBpZiB5b3UgbmVlZCB0byBjaGFuZ2Vcblx0ICogdGFibGUgc3RydWN0dXJlLCB1c2UgYGFkZFJvdygpYCBhbmQvb3IgYGFkZENvbHVtbigpYFxuXHQgKi9cblx0Z2V0IGRhdGEoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RhdGE7XG5cdH1cblxuXHQvKipcblx0ICogQ29udGFpbnMgaW5mb3JtYXRpb24gYWJvdXQgc2VsZWN0aW9uIHN0YXRlIG9mIHJvd3MgaW4gdGhlIHRhYmxlLlxuXHQgKi9cblx0cm93c1NlbGVjdGVkOiBib29sZWFuW10gPSBbXTtcblxuXHQvKipcblx0ICogQ29udGFpbnMgaW5mb3JtYXRpb24gYWJvdXQgZXhwYW5kZWQgc3RhdGUgb2Ygcm93cyBpbiB0aGUgdGFibGUuXG5cdCAqL1xuXHRyb3dzRXhwYW5kZWQ6IGJvb2xlYW5bXSA9IFtdO1xuXG5cdC8qKlxuXHQgKiBDb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCBpbml0aWFsIGluZGV4IG9mIHJvd3MgaW4gdGhlIHRhYmxlXG5cdCAqL1xuXHRyb3dzSW5kaWNlczogbnVtYmVyW10gPSBbXTtcblxuXHQvKipcblx0ICogQ29udGFpbnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGNvbnRleHQgb2YgdGhlIHJvdy5cblx0ICpcblx0ICogSXQgYWZmZWN0cyBzdHlsaW5nIG9mIHRoZSByb3cgdG8gcmVmbGVjdCB0aGUgY29udGV4dC5cblx0ICpcblx0ICogc3RyaW5nIGNhbiBiZSBvbmUgb2YgYFwic3VjY2Vzc1wiIHwgXCJ3YXJuaW5nXCIgfCBcImluZm9cIiB8IFwiZXJyb3JcIiB8IFwiXCJgIGFuZCBpdCdzXG5cdCAqIGVtcHR5IG9yIHVuZGVmaW5lZCBieSBkZWZhdWx0XG5cdCAqL1xuXHRyb3dzQ29udGV4dDogc3RyaW5nW10gPSBbXTtcblxuXHQvKipcblx0ICogQ29udGFpbnMgY2xhc3MgbmFtZShzKSBvZiB0aGUgcm93LlxuXHQgKlxuXHQgKiBJdCBhZmZlY3RzIHN0eWxpbmcgb2YgdGhlIHJvdyB0byByZWZsZWN0IHRoZSBhcHBlbmRlZCBjbGFzcyBuYW1lKHMpLlxuXHQgKlxuXHQgKiBJdCdzIGVtcHR5IG9yIHVuZGVmaW5lZCBieSBkZWZhdWx0XG5cdCAqL1xuXHRyb3dzQ2xhc3M6IHN0cmluZ1tdID0gW107XG5cblx0LyoqXG5cdCAqIENvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IHRoZSBoZWFkZXIgY2VsbHMgb2YgdGhlIHRhYmxlLlxuXHQgKi9cblx0aGVhZGVyOiBUYWJsZUhlYWRlckl0ZW1bXSA9IFtdO1xuXG5cdC8qKlxuXHQgKiBUcmFja3MgdGhlIGN1cnJlbnQgcGFnZS5cblx0ICovXG5cdGN1cnJlbnRQYWdlID0gMTtcblxuXHQvKipcblx0ICogTGVuZ3RoIG9mIHBhZ2UuXG5cdCAqL1xuXHRwYWdlTGVuZ3RoID0gMTA7XG5cblx0LyoqXG5cdCAqIFNldCB0byB0cnVlIHdoZW4gdGhlcmUgaXMgbm8gbW9yZSBkYXRhIHRvIGxvYWQgaW4gdGhlIHRhYmxlXG5cdCAqL1xuXHRpc0VuZCA9IGZhbHNlO1xuXG5cdC8qKlxuXHQgKiBTZXQgdG8gdHJ1ZSB3aGVuIGxhenkgbG9hZGluZyB0byBzaG93IGxvYWRpbmcgaW5kaWNhdG9yXG5cdCAqL1xuXHRpc0xvYWRpbmcgPSBmYWxzZTtcblxuXHQvKipcblx0ICogQWJzb2x1dGUgdG90YWwgbnVtYmVyIG9mIHJvd3Mgb2YgdGhlIHRhYmxlLlxuXHQgKi9cblx0cHJvdGVjdGVkIF90b3RhbERhdGFMZW5ndGg6IG51bWJlcjtcblxuXHQvKipcblx0ICogTWFudWFsbHkgc2V0IGRhdGEgbGVuZ3RoIGluIGNhc2UgdGhlIGRhdGEgaW4gdGhlIHRhYmxlIGRvZXNuJ3Rcblx0ICogY29ycmVjdGx5IHJlZmxlY3QgYWxsIHRoZSBkYXRhIHRoYXQgdGFibGUgaXMgdG8gZGlzcGxheS5cblx0ICpcblx0ICogRXhhbXBsZTogaWYgeW91IGhhdmUgbXVsdGlwbGUgcGFnZXMgb2YgZGF0YSB0aGF0IHRhYmxlIHdpbGwgZGlzcGxheVxuXHQgKiBidXQgeW91J3JlIGxvYWRpbmcgb25lIGF0IGEgdGltZS5cblx0ICpcblx0ICogU2V0IHRvIGBudWxsYCB0byByZXNldCB0byBkZWZhdWx0IGJlaGF2aW9yLlxuXHQgKi9cblx0c2V0IHRvdGFsRGF0YUxlbmd0aChsZW5ndGg6IG51bWJlcikge1xuXHRcdC8vIGlmIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGhvdXQgYSBwYXJhbWV0ZXIgd2UgbmVlZCB0byBzZXQgdG8gbnVsbCB0byBhdm9pZCBoYXZpbmcgdW5kZWZpbmVkICE9IG51bGxcblx0XHR0aGlzLl90b3RhbERhdGFMZW5ndGggPSBpc05hTihsZW5ndGgpID8gbnVsbCA6IGxlbmd0aDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUb3RhbCBsZW5ndGggb2YgZGF0YSB0aGF0IHRhYmxlIGhhcyBhY2Nlc3MgdG8sIG9yIHRoZSBhbW91bnQgbWFudWFsbHkgc2V0XG5cdCAqL1xuXHRnZXQgdG90YWxEYXRhTGVuZ3RoKCkge1xuXHRcdC8vIGlmIG1hbnVhbGx5IHNldCBkYXRhIGxlbmd0aFxuXHRcdGlmICh0aGlzLl90b3RhbERhdGFMZW5ndGggIT09IG51bGwgJiYgdGhpcy5fdG90YWxEYXRhTGVuZ3RoID49IDApIHtcblx0XHRcdHJldHVybiB0aGlzLl90b3RhbERhdGFMZW5ndGg7XG5cdFx0fVxuXG5cdFx0Ly8gaWYgZW1wdHkgZGF0YXNldFxuXHRcdGlmICh0aGlzLmRhdGEgJiYgdGhpcy5kYXRhLmxlbmd0aCA9PT0gMSAmJiB0aGlzLmRhdGFbMF0ubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5kYXRhLmxlbmd0aDtcblx0fVxuXG5cdC8qKlxuXHQgKiBVc2VkIGluIGBkYXRhYFxuXHQgKi9cblx0cHJvdGVjdGVkIF9kYXRhOiBUYWJsZUl0ZW1bXVtdID0gW1tdXTtcblxuXHQvKipcblx0ICogVGhlIG51bWJlciBvZiBtb2RlbHMgaW5zdGFudGlhdGVkLCB0aGlzIGlzIHRvIG1ha2Ugc3VyZSBlYWNoIHRhYmxlIGhhcyBhIGRpZmZlcmVudFxuXHQgKiBtb2RlbCBjb3VudCBmb3IgdW5pcXVlIGlkIGdlbmVyYXRpb24uXG5cdCAqL1xuXHRwcm90ZWN0ZWQgdGFibGVNb2RlbENvdW50ID0gMDtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHR0aGlzLnRhYmxlTW9kZWxDb3VudCA9IFRhYmxlTW9kZWwuQ09VTlQrKztcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGFuIGlkIGZvciB0aGUgZ2l2ZW4gY29sdW1uXG5cdCAqXG5cdCAqIEBwYXJhbSBjb2x1bW4gdGhlIGNvbHVtbiB0byBnZW5lcmF0ZSBhbiBpZCBmb3Jcblx0ICogQHBhcmFtIHJvdyB0aGUgcm93IG9mIHRoZSBoZWFkZXIgdG8gZ2VuZXJhdGUgYW4gaWQgZm9yXG5cdCAqL1xuXHRnZXRJZChjb2x1bW46IEhlYWRlclR5cGUsIHJvdyA9IDApOiBzdHJpbmcge1xuXHRcdHJldHVybiBgdGFibGUtaGVhZGVyLSR7cm93fS0ke2NvbHVtbn0tJHt0aGlzLnRhYmxlTW9kZWxDb3VudH1gO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGlkIG9mIHRoZSBoZWFkZXIuIFVzZWQgdG8gbGluayB0aGUgY2VsbHMgd2l0aCBoZWFkZXJzIChvciBoZWFkZXJzIHdpdGggaGVhZGVycylcblx0ICpcblx0ICogQHBhcmFtIGNvbHVtbiB0aGUgY29sdW1uIHRvIHN0YXJ0IGdldHRpbmcgaGVhZGVycyBmb3Jcblx0ICogQHBhcmFtIGNvbFNwYW4gdGhlIG51bWJlciBvZiBjb2x1bW5zIHRvIGdldCBoZWFkZXJzIGZvciAoZGVmYXVsdHMgdG8gMSlcblx0ICovXG5cdGdldEhlYWRlcklkKGNvbHVtbjogSGVhZGVyVHlwZSwgY29sU3BhbiA9IDEpOiBzdHJpbmcge1xuXHRcdGlmIChjb2x1bW4gPT09IFwic2VsZWN0XCIgfHwgY29sdW1uID09PSBcImV4cGFuZFwiKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRJZChjb2x1bW4pO1xuXHRcdH1cblxuXHRcdGxldCBpZHMgPSBbXTtcblx0XHRmb3IgKGxldCBpID0gY29sdW1uOyBpID49IDA7IGktLSkge1xuXHRcdFx0aWYgKHRoaXMuaGVhZGVyW2ldKSB7XG5cdFx0XHRcdGZvciAobGV0IGogPSAwOyBqIDwgY29sU3BhbjsgaisrKSB7XG5cdFx0XHRcdFx0aWRzLnB1c2godGhpcy5nZXRJZChpICsgaikpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBpZHMuam9pbihcIiBcIik7XG5cdH1cblxuXHQvKipcblx0ICogRmluZHMgY2xvc2VzdCBoZWFkZXIgYnkgdHJ5aW5nIHRoZSBgY29sdW1uYCBhbmQgdGhlbiB3b3JraW5nIGl0cyB3YXkgdG8gdGhlIGxlZnRcblx0ICpcblx0ICogQHBhcmFtIGNvbHVtbiB0aGUgdGFyZ2V0IGNvbHVtblxuXHQgKi9cblx0Z2V0SGVhZGVyKGNvbHVtbjogbnVtYmVyKTogVGFibGVIZWFkZXJJdGVtIHtcblx0XHRpZiAoIXRoaXMuaGVhZGVyKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHRmb3IgKGxldCBpID0gY29sdW1uOyBpID49IDA7IGktLSkge1xuXHRcdFx0Y29uc3QgaGVhZGVyQ2VsbCA9IHRoaXMuaGVhZGVyW2ldO1xuXHRcdFx0aWYgKGhlYWRlckNlbGwpIHtcblx0XHRcdFx0cmV0dXJuIGhlYWRlckNlbGw7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBob3cgbWFueSByb3dzIGlzIGN1cnJlbnRseSBzZWxlY3RlZFxuXHQgKi9cblx0c2VsZWN0ZWRSb3dzQ291bnQoKTogbnVtYmVyIHtcblx0XHRsZXQgY291bnQgPSAwO1xuXHRcdGlmICh0aGlzLnJvd3NTZWxlY3RlZCkge1xuXHRcdFx0dGhpcy5yb3dzU2VsZWN0ZWQuZm9yRWFjaChyb3dTZWxlY3RlZCA9PiB7XG5cdFx0XHRcdGlmIChyb3dTZWxlY3RlZCkge1xuXHRcdFx0XHRcdGNvdW50Kys7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0XHRyZXR1cm4gY291bnQ7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBob3cgbWFueSByb3dzIGlzIGN1cnJlbnRseSBleHBhbmRlZFxuXHQgKi9cblx0ZXhwYW5kZWRSb3dzQ291bnQoKTogbnVtYmVyIHtcblx0XHRsZXQgY291bnQgPSAwO1xuXHRcdGlmICh0aGlzLnJvd3NFeHBhbmRlZCkge1xuXHRcdFx0dGhpcy5yb3dzRXhwYW5kZWQuZm9yRWFjaChyb3dFeHBhbmRlZCA9PiB7XG5cdFx0XHRcdGlmIChyb3dFeHBhbmRlZCkge1xuXHRcdFx0XHRcdGNvdW50Kys7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0XHRyZXR1cm4gY291bnQ7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBgaW5kZXhgdGggcm93IG9mIHRoZSB0YWJsZS5cblx0ICpcblx0ICogTmVnYXRpdmUgaW5kZXggc3RhcnRzIGZyb20gdGhlIGVuZC4gLTEgYmVpbmcgdGhlIGxhc3QgZWxlbWVudC5cblx0ICpcblx0ICogQHBhcmFtIGluZGV4XG5cdCAqL1xuXHRyb3coaW5kZXg6IG51bWJlcik6IFRhYmxlSXRlbVtdIHtcblx0XHRyZXR1cm4gdGhpcy5kYXRhW3RoaXMucmVhbFJvd0luZGV4KGluZGV4KV07XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIHJvdyB0byB0aGUgYGluZGV4YHRoIHJvdyBvciBhcHBlbmRzIHRvIHRhYmxlIGlmIGluZGV4IG5vdCBwcm92aWRlZC5cblx0ICpcblx0ICogSWYgcm93IGlzIHNob3J0ZXIgdGhhbiBvdGhlciByb3dzIG9yIG5vdCBwcm92aWRlZCwgaXQgd2lsbCBiZSBwYWRkZWQgd2l0aFxuXHQgKiBlbXB0eSBgVGFibGVJdGVtYCBlbGVtZW50cy5cblx0ICpcblx0ICogSWYgcm93IGlzIGxvbmdlciB0aGFuIG90aGVyIHJvd3MsIG90aGVycyB3aWxsIGJlIGV4dGVuZGVkIHRvIG1hdGNoIHNvIG5vIGRhdGEgaXMgbG9zdC5cblx0ICpcblx0ICogSWYgY2FsbGVkIG9uIGFuIGVtcHR5IHRhYmxlIHdpdGggbm8gcGFyYW1ldGVycywgaXQgY3JlYXRlcyBhIDF4MSB0YWJsZS5cblx0ICpcblx0ICogTmVnYXRpdmUgaW5kZXggc3RhcnRzIGZyb20gdGhlIGVuZC4gLTEgYmVpbmcgdGhlIGxhc3QgZWxlbWVudC5cblx0ICpcblx0ICogQHBhcmFtIFtyb3ddXG5cdCAqIEBwYXJhbSBbaW5kZXhdXG5cdCAqL1xuXHRhZGRSb3cocm93PzogVGFibGVJdGVtW10sIGluZGV4PzogbnVtYmVyKSB7XG5cdFx0Ly8gaWYgdGFibGUgZW1wdHkgY3JlYXRlIHRhYmxlIHdpdGggcm93XG5cdFx0aWYgKCF0aGlzLmRhdGEgfHwgdGhpcy5kYXRhLmxlbmd0aCA9PT0gMCB8fCB0aGlzLmRhdGFbMF0ubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRsZXQgbmV3RGF0YSA9IG5ldyBBcnJheTxBcnJheTxUYWJsZUl0ZW0+PigpO1xuXHRcdFx0bmV3RGF0YS5wdXNoKHJvdyA/IHJvdyA6IFtuZXcgVGFibGVJdGVtKCldKTsgIC8vIHJvdyBvciBvbmUgZW1wdHkgb25lIGNvbHVtbiByb3dcblx0XHRcdHRoaXMuZGF0YSA9IG5ld0RhdGE7XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRsZXQgcmVhbFJvdyA9IHJvdztcblx0XHRjb25zdCBjb2x1bW5Db3VudCA9IHRoaXMuZGF0YVswXS5sZW5ndGg7XG5cblx0XHRpZiAocm93ID09IG51bGwpIHtcblx0XHRcdHJlYWxSb3cgPSBuZXcgQXJyYXk8VGFibGVJdGVtPigpO1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjb2x1bW5Db3VudDsgaSsrKSB7XG5cdFx0XHRcdHJlYWxSb3cucHVzaChuZXcgVGFibGVJdGVtKCkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChyZWFsUm93Lmxlbmd0aCA8IGNvbHVtbkNvdW50KSB7XG5cdFx0XHQvLyBleHRlbmQgdGhlIGxlbmd0aCBvZiByZWFsUm93XG5cdFx0XHRjb25zdCBkaWZmZXJlbmNlID0gY29sdW1uQ291bnQgLSByZWFsUm93Lmxlbmd0aDtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgZGlmZmVyZW5jZTsgaSsrKSB7XG5cdFx0XHRcdHJlYWxSb3cucHVzaChuZXcgVGFibGVJdGVtKCkpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAocmVhbFJvdy5sZW5ndGggPiBjb2x1bW5Db3VudCkge1xuXHRcdFx0Ly8gZXh0ZW5kIHRoZSBsZW5ndGggb2YgaGVhZGVyXG5cdFx0XHRsZXQgZGlmZmVyZW5jZSA9IHJlYWxSb3cubGVuZ3RoIC0gdGhpcy5oZWFkZXIubGVuZ3RoO1xuXHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPCBkaWZmZXJlbmNlOyBqKyspIHtcblx0XHRcdFx0dGhpcy5oZWFkZXIucHVzaChuZXcgVGFibGVIZWFkZXJJdGVtKCkpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gZXh0ZW5kIHRoZSBsZW5ndGggb2YgZXZlcnkgb3RoZXIgcm93XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRsZXQgY3VycmVudFJvdyA9IHRoaXMuZGF0YVtpXTtcblx0XHRcdFx0ZGlmZmVyZW5jZSA9IHJlYWxSb3cubGVuZ3RoIC0gY3VycmVudFJvdy5sZW5ndGg7XG5cdFx0XHRcdGZvciAobGV0IGogPSAwOyBqIDwgZGlmZmVyZW5jZTsgaisrKSB7XG5cdFx0XHRcdFx0Y3VycmVudFJvdy5wdXNoKG5ldyBUYWJsZUl0ZW0oKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoaW5kZXggPT0gbnVsbCkge1xuXHRcdFx0dGhpcy5kYXRhLnB1c2gocmVhbFJvdyk7XG5cblx0XHRcdC8vIHVwZGF0ZSByb3dzU2VsZWN0ZWQgcHJvcGVydHkgZm9yIGxlbmd0aFxuXHRcdFx0dGhpcy5yb3dzU2VsZWN0ZWQucHVzaChmYWxzZSk7XG5cblx0XHRcdC8vIHVwZGF0ZSByb3dzRXhwYW5kZWQgcHJvcGVydHkgZm9yIGxlbmd0aFxuXHRcdFx0dGhpcy5yb3dzRXhwYW5kZWQucHVzaChmYWxzZSk7XG5cblx0XHRcdC8vIHVwZGF0ZSByb3dzQ29udGV4dCBwcm9wZXJ0eSBmb3IgbGVuZ3RoXG5cdFx0XHR0aGlzLnJvd3NDb250ZXh0LnB1c2godW5kZWZpbmVkKTtcblxuXHRcdFx0Ly8gdXBkYXRlIHJvd3NDbGFzcyBwcm9wZXJ0eSBmb3IgbGVuZ3RoXG5cdFx0XHR0aGlzLnJvd3NDbGFzcy5wdXNoKHVuZGVmaW5lZCk7XG5cblx0XHRcdC8vIHVwZGF0ZSByb3dzSW5kaWNlcyBwcm9wZXJ0eSBmb3IgbGVuZ3RoXG5cdFx0XHR0aGlzLnJvd3NJbmRpY2VzLnB1c2godGhpcy5kYXRhLmxlbmd0aCAtIDEpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zdCByaSA9IHRoaXMucmVhbFJvd0luZGV4KGluZGV4KTtcblx0XHRcdHRoaXMuZGF0YS5zcGxpY2UocmksIDAsIHJlYWxSb3cpO1xuXG5cdFx0XHQvLyB1cGRhdGUgcm93c1NlbGVjdGVkIHByb3BlcnR5IGZvciBsZW5ndGhcblx0XHRcdHRoaXMucm93c1NlbGVjdGVkLnNwbGljZShyaSwgMCwgZmFsc2UpO1xuXG5cdFx0XHQvLyB1cGRhdGUgcm93c0V4cGFuZGVkIHByb3BlcnR5IGZvciBsZW5ndGhcblx0XHRcdHRoaXMucm93c0V4cGFuZGVkLnNwbGljZShyaSwgMCwgZmFsc2UpO1xuXG5cdFx0XHQvLyB1cGRhdGUgcm93c0NvbnRleHQgcHJvcGVydHkgZm9yIGxlbmd0aFxuXHRcdFx0dGhpcy5yb3dzQ29udGV4dC5zcGxpY2UocmksIDAsIHVuZGVmaW5lZCk7XG5cblx0XHRcdC8vIHVwZGF0ZSByb3dzQ2xhc3MgcHJvcGVydHkgZm9yIGxlbmd0aFxuXHRcdFx0dGhpcy5yb3dzQ2xhc3Muc3BsaWNlKHJpLCAwLCB1bmRlZmluZWQpO1xuXG5cdFx0XHQvLyB1cGRhdGUgcm93c0luZGljZXMgcHJvcGVydHkgZm9yIGxlbmd0aFxuXHRcdFx0dGhpcy5yb3dzSW5kaWNlcy5zcGxpY2UocmksIDAsIHRoaXMuZGF0YS5sZW5ndGggLSAxKTtcblx0XHR9XG5cblx0XHR0aGlzLmRhdGFDaGFuZ2UuZW1pdCgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIERlbGV0ZXMgYGluZGV4YHRoIHJvdy5cblx0ICpcblx0ICogTmVnYXRpdmUgaW5kZXggc3RhcnRzIGZyb20gdGhlIGVuZC4gLTEgYmVpbmcgdGhlIGxhc3QgZWxlbWVudC5cblx0ICpcblx0ICogQHBhcmFtIGluZGV4XG5cdCAqL1xuXHRkZWxldGVSb3coaW5kZXg6IG51bWJlcikge1xuXHRcdGNvbnN0IHJyaSA9IHRoaXMucmVhbFJvd0luZGV4KGluZGV4KTtcblx0XHR0aGlzLmRhdGEuc3BsaWNlKHJyaSwgMSk7XG5cdFx0dGhpcy5yb3dzU2VsZWN0ZWQuc3BsaWNlKHJyaSwgMSk7XG5cdFx0dGhpcy5yb3dzRXhwYW5kZWQuc3BsaWNlKHJyaSwgMSk7XG5cdFx0dGhpcy5yb3dzQ29udGV4dC5zcGxpY2UocnJpLCAxKTtcblx0XHR0aGlzLnJvd3NDbGFzcy5zcGxpY2UocnJpLCAxKTtcblxuXHRcdGNvbnN0IHJvd0luZGV4ID0gdGhpcy5yb3dzSW5kaWNlc1tycmldO1xuXHRcdHRoaXMucm93c0luZGljZXMuc3BsaWNlKHJyaSwgMSk7XG5cdFx0dGhpcy5yb3dzSW5kaWNlcyA9IHRoaXMucm93c0luZGljZXMubWFwKCh2YWx1ZSkgPT4gKHZhbHVlID4gcm93SW5kZXgpID8gLS12YWx1ZSA6IHZhbHVlKTtcblxuXHRcdHRoaXMuZGF0YUNoYW5nZS5lbWl0KCk7XG5cdH1cblxuXHQvKipcblx0ICogRGVsZXRlcyBhbGwgcm93cy5cblx0ICovXG5cdGRlbGV0ZUFsbFJvd3MoKSB7XG5cdFx0dGhpcy5kYXRhID0gW107XG5cdH1cblxuXHRoYXNFeHBhbmRhYmxlUm93cygpIHtcblx0XHRyZXR1cm4gdGhpcy5kYXRhLnNvbWUoZGF0YSA9PiBkYXRhLnNvbWUoZCA9PiBkICYmIGQuZXhwYW5kZWREYXRhKSk7IC8vIGNoZWNraW5nIGZvciBzb21lIGluIDJEIGFycmF5XG5cdH1cblxuXHQvKipcblx0ICogTnVtYmVyIG9mIHJvd3MgdGhhdCBjYW4gYmUgZXhwYW5kZWQuXG5cdCAqXG5cdCAqIEByZXR1cm5zIG51bWJlclxuXHQgKi9cblx0ZXhwYW5kYWJsZVJvd3NDb3VudCgpIHtcblx0XHRyZXR1cm4gdGhpcy5kYXRhLnJlZHVjZSgoY291bnRlciwgXywgaW5kZXgpID0+IHtcblx0XHRcdGNvdW50ZXIgPSAodGhpcy5pc1Jvd0V4cGFuZGFibGUoaW5kZXgpKSA/IGNvdW50ZXIgKyAxIDogY291bnRlcjtcblx0XHRcdHJldHVybiBjb3VudGVyO1xuXHRcdH0sIDApO1xuXHR9XG5cblx0aXNSb3dFeHBhbmRhYmxlKGluZGV4OiBudW1iZXIpIHtcblx0XHRyZXR1cm4gdGhpcy5kYXRhW2luZGV4XS5zb21lKGQgPT4gZCAmJiBkLmV4cGFuZGVkRGF0YSk7XG5cdH1cblxuXHRpc1Jvd0V4cGFuZGVkKGluZGV4OiBudW1iZXIpIHtcblx0XHRyZXR1cm4gdGhpcy5yb3dzRXhwYW5kZWRbaW5kZXhdO1xuXHR9XG5cblx0Z2V0Um93Q29udGV4dChpbmRleDogbnVtYmVyKSB7XG5cdFx0cmV0dXJuIHRoaXMucm93c0NvbnRleHRbaW5kZXhdO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYGluZGV4YHRoIGNvbHVtbiBvZiB0aGUgdGFibGUuXG5cdCAqXG5cdCAqIE5lZ2F0aXZlIGluZGV4IHN0YXJ0cyBmcm9tIHRoZSBlbmQuIC0xIGJlaW5nIHRoZSBsYXN0IGVsZW1lbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSBpbmRleFxuXHQgKi9cblx0Y29sdW1uKGluZGV4OiBudW1iZXIpOiBUYWJsZUl0ZW1bXSB7XG5cdFx0bGV0IGNvbHVtbiA9IG5ldyBBcnJheTxUYWJsZUl0ZW0+KCk7XG5cdFx0Y29uc3QgcmkgPSB0aGlzLnJlYWxDb2x1bW5JbmRleChpbmRleCk7XG5cdFx0Y29uc3QgcmMgPSB0aGlzLmRhdGEubGVuZ3RoO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCByYzsgaSsrKSB7XG5cdFx0XHRjb25zdCByb3cgPSB0aGlzLmRhdGFbaV07XG5cdFx0XHRjb2x1bW4ucHVzaChyb3dbcmldKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gY29sdW1uO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBjb2x1bW4gdG8gdGhlIGBpbmRleGB0aCBjb2x1bW4gb3IgYXBwZW5kcyB0byB0YWJsZSBpZiBpbmRleCBub3QgcHJvdmlkZWQuXG5cdCAqXG5cdCAqIElmIGNvbHVtbiBpcyBzaG9ydGVyIHRoYW4gb3RoZXIgY29sdW1ucyBvciBub3QgcHJvdmlkZWQsIGl0IHdpbGwgYmUgcGFkZGVkIHdpdGhcblx0ICogZW1wdHkgYFRhYmxlSXRlbWAgZWxlbWVudHMuXG5cdCAqXG5cdCAqIElmIGNvbHVtbiBpcyBsb25nZXIgdGhhbiBvdGhlciBjb2x1bW5zLCBvdGhlcnMgd2lsbCBiZSBleHRlbmRlZCB0byBtYXRjaCBzbyBubyBkYXRhIGlzIGxvc3QuXG5cdCAqXG5cdCAqIElmIGNhbGxlZCBvbiBhbiBlbXB0eSB0YWJsZSB3aXRoIG5vIHBhcmFtZXRlcnMsIGl0IGNyZWF0ZXMgYSAxeDEgdGFibGUuXG5cdCAqXG5cdCAqIE5lZ2F0aXZlIGluZGV4IHN0YXJ0cyBmcm9tIHRoZSBlbmQuIC0xIGJlaW5nIHRoZSBsYXN0IGVsZW1lbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSBbY29sdW1uXVxuXHQgKiBAcGFyYW0gW2luZGV4XVxuXHQgKi9cblx0YWRkQ29sdW1uKGNvbHVtbj86IFRhYmxlSXRlbVtdLCBpbmRleD86IG51bWJlcikge1xuXHRcdC8vIGlmIHRhYmxlIGVtcHR5IGNyZWF0ZSB0YWJsZSB3aXRoIHJvd1xuXHRcdGlmICghdGhpcy5kYXRhIHx8IHRoaXMuZGF0YS5sZW5ndGggPT09IDAgfHwgdGhpcy5kYXRhWzBdLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0bGV0IG5ld0RhdGEgPSBuZXcgQXJyYXk8QXJyYXk8VGFibGVJdGVtPj4oKTtcblx0XHRcdGlmIChjb2x1bW4gPT0gbnVsbCkge1xuXHRcdFx0XHRuZXdEYXRhLnB1c2goW25ldyBUYWJsZUl0ZW0oKV0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjb2x1bW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRsZXQgaXRlbSA9IGNvbHVtbltpXTtcblx0XHRcdFx0XHRuZXdEYXRhLnB1c2goW2l0ZW1dKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5kYXRhID0gbmV3RGF0YTtcblxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGxldCByYyA9IHRoaXMuZGF0YS5sZW5ndGg7ICAvLyByb3cgY291bnRcblx0XHRsZXQgY2kgPSB0aGlzLnJlYWxDb2x1bW5JbmRleChpbmRleCk7XG5cblx0XHQvLyBhcHBlbmQgbWlzc2luZyByb3dzXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGNvbHVtbiAhPSBudWxsICYmIGkgPCBjb2x1bW4ubGVuZ3RoIC0gcmM7IGkrKykge1xuXHRcdFx0dGhpcy5hZGRSb3coKTtcblx0XHR9XG5cdFx0cmMgPSB0aGlzLmRhdGEubGVuZ3RoO1xuXHRcdGlmIChpbmRleCA9PSBudWxsKSB7XG5cdFx0XHQvLyBhcHBlbmQgdG8gZW5kXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHJjOyBpKyspIHtcblx0XHRcdFx0bGV0IHJvdyA9IHRoaXMuZGF0YVtpXTtcblx0XHRcdFx0cm93LnB1c2goY29sdW1uID09IG51bGwgfHwgY29sdW1uW2ldID09IG51bGwgPyBuZXcgVGFibGVJdGVtKCkgOiBjb2x1bW5baV0pO1xuXHRcdFx0fVxuXHRcdFx0Ly8gdXBkYXRlIGhlYWRlciBpZiBub3QgYWxyZWFkeSBzZXQgYnkgdXNlclxuXHRcdFx0aWYgKHRoaXMuaGVhZGVyLmxlbmd0aCA8IHRoaXMuZGF0YVswXS5sZW5ndGgpIHtcblx0XHRcdFx0dGhpcy5oZWFkZXIucHVzaChuZXcgVGFibGVIZWFkZXJJdGVtKCkpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoaW5kZXggPj0gdGhpcy5kYXRhWzBdLmxlbmd0aCkge1xuXHRcdFx0XHQvLyBpZiB0cnlpbmcgdG8gYXBwZW5kXG5cdFx0XHRcdGNpKys7XG5cdFx0XHR9XG5cdFx0XHQvLyBpbnNlcnRcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcmM7IGkrKykge1xuXHRcdFx0XHRsZXQgcm93ID0gdGhpcy5kYXRhW2ldO1xuXHRcdFx0XHRyb3cuc3BsaWNlKGNpLCAwLCBjb2x1bW4gPT0gbnVsbCB8fCBjb2x1bW5baV0gPT0gbnVsbCA/IG5ldyBUYWJsZUl0ZW0oKSA6IGNvbHVtbltpXSk7XG5cdFx0XHR9XG5cdFx0XHQvLyB1cGRhdGUgaGVhZGVyIGlmIG5vdCBhbHJlYWR5IHNldCBieSB1c2VyXG5cdFx0XHRpZiAodGhpcy5oZWFkZXIubGVuZ3RoIDwgdGhpcy5kYXRhWzBdLmxlbmd0aCkge1xuXHRcdFx0XHR0aGlzLmhlYWRlci5zcGxpY2UoY2ksIDAsIG5ldyBUYWJsZUhlYWRlckl0ZW0oKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5kYXRhQ2hhbmdlLmVtaXQoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEZWxldGVzIGBpbmRleGB0aCBjb2x1bW4uXG5cdCAqXG5cdCAqIE5lZ2F0aXZlIGluZGV4IHN0YXJ0cyBmcm9tIHRoZSBlbmQuIC0xIGJlaW5nIHRoZSBsYXN0IGVsZW1lbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSBpbmRleFxuXHQgKi9cblx0ZGVsZXRlQ29sdW1uKGluZGV4OiBudW1iZXIpIHtcblx0XHRjb25zdCByY2kgPSB0aGlzLnJlYWxDb2x1bW5JbmRleChpbmRleCk7XG5cdFx0Y29uc3Qgcm93Q291bnQgPSB0aGlzLmRhdGEubGVuZ3RoO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcm93Q291bnQ7IGkrKykge1xuXHRcdFx0dGhpcy5kYXRhW2ldLnNwbGljZShyY2ksIDEpO1xuXHRcdH1cblx0XHQvLyB1cGRhdGUgaGVhZGVyIGlmIG5vdCBhbHJlYWR5IHNldCBieSB1c2VyXG5cdFx0aWYgKHRoaXMuaGVhZGVyLmxlbmd0aCA+IHRoaXMuZGF0YVswXS5sZW5ndGgpIHtcblx0XHRcdHRoaXMuaGVhZGVyLnNwbGljZShyY2ksIDEpO1xuXHRcdH1cblxuXHRcdHRoaXMuZGF0YUNoYW5nZS5lbWl0KCk7XG5cdH1cblxuXHRtb3ZlQ29sdW1uKGluZGV4RnJvbTogbnVtYmVyLCBpbmRleFRvOiBudW1iZXIpIHtcblx0XHRjb25zdCBoZWFkZXJGcm9tID0gdGhpcy5oZWFkZXJbaW5kZXhGcm9tXTtcblxuXHRcdHRoaXMuYWRkQ29sdW1uKHRoaXMuY29sdW1uKGluZGV4RnJvbSksIGluZGV4VG8pO1xuXHRcdHRoaXMuZGVsZXRlQ29sdW1uKGluZGV4RnJvbSArIChpbmRleFRvIDwgaW5kZXhGcm9tID8gMSA6IDApKTtcblxuXHRcdHRoaXMuaGVhZGVyW2luZGV4VG8gKyAoaW5kZXhUbyA+IGluZGV4RnJvbSA/IC0xIDogMCldID0gaGVhZGVyRnJvbTtcblx0fVxuXG5cdC8qKlxuXHQgKiBjeWNsZSB0aHJvdWdoIHRoZSB0aHJlZSBzb3J0IHN0YXRlc1xuXHQgKiBAcGFyYW0gaW5kZXhcblx0ICovXG5cdGN5Y2xlU29ydFN0YXRlKGluZGV4OiBudW1iZXIpIHtcblx0XHQvLyBubyBzb3J0IHByb3ZpZGVkIHNvIGRvIHRoZSBzaW1wbGUgc29ydFxuXHRcdHN3aXRjaCAodGhpcy5oZWFkZXJbaW5kZXhdLnNvcnREaXJlY3Rpb24pIHtcblx0XHRcdGNhc2UgXCJBU0NFTkRJTkdcIjpcblx0XHRcdFx0dGhpcy5oZWFkZXJbaW5kZXhdLnNvcnREaXJlY3Rpb24gPSBcIkRFU0NFTkRJTkdcIjtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFwiREVTQ0VORElOR1wiOlxuXHRcdFx0XHR0aGlzLmhlYWRlcltpbmRleF0uc29ydERpcmVjdGlvbiA9IFwiTk9ORVwiO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHRoaXMuaGVhZGVyW2luZGV4XS5zb3J0RGlyZWN0aW9uID0gXCJBU0NFTkRJTkdcIjtcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFNvcnRzIHRoZSBkYXRhIGN1cnJlbnRseSBwcmVzZW50IGluIHRoZSBtb2RlbCBiYXNlZCBvbiBgY29tcGFyZSgpYFxuXHQgKlxuXHQgKiBEaXJlY3Rpb24gaXMgc2V0IGJ5IGBhc2NlbmRpbmdgIGFuZCBgZGVzY2VuZGluZ2AgcHJvcGVydGllcyBvZiBgVGFibGVIZWFkZXJJdGVtYFxuXHQgKiBpbiBgaW5kZXhgdGggY29sdW1uLlxuXHQgKlxuXHQgKiBAcGFyYW0gaW5kZXggVGhlIGNvbHVtbiBiYXNlZCBvbiB3aGljaCBpdCdzIHNvcnRpbmdcblx0ICovXG5cdHNvcnQoaW5kZXg6IG51bWJlcikge1xuXHRcdHRoaXMucHVzaFJvd1N0YXRlVG9Nb2RlbERhdGEoKTtcblx0XHRjb25zdCBoZWFkZXJTb3J0ZWQgPSB0aGlzLmhlYWRlcltpbmRleF0uc29ydGVkO1xuXHRcdC8vIFdlIG9ubHkgYWxsb3cgc29ydGluZyBieSBhIHNpbmdsZSBjb2x1bW4sIHNvIHJlc2V0IHNvcnQgc3RhdGUgZm9yIGFsbCBjb2x1bW5zIGJlZm9yZSBzcGVjaWZ5aW5nIG5ldyBzb3J0IHN0YXRlXG5cdFx0dGhpcy5oZWFkZXIuZm9yRWFjaChjb2x1bW4gPT4gY29sdW1uLnNvcnRlZCA9IGZhbHNlKTtcblx0XHRpZiAodGhpcy5oZWFkZXJbaW5kZXhdLnNvcnREaXJlY3Rpb24gPT09IFwiTk9ORVwiICYmIGhlYWRlclNvcnRlZCkge1xuXHRcdFx0Ly8gUmVzdG9yZSBpbml0aWFsIG9yZGVyIG9mIHJvd3Ncblx0XHRcdGNvbnN0IG9sZERhdGEgPSB0aGlzLl9kYXRhO1xuXHRcdFx0dGhpcy5fZGF0YSA9IFtdO1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3NJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IHJpID0gdGhpcy5yb3dzSW5kaWNlc1tpXTtcblx0XHRcdFx0dGhpcy5fZGF0YVtyaV0gPSBvbGREYXRhW2ldO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zdCBkZXNjZW5kaW5nID0gdGhpcy5oZWFkZXJbaW5kZXhdLnNvcnREaXJlY3Rpb24gPT09IFwiREVTQ0VORElOR1wiID8gLTEgOiAxO1xuXHRcdFx0dGhpcy5kYXRhLnNvcnQoKGEsIGIpID0+IHtcblx0XHRcdFx0cmV0dXJuIGRlc2NlbmRpbmcgKiB0aGlzLmhlYWRlcltpbmRleF0uY29tcGFyZShhW2luZGV4XSwgYltpbmRleF0pO1xuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLmhlYWRlcltpbmRleF0uc29ydGVkID0gdHJ1ZTtcblx0XHR9XG5cdFx0dGhpcy5wb3BSb3dTdGF0ZUZyb21Nb2RlbERhdGEoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBcHBlbmRzIGByb3dzU2VsZWN0ZWRgIGFuZCBgcm93c0V4cGFuZGVkYCBpbmZvIHRvIG1vZGVsIGRhdGEuXG5cdCAqXG5cdCAqIFdoZW4gc29ydGluZyByb3dzLCBkbyB0aGlzIGZpcnN0IHNvIGluZm9ybWF0aW9uIGFib3V0IHJvdyBzZWxlY3Rpb25cblx0ICogZ2V0cyBzb3J0ZWQgd2l0aCB0aGUgb3RoZXIgcm93IGluZm8uXG5cdCAqXG5cdCAqIENhbGwgYHBvcFJvd1NlbGVjdGlvbkZyb21Nb2RlbERhdGEoKWAgYWZ0ZXIgc29ydGluZyB0byBtYWtlIGV2ZXJ5dGhpbmdcblx0ICogcmlnaHQgd2l0aCB0aGUgd29ybGQgYWdhaW4uXG5cdCAqL1xuXHRwdXNoUm93U3RhdGVUb01vZGVsRGF0YSgpIHtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29uc3Qgcm93U2VsZWN0ZWRNYXJrID0gbmV3IFRhYmxlSXRlbSgpO1xuXHRcdFx0cm93U2VsZWN0ZWRNYXJrLmRhdGEgPSB0aGlzLnJvd3NTZWxlY3RlZFtpXTtcblx0XHRcdHRoaXMuZGF0YVtpXS5wdXNoKHJvd1NlbGVjdGVkTWFyayk7XG5cblx0XHRcdGNvbnN0IHJvd0V4cGFuZGVkTWFyayA9IG5ldyBUYWJsZUl0ZW0oKTtcblx0XHRcdHJvd0V4cGFuZGVkTWFyay5kYXRhID0gdGhpcy5yb3dzRXhwYW5kZWRbaV07XG5cdFx0XHR0aGlzLmRhdGFbaV0ucHVzaChyb3dFeHBhbmRlZE1hcmspO1xuXG5cdFx0XHRjb25zdCByb3dDb250ZXh0ID0gbmV3IFRhYmxlSXRlbSgpO1xuXHRcdFx0cm93Q29udGV4dC5kYXRhID0gdGhpcy5yb3dzQ29udGV4dFtpXTtcblx0XHRcdHRoaXMuZGF0YVtpXS5wdXNoKHJvd0NvbnRleHQpO1xuXG5cdFx0XHRjb25zdCByb3dDbGFzcyA9IG5ldyBUYWJsZUl0ZW0oKTtcblx0XHRcdHJvd0NsYXNzLmRhdGEgPSB0aGlzLnJvd3NDbGFzc1tpXTtcblx0XHRcdHRoaXMuZGF0YVtpXS5wdXNoKHJvd0NsYXNzKTtcblxuXHRcdFx0Y29uc3Qgcm93SW5kZXggPSBuZXcgVGFibGVJdGVtKCk7XG5cdFx0XHRyb3dJbmRleC5kYXRhID0gdGhpcy5yb3dzSW5kaWNlc1tpXTtcblx0XHRcdHRoaXMuZGF0YVtpXS5wdXNoKHJvd0luZGV4KTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmVzdG9yZXMgYHJvd3NTZWxlY3RlZGAgZnJvbSBkYXRhIHB1c2hlZCBieSBgcHVzaFJvd1NlbGVjdGlvblRvTW9kZWxEYXRhKClgXG5cdCAqXG5cdCAqIENhbGwgYWZ0ZXIgc29ydGluZyBkYXRhIChpZiB5b3UgcHJldmlvdXNseSBwdXNoZWQgdG8gbWFpbnRhaW4gc2VsZWN0aW9uIG9yZGVyKVxuXHQgKiB0byBtYWtlIGV2ZXJ5dGhpbmcgcmlnaHQgd2l0aCB0aGUgd29ybGQgYWdhaW4uXG5cdCAqL1xuXHRwb3BSb3dTdGF0ZUZyb21Nb2RlbERhdGEoKSB7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyspIHtcblx0XHRcdHRoaXMucm93c0luZGljZXNbaV0gPSB0aGlzLmRhdGFbaV0ucG9wKCkuZGF0YTtcblx0XHRcdHRoaXMucm93c0NsYXNzW2ldID0gdGhpcy5kYXRhW2ldLnBvcCgpLmRhdGE7XG5cdFx0XHR0aGlzLnJvd3NDb250ZXh0W2ldID0gdGhpcy5kYXRhW2ldLnBvcCgpLmRhdGE7XG5cdFx0XHR0aGlzLnJvd3NFeHBhbmRlZFtpXSA9ICEhdGhpcy5kYXRhW2ldLnBvcCgpLmRhdGE7XG5cdFx0XHR0aGlzLnJvd3NTZWxlY3RlZFtpXSA9ICEhdGhpcy5kYXRhW2ldLnBvcCgpLmRhdGE7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiByb3cgaXMgZmlsdGVyZWQgb3V0LlxuXHQgKlxuXHQgKiBAcGFyYW0gaW5kZXhcblx0ICogQHJldHVybnMgdHJ1ZSBpZiBhbnkgb2YgdGhlIGZpbHRlcnMgaW4gaGVhZGVyIGZpbHRlcnMgb3V0IHRoZSBgaW5kZXhgdGggcm93XG5cdCAqL1xuXHRpc1Jvd0ZpbHRlcmVkKGluZGV4OiBudW1iZXIpOiBib29sZWFuIHtcblx0XHRjb25zdCByZWFsSW5kZXggPSB0aGlzLnJlYWxSb3dJbmRleChpbmRleCk7XG5cdFx0cmV0dXJuIHRoaXMuaGVhZGVyLnNvbWUoKGl0ZW0sIGkpID0+IGl0ZW0gJiYgaXRlbS5maWx0ZXIodGhpcy5yb3cocmVhbEluZGV4KVtpXSkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNlbGVjdC9kZXNlbGVjdCBgaW5kZXhgdGggcm93IGJhc2VkIG9uIHZhbHVlXG5cdCAqXG5cdCAqIEBwYXJhbSBpbmRleCBpbmRleCBvZiB0aGUgcm93IHRvIHNlbGVjdFxuXHQgKiBAcGFyYW0gdmFsdWUgc3RhdGUgdG8gc2V0IHRoZSByb3cgdG8uIERlZmF1bHRzIHRvIGB0cnVlYFxuXHQgKi9cblx0c2VsZWN0Um93KGluZGV4OiBudW1iZXIsIHZhbHVlID0gdHJ1ZSkge1xuXHRcdGlmICh0aGlzLmlzUm93RGlzYWJsZWQoaW5kZXgpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMucm93c1NlbGVjdGVkW2luZGV4XSA9IHZhbHVlO1xuXHRcdHRoaXMucm93c1NlbGVjdGVkQ2hhbmdlLmVtaXQoaW5kZXgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNlbGVjdHMgb3IgZGVzZWxlY3RzIGFsbCByb3dzIGluIHRoZSBtb2RlbFxuXHQgKlxuXHQgKiBAcGFyYW0gdmFsdWUgc3RhdGUgdG8gc2V0IGFsbCByb3dzIHRvLiBEZWZhdWx0cyB0byBgdHJ1ZWBcblx0ICovXG5cdHNlbGVjdEFsbCh2YWx1ZSA9IHRydWUpIHtcblx0XHRpZiAodGhpcy5kYXRhLmxlbmd0aCA+PSAxICYmIHRoaXMuZGF0YVswXS5sZW5ndGggPj0gMSkge1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3NTZWxlY3RlZC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR0aGlzLnNlbGVjdFJvdyhpLCB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMuc2VsZWN0QWxsQ2hhbmdlLm5leHQodmFsdWUpO1xuXHR9XG5cblx0aXNSb3dTZWxlY3RlZChpbmRleDogbnVtYmVyKSB7XG5cdFx0cmV0dXJuIHRoaXMucm93c1NlbGVjdGVkW2luZGV4XTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgcm93IGlzIGRpc2FibGVkIG9yIG5vdC5cblx0ICovXG5cdGlzUm93RGlzYWJsZWQoaW5kZXg6IG51bWJlcikge1xuXHRcdGNvbnN0IHJvdyA9IHRoaXMuZGF0YVtpbmRleF0gYXMgVGFibGVSb3c7XG5cdFx0cmV0dXJuICEhcm93LmRpc2FibGVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIEV4cGFuZHMvQ29sbGFwc2VzIGBpbmRleGB0aCByb3cgYmFzZWQgb24gdmFsdWVcblx0ICpcblx0ICogQHBhcmFtIGluZGV4IGluZGV4IG9mIHRoZSByb3cgdG8gZXhwYW5kIG9yIGNvbGxhcHNlXG5cdCAqIEBwYXJhbSB2YWx1ZSBleHBhbmRlZCBzdGF0ZSBvZiB0aGUgcm93LiBgdHJ1ZWAgaXMgZXhwYW5kZWQgYW5kIGBmYWxzZWAgaXMgY29sbGFwc2VkXG5cdCAqL1xuXHRleHBhbmRSb3coaW5kZXg6IG51bWJlciwgdmFsdWUgPSB0cnVlKSB7XG5cdFx0dGhpcy5yb3dzRXhwYW5kZWRbaW5kZXhdID0gdmFsdWU7XG5cdFx0dGhpcy5yb3dzRXhwYW5kZWRDaGFuZ2UuZW1pdChpbmRleCk7XG5cdH1cblxuXHQvKipcblx0ICogRXhwYW5kcyAvIGNvbGxhcHNlcyBhbGwgcm93c1xuXHQgKlxuXHQgKiBAcGFyYW0gdmFsdWUgZXhwYW5kZWQgc3RhdGUgb2YgdGhlIHJvd3MuIGB0cnVlYCBpcyBleHBhbmRlZCBhbmQgYGZhbHNlYCBpcyBjb2xsYXBzZWRcblx0ICovXG5cdGV4cGFuZEFsbFJvd3ModmFsdWUgPSB0cnVlKSB7XG5cdFx0aWYgKHRoaXMuZGF0YS5sZW5ndGggPiAwKSB7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAodGhpcy5pc1Jvd0V4cGFuZGFibGUoaSkpIHtcblx0XHRcdFx0XHR0aGlzLnJvd3NFeHBhbmRlZFtpXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICh2YWx1ZSkge1xuXHRcdFx0XHR0aGlzLnJvd3NFeHBhbmRlZEFsbENoYW5nZS5lbWl0KCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnJvd3NDb2xsYXBzZWRBbGxDaGFuZ2UuZW1pdCgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSB0cnVlIGluZGV4IG9mIGEgcm93IGJhc2VkIG9uIGl0J3MgcmVsYXRpdmUgcG9zaXRpb24uXG5cdCAqIExpa2UgaW4gUHl0aG9uLCBwb3NpdGl2ZSBudW1iZXJzIHN0YXJ0IGZyb20gdGhlIHRvcCBhbmRcblx0ICogbmVnYXRpdmUgbnVtYmVycyBzdGFydCBmcm9tIHRoZSBib3R0b20uXG5cdCAqXG5cdCAqIEBwYXJhbSBpbmRleFxuXHQgKi9cblx0cHJvdGVjdGVkIHJlYWxSb3dJbmRleChpbmRleDogbnVtYmVyKTogbnVtYmVyIHtcblx0XHRyZXR1cm4gdGhpcy5yZWFsSW5kZXgoaW5kZXgsIHRoaXMuZGF0YS5sZW5ndGgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIHRydWUgaW5kZXggb2YgYSBjb2x1bW4gYmFzZWQgb24gaXQncyByZWxhdGl2ZSBwb3NpdGlvbi5cblx0ICogTGlrZSBpbiBQeXRob24sIHBvc2l0aXZlIG51bWJlcnMgc3RhcnQgZnJvbSB0aGUgdG9wIGFuZFxuXHQgKiBuZWdhdGl2ZSBudW1iZXJzIHN0YXJ0IGZyb20gdGhlIGJvdHRvbS5cblx0ICpcblx0ICogQHBhcmFtIGluZGV4XG5cdCAqL1xuXHRwcm90ZWN0ZWQgcmVhbENvbHVtbkluZGV4KGluZGV4OiBudW1iZXIpOiBudW1iZXIge1xuXHRcdHJldHVybiB0aGlzLnJlYWxJbmRleChpbmRleCwgdGhpcy5kYXRhWzBdLmxlbmd0aCk7XG5cdH1cblxuXHQvKipcblx0ICogR2VuZXJpYyBmdW5jdGlvbiB0byBjYWxjdWxhdGUgdGhlIHJlYWwgaW5kZXggb2Ygc29tZXRoaW5nLlxuXHQgKiBVc2VkIGJ5IGByZWFsUm93SW5kZXgoKWAgYW5kIGByZWFsQ29sdW1uSW5kZXgoKWBcblx0ICpcblx0ICogQHBhcmFtIGluZGV4XG5cdCAqIEBwYXJhbSBsZW5ndGhcblx0ICovXG5cdHByb3RlY3RlZCByZWFsSW5kZXgoaW5kZXg6IG51bWJlciwgbGVuZ3RoOiBudW1iZXIpOiBudW1iZXIge1xuXHRcdGlmIChpbmRleCA9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gbGVuZ3RoIC0gMTtcblx0XHR9IGVsc2UgaWYgKGluZGV4ID49IDApIHtcblx0XHRcdHJldHVybiBpbmRleCA+PSBsZW5ndGggPyBsZW5ndGggLSAxIDogaW5kZXg7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiAtaW5kZXggPj0gbGVuZ3RoID8gMCA6IGxlbmd0aCArIGluZGV4O1xuXHRcdH1cblx0fVxufVxuIl19