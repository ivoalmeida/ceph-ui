import { Component, HostBinding, Input, TemplateRef } from "@angular/core";
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
import * as i2 from "carbon-components-angular/icon";
/**
 * Get started with importing the module:
 *
 * ```typescript
 * import { ProgressBarModule } from 'carbon-components-angular';
 * ```
 *
 * [See demo](../../?path=/story/components-progress-bar--basic)
 */
export class ProgressBar {
    constructor() {
        this.id = `progress-bar-${ProgressBar.progressBarCounter++}`;
        this.helperId = `progress-bar-helper-${ProgressBar.progressBarCounter}`;
        /**
         * Maximum value
         */
        this.max = 100;
        /**
         * Alignment variant of the progress bar, default is `default`
         */
        this.type = "default";
        /**
         * Current status of the progress bar, default is `active`
         */
        this.status = "active";
        /**
         * Size of the progress bar, default is `big`
         */
        this.size = "big";
        this.defaultClass = true;
        this._value = undefined;
    }
    /**
     * Current value
     */
    set value(num) {
        this._value = num;
        // Validate number
        if (num > this.max) {
            this._value = this.max;
        }
        if (num < 0) {
            this._value = 0;
        }
        // Set values based on current state
        if (this.isError) {
            this._value = 0;
        }
        else if (this.isFinished) {
            this._value = this.max;
        }
    }
    get value() {
        return this._value;
    }
    get percentage() {
        return `scaleX(${this.value / this.max})`;
    }
    // Size
    get bigBar() {
        return this.size === "big";
    }
    get smallBar() {
        return this.size === "small";
    }
    // Type
    get defaultType() {
        return this.type === "default";
    }
    get indentedType() {
        return this.type === "indented";
    }
    get inlineType() {
        return this.type === "inline";
    }
    // Status
    get isFinished() {
        return this.status === "finished";
    }
    get isError() {
        return this.status === "error";
    }
    get indeterminate() {
        return this.value === undefined && !this.isFinished && !this.isError;
    }
    isTemplate(value) {
        return value instanceof TemplateRef;
    }
}
ProgressBar.progressBarCounter = 0;
ProgressBar.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: ProgressBar, deps: [], target: i0.ɵɵFactoryTarget.Component });
ProgressBar.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.3.0", type: ProgressBar, selector: "cds-progress-bar, ibm-progress-bar", inputs: { value: "value", id: "id", label: "label", helperText: "helperText", max: "max", type: "type", status: "status", size: "size" }, host: { properties: { "class.cds--progress-bar--big": "this.bigBar", "class.cds--progress-bar--small": "this.smallBar", "class.cds--progress-bar--default": "this.defaultType", "class.cds--progress-bar--indented": "this.indentedType", "class.cds--progress-bar--inline": "this.inlineType", "class.cds--progress-bar--finished": "this.isFinished", "class.cds--progress-bar--error": "this.isError", "class.cds--progress-bar--indeterminate": "this.indeterminate", "class.cds--progress-bar": "this.defaultClass" } }, ngImport: i0, template: `
		<div
			*ngIf="label"
			class="cds--progress-bar__label"
			[id]="id">
			<span class="cds--progress-bar__label-text">
				<ng-container *ngIf="!isTemplate(label)">{{label}}</ng-container>
				<ng-template *ngIf="isTemplate(label)" [ngTemplateOutlet]="label"></ng-template>
			</span>
			<svg
				*ngIf="isFinished"
				fill="currentColor"
				cdsIcon="checkmark--filled"
				class="cds--progress-bar__status-icon">
			</svg>
			<svg
				*ngIf="isError"
				fill="currentColor"
				cdsIcon="error--filled"
				class="cds--progress-bar__status-icon">
			</svg>
		</div>
		<div
			class="cds--progress-bar__track"
			role="progressbar"
			[attr.aria-invalid]="isError"
			[attr.aria-labelledby]="id"
			[attr.aria-describedby]="helperText ? helperId : null"
			[attr.aria-valuemin]="!indeterminate ? 0 : null"
			[attr.aria-valuemax]="!indeterminate ? max : null"
			[attr.aria-valuenow]="!indeterminate ? value : null">
			<div
				class="cds--progress-bar__bar"
				[ngStyle]="{
					'transform': !isFinished && !isError ? percentage : null
				}">
			</div>
		</div>
		<div
			[id]="helperId"
			*ngIf="helperText"
			class="cds--progress-bar__helper-text">
			<ng-container *ngIf="!isTemplate(helperText)">{{helperText}}</ng-container>
			<ng-template *ngIf="isTemplate(helperText)" [ngTemplateOutlet]="helperText"></ng-template>
		</div>
	`, isInline: true, dependencies: [{ kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "directive", type: i2.IconDirective, selector: "[cdsIcon], [ibmIcon]", inputs: ["ibmIcon", "cdsIcon", "size", "title", "ariaLabel", "ariaLabelledBy", "ariaHidden", "isFocusable"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: ProgressBar, decorators: [{
            type: Component,
            args: [{
                    selector: "cds-progress-bar, ibm-progress-bar",
                    template: `
		<div
			*ngIf="label"
			class="cds--progress-bar__label"
			[id]="id">
			<span class="cds--progress-bar__label-text">
				<ng-container *ngIf="!isTemplate(label)">{{label}}</ng-container>
				<ng-template *ngIf="isTemplate(label)" [ngTemplateOutlet]="label"></ng-template>
			</span>
			<svg
				*ngIf="isFinished"
				fill="currentColor"
				cdsIcon="checkmark--filled"
				class="cds--progress-bar__status-icon">
			</svg>
			<svg
				*ngIf="isError"
				fill="currentColor"
				cdsIcon="error--filled"
				class="cds--progress-bar__status-icon">
			</svg>
		</div>
		<div
			class="cds--progress-bar__track"
			role="progressbar"
			[attr.aria-invalid]="isError"
			[attr.aria-labelledby]="id"
			[attr.aria-describedby]="helperText ? helperId : null"
			[attr.aria-valuemin]="!indeterminate ? 0 : null"
			[attr.aria-valuemax]="!indeterminate ? max : null"
			[attr.aria-valuenow]="!indeterminate ? value : null">
			<div
				class="cds--progress-bar__bar"
				[ngStyle]="{
					'transform': !isFinished && !isError ? percentage : null
				}">
			</div>
		</div>
		<div
			[id]="helperId"
			*ngIf="helperText"
			class="cds--progress-bar__helper-text">
			<ng-container *ngIf="!isTemplate(helperText)">{{helperText}}</ng-container>
			<ng-template *ngIf="isTemplate(helperText)" [ngTemplateOutlet]="helperText"></ng-template>
		</div>
	`
                }]
        }], propDecorators: { value: [{
                type: Input
            }], bigBar: [{
                type: HostBinding,
                args: ["class.cds--progress-bar--big"]
            }], smallBar: [{
                type: HostBinding,
                args: ["class.cds--progress-bar--small"]
            }], defaultType: [{
                type: HostBinding,
                args: ["class.cds--progress-bar--default"]
            }], indentedType: [{
                type: HostBinding,
                args: ["class.cds--progress-bar--indented"]
            }], inlineType: [{
                type: HostBinding,
                args: ["class.cds--progress-bar--inline"]
            }], isFinished: [{
                type: HostBinding,
                args: ["class.cds--progress-bar--finished"]
            }], isError: [{
                type: HostBinding,
                args: ["class.cds--progress-bar--error"]
            }], indeterminate: [{
                type: HostBinding,
                args: ["class.cds--progress-bar--indeterminate"]
            }], id: [{
                type: Input
            }], label: [{
                type: Input
            }], helperText: [{
                type: Input
            }], max: [{
                type: Input
            }], type: [{
                type: Input
            }], status: [{
                type: Input
            }], size: [{
                type: Input
            }], defaultClass: [{
                type: HostBinding,
                args: ["class.cds--progress-bar"]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvZ3Jlc3MtYmFyLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9wcm9ncmVzcy1iYXIvcHJvZ3Jlc3MtYmFyLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ04sU0FBUyxFQUNULFdBQVcsRUFDWCxLQUFLLEVBQ0wsV0FBVyxFQUNYLE1BQU0sZUFBZSxDQUFDOzs7O0FBRXZCOzs7Ozs7OztHQVFHO0FBa0RILE1BQU0sT0FBTyxXQUFXO0lBakR4QjtRQTBHVSxPQUFFLEdBQUcsZ0JBQWdCLFdBQVcsQ0FBQyxrQkFBa0IsRUFBRSxFQUFFLENBQUM7UUFDakUsYUFBUSxHQUFHLHVCQUF1QixXQUFXLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztRQVNuRTs7V0FFRztRQUNNLFFBQUcsR0FBRyxHQUFHLENBQUM7UUFDbkI7O1dBRUc7UUFDTSxTQUFJLEdBQXNDLFNBQVMsQ0FBQztRQUM3RDs7V0FFRztRQUNNLFdBQU0sR0FBb0MsUUFBUSxDQUFDO1FBQzVEOztXQUVHO1FBQ00sU0FBSSxHQUFvQixLQUFLLENBQUM7UUFFQyxpQkFBWSxHQUFHLElBQUksQ0FBQztRQUNwRCxXQUFNLEdBQUcsU0FBUyxDQUFDO0tBSzNCO0lBekZBOztPQUVHO0lBQ0gsSUFBYSxLQUFLLENBQUMsR0FBdUI7UUFDekMsSUFBSSxDQUFDLE1BQU0sR0FBRyxHQUFHLENBQUM7UUFDbEIsa0JBQWtCO1FBQ2xCLElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUU7WUFDbkIsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDO1NBQ3ZCO1FBQ0QsSUFBSSxHQUFHLEdBQUcsQ0FBQyxFQUFFO1lBQ1osSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7U0FDaEI7UUFDRCxvQ0FBb0M7UUFDcEMsSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFO1lBQ2pCLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO1NBQ2hCO2FBQU0sSUFBSSxJQUFJLENBQUMsVUFBVSxFQUFFO1lBQzNCLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQztTQUN2QjtJQUNGLENBQUM7SUFFRCxJQUFJLEtBQUs7UUFDUixPQUFPLElBQUksQ0FBQyxNQUFNLENBQUM7SUFDcEIsQ0FBQztJQUVELElBQUksVUFBVTtRQUNiLE9BQU8sVUFBVSxJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxHQUFHLEdBQUcsQ0FBQztJQUMzQyxDQUFDO0lBQ0QsT0FBTztJQUNQLElBQWlELE1BQU07UUFDdEQsT0FBTyxJQUFJLENBQUMsSUFBSSxLQUFLLEtBQUssQ0FBQztJQUM1QixDQUFDO0lBQ0QsSUFBbUQsUUFBUTtRQUMxRCxPQUFPLElBQUksQ0FBQyxJQUFJLEtBQUssT0FBTyxDQUFDO0lBQzlCLENBQUM7SUFDRCxPQUFPO0lBQ1AsSUFBcUQsV0FBVztRQUMvRCxPQUFPLElBQUksQ0FBQyxJQUFJLEtBQUssU0FBUyxDQUFDO0lBQ2hDLENBQUM7SUFDRCxJQUFzRCxZQUFZO1FBQ2pFLE9BQU8sSUFBSSxDQUFDLElBQUksS0FBSyxVQUFVLENBQUM7SUFDakMsQ0FBQztJQUNELElBQW9ELFVBQVU7UUFDN0QsT0FBTyxJQUFJLENBQUMsSUFBSSxLQUFLLFFBQVEsQ0FBQztJQUMvQixDQUFDO0lBQ0QsU0FBUztJQUNULElBQXNELFVBQVU7UUFDL0QsT0FBTyxJQUFJLENBQUMsTUFBTSxLQUFLLFVBQVUsQ0FBQztJQUNuQyxDQUFDO0lBQ0QsSUFBbUQsT0FBTztRQUN6RCxPQUFPLElBQUksQ0FBQyxNQUFNLEtBQUssT0FBTyxDQUFDO0lBQ2hDLENBQUM7SUFDRCxJQUEyRCxhQUFhO1FBQ3ZFLE9BQU8sSUFBSSxDQUFDLEtBQUssS0FBSyxTQUFTLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQztJQUN0RSxDQUFDO0lBaUNELFVBQVUsQ0FBQyxLQUFLO1FBQ2YsT0FBTyxLQUFLLFlBQVksV0FBVyxDQUFDO0lBQ3JDLENBQUM7O0FBbENNLDhCQUFrQixHQUFHLENBQUMsQ0FBQzt3R0F2RGxCLFdBQVc7NEZBQVgsV0FBVyxrdEJBL0NiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUE2Q1Q7MkZBRVcsV0FBVztrQkFqRHZCLFNBQVM7bUJBQUM7b0JBQ1YsUUFBUSxFQUFFLG9DQUFvQztvQkFDOUMsUUFBUSxFQUFFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUE2Q1Q7aUJBQ0Q7OEJBS2EsS0FBSztzQkFBakIsS0FBSztnQkF5QjJDLE1BQU07c0JBQXRELFdBQVc7dUJBQUMsOEJBQThCO2dCQUdRLFFBQVE7c0JBQTFELFdBQVc7dUJBQUMsZ0NBQWdDO2dCQUlRLFdBQVc7c0JBQS9ELFdBQVc7dUJBQUMsa0NBQWtDO2dCQUdPLFlBQVk7c0JBQWpFLFdBQVc7dUJBQUMsbUNBQW1DO2dCQUdJLFVBQVU7c0JBQTdELFdBQVc7dUJBQUMsaUNBQWlDO2dCQUlRLFVBQVU7c0JBQS9ELFdBQVc7dUJBQUMsbUNBQW1DO2dCQUdHLE9BQU87c0JBQXpELFdBQVc7dUJBQUMsZ0NBQWdDO2dCQUdjLGFBQWE7c0JBQXZFLFdBQVc7dUJBQUMsd0NBQXdDO2dCQUs1QyxFQUFFO3NCQUFWLEtBQUs7Z0JBS0csS0FBSztzQkFBYixLQUFLO2dCQUlHLFVBQVU7c0JBQWxCLEtBQUs7Z0JBSUcsR0FBRztzQkFBWCxLQUFLO2dCQUlHLElBQUk7c0JBQVosS0FBSztnQkFJRyxNQUFNO3NCQUFkLEtBQUs7Z0JBSUcsSUFBSTtzQkFBWixLQUFLO2dCQUVrQyxZQUFZO3NCQUFuRCxXQUFXO3VCQUFDLHlCQUF5QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG5cdENvbXBvbmVudCxcblx0SG9zdEJpbmRpbmcsXG5cdElucHV0LFxuXHRUZW1wbGF0ZVJlZlxufSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuXG4vKipcbiAqIEdldCBzdGFydGVkIHdpdGggaW1wb3J0aW5nIHRoZSBtb2R1bGU6XG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHsgUHJvZ3Jlc3NCYXJNb2R1bGUgfSBmcm9tICdjYXJib24tY29tcG9uZW50cy1hbmd1bGFyJztcbiAqIGBgYFxuICpcbiAqIFtTZWUgZGVtb10oLi4vLi4vP3BhdGg9L3N0b3J5L2NvbXBvbmVudHMtcHJvZ3Jlc3MtYmFyLS1iYXNpYylcbiAqL1xuQENvbXBvbmVudCh7XG5cdHNlbGVjdG9yOiBcImNkcy1wcm9ncmVzcy1iYXIsIGlibS1wcm9ncmVzcy1iYXJcIixcblx0dGVtcGxhdGU6IGBcblx0XHQ8ZGl2XG5cdFx0XHQqbmdJZj1cImxhYmVsXCJcblx0XHRcdGNsYXNzPVwiY2RzLS1wcm9ncmVzcy1iYXJfX2xhYmVsXCJcblx0XHRcdFtpZF09XCJpZFwiPlxuXHRcdFx0PHNwYW4gY2xhc3M9XCJjZHMtLXByb2dyZXNzLWJhcl9fbGFiZWwtdGV4dFwiPlxuXHRcdFx0XHQ8bmctY29udGFpbmVyICpuZ0lmPVwiIWlzVGVtcGxhdGUobGFiZWwpXCI+e3tsYWJlbH19PC9uZy1jb250YWluZXI+XG5cdFx0XHRcdDxuZy10ZW1wbGF0ZSAqbmdJZj1cImlzVGVtcGxhdGUobGFiZWwpXCIgW25nVGVtcGxhdGVPdXRsZXRdPVwibGFiZWxcIj48L25nLXRlbXBsYXRlPlxuXHRcdFx0PC9zcGFuPlxuXHRcdFx0PHN2Z1xuXHRcdFx0XHQqbmdJZj1cImlzRmluaXNoZWRcIlxuXHRcdFx0XHRmaWxsPVwiY3VycmVudENvbG9yXCJcblx0XHRcdFx0Y2RzSWNvbj1cImNoZWNrbWFyay0tZmlsbGVkXCJcblx0XHRcdFx0Y2xhc3M9XCJjZHMtLXByb2dyZXNzLWJhcl9fc3RhdHVzLWljb25cIj5cblx0XHRcdDwvc3ZnPlxuXHRcdFx0PHN2Z1xuXHRcdFx0XHQqbmdJZj1cImlzRXJyb3JcIlxuXHRcdFx0XHRmaWxsPVwiY3VycmVudENvbG9yXCJcblx0XHRcdFx0Y2RzSWNvbj1cImVycm9yLS1maWxsZWRcIlxuXHRcdFx0XHRjbGFzcz1cImNkcy0tcHJvZ3Jlc3MtYmFyX19zdGF0dXMtaWNvblwiPlxuXHRcdFx0PC9zdmc+XG5cdFx0PC9kaXY+XG5cdFx0PGRpdlxuXHRcdFx0Y2xhc3M9XCJjZHMtLXByb2dyZXNzLWJhcl9fdHJhY2tcIlxuXHRcdFx0cm9sZT1cInByb2dyZXNzYmFyXCJcblx0XHRcdFthdHRyLmFyaWEtaW52YWxpZF09XCJpc0Vycm9yXCJcblx0XHRcdFthdHRyLmFyaWEtbGFiZWxsZWRieV09XCJpZFwiXG5cdFx0XHRbYXR0ci5hcmlhLWRlc2NyaWJlZGJ5XT1cImhlbHBlclRleHQgPyBoZWxwZXJJZCA6IG51bGxcIlxuXHRcdFx0W2F0dHIuYXJpYS12YWx1ZW1pbl09XCIhaW5kZXRlcm1pbmF0ZSA/IDAgOiBudWxsXCJcblx0XHRcdFthdHRyLmFyaWEtdmFsdWVtYXhdPVwiIWluZGV0ZXJtaW5hdGUgPyBtYXggOiBudWxsXCJcblx0XHRcdFthdHRyLmFyaWEtdmFsdWVub3ddPVwiIWluZGV0ZXJtaW5hdGUgPyB2YWx1ZSA6IG51bGxcIj5cblx0XHRcdDxkaXZcblx0XHRcdFx0Y2xhc3M9XCJjZHMtLXByb2dyZXNzLWJhcl9fYmFyXCJcblx0XHRcdFx0W25nU3R5bGVdPVwie1xuXHRcdFx0XHRcdCd0cmFuc2Zvcm0nOiAhaXNGaW5pc2hlZCAmJiAhaXNFcnJvciA/IHBlcmNlbnRhZ2UgOiBudWxsXG5cdFx0XHRcdH1cIj5cblx0XHRcdDwvZGl2PlxuXHRcdDwvZGl2PlxuXHRcdDxkaXZcblx0XHRcdFtpZF09XCJoZWxwZXJJZFwiXG5cdFx0XHQqbmdJZj1cImhlbHBlclRleHRcIlxuXHRcdFx0Y2xhc3M9XCJjZHMtLXByb2dyZXNzLWJhcl9faGVscGVyLXRleHRcIj5cblx0XHRcdDxuZy1jb250YWluZXIgKm5nSWY9XCIhaXNUZW1wbGF0ZShoZWxwZXJUZXh0KVwiPnt7aGVscGVyVGV4dH19PC9uZy1jb250YWluZXI+XG5cdFx0XHQ8bmctdGVtcGxhdGUgKm5nSWY9XCJpc1RlbXBsYXRlKGhlbHBlclRleHQpXCIgW25nVGVtcGxhdGVPdXRsZXRdPVwiaGVscGVyVGV4dFwiPjwvbmctdGVtcGxhdGU+XG5cdFx0PC9kaXY+XG5cdGBcbn0pXG5leHBvcnQgY2xhc3MgUHJvZ3Jlc3NCYXIge1xuXHQvKipcblx0ICogQ3VycmVudCB2YWx1ZVxuXHQgKi9cblx0QElucHV0KCkgc2V0IHZhbHVlKG51bTogbnVtYmVyIHwgdW5kZWZpbmVkKSB7XG5cdFx0dGhpcy5fdmFsdWUgPSBudW07XG5cdFx0Ly8gVmFsaWRhdGUgbnVtYmVyXG5cdFx0aWYgKG51bSA+IHRoaXMubWF4KSB7XG5cdFx0XHR0aGlzLl92YWx1ZSA9IHRoaXMubWF4O1xuXHRcdH1cblx0XHRpZiAobnVtIDwgMCkge1xuXHRcdFx0dGhpcy5fdmFsdWUgPSAwO1xuXHRcdH1cblx0XHQvLyBTZXQgdmFsdWVzIGJhc2VkIG9uIGN1cnJlbnQgc3RhdGVcblx0XHRpZiAodGhpcy5pc0Vycm9yKSB7XG5cdFx0XHR0aGlzLl92YWx1ZSA9IDA7XG5cdFx0fSBlbHNlIGlmICh0aGlzLmlzRmluaXNoZWQpIHtcblx0XHRcdHRoaXMuX3ZhbHVlID0gdGhpcy5tYXg7XG5cdFx0fVxuXHR9XG5cblx0Z2V0IHZhbHVlKCkge1xuXHRcdHJldHVybiB0aGlzLl92YWx1ZTtcblx0fVxuXG5cdGdldCBwZXJjZW50YWdlKCkge1xuXHRcdHJldHVybiBgc2NhbGVYKCR7dGhpcy52YWx1ZSAvIHRoaXMubWF4fSlgO1xuXHR9XG5cdC8vIFNpemVcblx0QEhvc3RCaW5kaW5nKFwiY2xhc3MuY2RzLS1wcm9ncmVzcy1iYXItLWJpZ1wiKSBnZXQgYmlnQmFyKCkge1xuXHRcdHJldHVybiB0aGlzLnNpemUgPT09IFwiYmlnXCI7XG5cdH1cblx0QEhvc3RCaW5kaW5nKFwiY2xhc3MuY2RzLS1wcm9ncmVzcy1iYXItLXNtYWxsXCIpIGdldCBzbWFsbEJhcigpIHtcblx0XHRyZXR1cm4gdGhpcy5zaXplID09PSBcInNtYWxsXCI7XG5cdH1cblx0Ly8gVHlwZVxuXHRASG9zdEJpbmRpbmcoXCJjbGFzcy5jZHMtLXByb2dyZXNzLWJhci0tZGVmYXVsdFwiKSBnZXQgZGVmYXVsdFR5cGUoKSB7XG5cdFx0cmV0dXJuIHRoaXMudHlwZSA9PT0gXCJkZWZhdWx0XCI7XG5cdH1cblx0QEhvc3RCaW5kaW5nKFwiY2xhc3MuY2RzLS1wcm9ncmVzcy1iYXItLWluZGVudGVkXCIpIGdldCBpbmRlbnRlZFR5cGUoKSB7XG5cdFx0cmV0dXJuIHRoaXMudHlwZSA9PT0gXCJpbmRlbnRlZFwiO1xuXHR9XG5cdEBIb3N0QmluZGluZyhcImNsYXNzLmNkcy0tcHJvZ3Jlc3MtYmFyLS1pbmxpbmVcIikgZ2V0IGlubGluZVR5cGUoKSB7XG5cdFx0cmV0dXJuIHRoaXMudHlwZSA9PT0gXCJpbmxpbmVcIjtcblx0fVxuXHQvLyBTdGF0dXNcblx0QEhvc3RCaW5kaW5nKFwiY2xhc3MuY2RzLS1wcm9ncmVzcy1iYXItLWZpbmlzaGVkXCIpIGdldCBpc0ZpbmlzaGVkKCkge1xuXHRcdHJldHVybiB0aGlzLnN0YXR1cyA9PT0gXCJmaW5pc2hlZFwiO1xuXHR9XG5cdEBIb3N0QmluZGluZyhcImNsYXNzLmNkcy0tcHJvZ3Jlc3MtYmFyLS1lcnJvclwiKSBnZXQgaXNFcnJvcigpIHtcblx0XHRyZXR1cm4gdGhpcy5zdGF0dXMgPT09IFwiZXJyb3JcIjtcblx0fVxuXHRASG9zdEJpbmRpbmcoXCJjbGFzcy5jZHMtLXByb2dyZXNzLWJhci0taW5kZXRlcm1pbmF0ZVwiKSBnZXQgaW5kZXRlcm1pbmF0ZSgpIHtcblx0XHRyZXR1cm4gdGhpcy52YWx1ZSA9PT0gdW5kZWZpbmVkICYmICF0aGlzLmlzRmluaXNoZWQgJiYgIXRoaXMuaXNFcnJvcjtcblx0fVxuXHRzdGF0aWMgcHJvZ3Jlc3NCYXJDb3VudGVyID0gMDtcblxuXHRASW5wdXQoKSBpZCA9IGBwcm9ncmVzcy1iYXItJHtQcm9ncmVzc0Jhci5wcm9ncmVzc0JhckNvdW50ZXIrK31gO1xuXHRoZWxwZXJJZCA9IGBwcm9ncmVzcy1iYXItaGVscGVyLSR7UHJvZ3Jlc3NCYXIucHJvZ3Jlc3NCYXJDb3VudGVyfWA7XG5cdC8qKlxuXHQgKiBEZXNjcmlwdGlvbiBvZiB0aGUgcHJvZ3Jlc3MgYmFyXG5cdCAqL1xuXHRASW5wdXQoKSBsYWJlbDogc3RyaW5nIHwgVGVtcGxhdGVSZWY8YW55Pjtcblx0LyoqXG5cdCAqIEN1cnJlbnQgcHJvZ3Jlc3MgdGV4dHVhbCByZXByZXNlbnRhdGlvblxuXHQgKi9cblx0QElucHV0KCkgaGVscGVyVGV4dDogc3RyaW5nIHwgVGVtcGxhdGVSZWY8YW55Pjtcblx0LyoqXG5cdCAqIE1heGltdW0gdmFsdWVcblx0ICovXG5cdEBJbnB1dCgpIG1heCA9IDEwMDtcblx0LyoqXG5cdCAqIEFsaWdubWVudCB2YXJpYW50IG9mIHRoZSBwcm9ncmVzcyBiYXIsIGRlZmF1bHQgaXMgYGRlZmF1bHRgXG5cdCAqL1xuXHRASW5wdXQoKSB0eXBlOiBcImRlZmF1bHRcIiB8IFwiaW5saW5lXCIgfCBcImluZGVudGVkXCIgPSBcImRlZmF1bHRcIjtcblx0LyoqXG5cdCAqIEN1cnJlbnQgc3RhdHVzIG9mIHRoZSBwcm9ncmVzcyBiYXIsIGRlZmF1bHQgaXMgYGFjdGl2ZWBcblx0ICovXG5cdEBJbnB1dCgpIHN0YXR1czogXCJhY3RpdmVcIiB8IFwiZmluaXNoZWRcIiB8IFwiZXJyb3JcIiA9IFwiYWN0aXZlXCI7XG5cdC8qKlxuXHQgKiBTaXplIG9mIHRoZSBwcm9ncmVzcyBiYXIsIGRlZmF1bHQgaXMgYGJpZ2Bcblx0ICovXG5cdEBJbnB1dCgpIHNpemU6IFwic21hbGxcIiB8IFwiYmlnXCIgPSBcImJpZ1wiO1xuXG5cdEBIb3N0QmluZGluZyhcImNsYXNzLmNkcy0tcHJvZ3Jlc3MtYmFyXCIpIGRlZmF1bHRDbGFzcyA9IHRydWU7XG5cdHByaXZhdGUgX3ZhbHVlID0gdW5kZWZpbmVkO1xuXG5cdGlzVGVtcGxhdGUodmFsdWUpIHtcblx0XHRyZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBUZW1wbGF0ZVJlZjtcblx0fVxufVxuIl19