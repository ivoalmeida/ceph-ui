import { ChangeDetectionStrategy, Component, HostBinding, HostListener, Input, TemplateRef, ViewChild } from "@angular/core";
import { PopoverContainer } from "carbon-components-angular/popover";
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
/**
 * Get started with importing the module:
 *
 * ```typescript
 * import { TooltipModule } from 'carbon-components-angular';
 * ```
 *
 * [See demo](../../?path=/story/components-tooltip--basic)
 */
export class Tooltip extends PopoverContainer {
    constructor(elementRef, ngZone, renderer, changeDetectorRef) {
        super(elementRef, ngZone, renderer, changeDetectorRef);
        this.elementRef = elementRef;
        this.ngZone = ngZone;
        this.renderer = renderer;
        this.changeDetectorRef = changeDetectorRef;
        this.tooltipClass = true;
        this.id = `tooltip-${Tooltip.tooltipCount++}`;
        /**
         * Set delay before tooltip is shown
         */
        this.enterDelayMs = 100;
        /**
         * Set delay when tooltip disappears
         */
        this.leaveDelayMs = 300;
        /**
         * Prevent tooltip from showing, used by icon button
         */
        this.disabled = false;
        this.highContrast = true;
        this.dropShadow = false;
    }
    mouseenter(event) {
        // If a mouseleave is triggered before the tooltip is displayed (before setTimeout of mouseenter completes)
        // we trigger the mouseleave only avoiding having to unecessary show the tooltip
        clearTimeout(this.timeoutId);
        this.timeoutId = setTimeout(() => {
            this.handleChange(true, event);
        }, this.enterDelayMs);
    }
    mouseleave(event) {
        // If a mouseleave is triggered before the tooltip is displayed (before setTimeout of mouseenter completes)
        // we trigger the mouseleave only avoiding having to unecessary show the tooltip
        clearTimeout(this.timeoutId);
        this.timeoutId = setTimeout(() => {
            this.handleChange(false, event);
        }, this.leaveDelayMs);
    }
    hostkeys(event) {
        if (open && event.key === "Escape") {
            event.stopPropagation();
            this.handleChange(false, event);
        }
    }
    // We are not focusing on entire popover, only the trigger
    handleFocus(event) {
        this.handleChange(true, event);
    }
    handleFocusOut(event) {
        this.handleChange(false, event);
    }
    isTemplate(value) {
        return value instanceof TemplateRef;
    }
    /**
     * Close the popover and reopen it with updated values without emitting an event
     * @param changes
     */
    ngOnChanges(changes) {
        // Close and reopen the popover, handle alignment/programmatic open/close
        const originalState = this.isOpen;
        this.handleChange(false);
        // Ignore first change since content is not initialized
        if ((changes.autoAlign && !changes.autoAlign.firstChange)
            || (changes.disabled && !changes.disabled.firstChange && !changes.disabled.currentValue)) {
            /**
             * When `disabled` is `true`, popover content node is removed. So when re-enabling `disabled`,
             * we manually update view so querySelector can detect the popover content node.
             * Otherwise, the position of the popover will be incorrect when autoAlign is enabled.
             */
            this.changeDetectorRef.detectChanges();
            // Reset the inline styles
            this.popoverContentRef = this.elementRef.nativeElement.querySelector(".cds--popover-content");
            this.popoverContentRef.setAttribute("style", "");
            this.caretRef = this.elementRef.nativeElement.querySelector("span.cds--popover-caret");
        }
        this.handleChange(originalState);
    }
    /**
     * Check for any changes in the projected content & apply accessibility attribute if needed
     */
    ngAfterContentChecked() {
        if (this.wrapper) {
            const buttonElement = this.wrapper.nativeElement.querySelector("button");
            if (buttonElement && !buttonElement.getAttribute("aria-labelledby")) {
                buttonElement.setAttribute("aria-labelledby", this.id);
            }
        }
    }
}
Tooltip.tooltipCount = 0;
Tooltip.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: Tooltip, deps: [{ token: i0.ElementRef }, { token: i0.NgZone }, { token: i0.Renderer2 }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
Tooltip.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.3.0", type: Tooltip, selector: "cds-tooltip, ibm-tooltip", inputs: { id: "id", enterDelayMs: "enterDelayMs", leaveDelayMs: "leaveDelayMs", disabled: "disabled", description: "description", templateContext: "templateContext" }, host: { listeners: { "mouseenter": "mouseenter($event)", "mouseleave": "mouseleave($event)", "keyup": "hostkeys($event)", "focusin": "handleFocus($event)", "focusout": "handleFocusOut($event)" }, properties: { "class.cds--tooltip": "this.tooltipClass" } }, viewQueries: [{ propertyName: "wrapper", first: true, predicate: ["contentWrapper"], descendants: true }], usesInheritance: true, usesOnChanges: true, ngImport: i0, template: `
		<span #contentWrapper>
			<ng-content></ng-content>
		</span>
		<span
			*ngIf="description"
			class="cds--popover"
			[id]="id"
			[attr.aria-hidden]="!isOpen"
			role="tooltip">
			<ng-container *ngIf="!disabled">
				<span class="cds--popover-content cds--tooltip-content">
					<ng-container *ngIf="!isTemplate(description)">{{description}}</ng-container>
					<ng-template *ngIf="isTemplate(description)" [ngTemplateOutlet]="description" [ngTemplateOutletContext]="{ $implicit: templateContext }"></ng-template>
					<span *ngIf="autoAlign" class="cds--popover-caret cds--popover--auto-align"></span>
				</span>
				<span *ngIf="!autoAlign" class="cds--popover-caret"></span>
			</ng-container>
		</span>
	`, isInline: true, dependencies: [{ kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: Tooltip, decorators: [{
            type: Component,
            args: [{
                    selector: "cds-tooltip, ibm-tooltip",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: `
		<span #contentWrapper>
			<ng-content></ng-content>
		</span>
		<span
			*ngIf="description"
			class="cds--popover"
			[id]="id"
			[attr.aria-hidden]="!isOpen"
			role="tooltip">
			<ng-container *ngIf="!disabled">
				<span class="cds--popover-content cds--tooltip-content">
					<ng-container *ngIf="!isTemplate(description)">{{description}}</ng-container>
					<ng-template *ngIf="isTemplate(description)" [ngTemplateOutlet]="description" [ngTemplateOutletContext]="{ $implicit: templateContext }"></ng-template>
					<span *ngIf="autoAlign" class="cds--popover-caret cds--popover--auto-align"></span>
				</span>
				<span *ngIf="!autoAlign" class="cds--popover-caret"></span>
			</ng-container>
		</span>
	`
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.NgZone }, { type: i0.Renderer2 }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { tooltipClass: [{
                type: HostBinding,
                args: ["class.cds--tooltip"]
            }], id: [{
                type: Input
            }], enterDelayMs: [{
                type: Input
            }], leaveDelayMs: [{
                type: Input
            }], disabled: [{
                type: Input
            }], description: [{
                type: Input
            }], templateContext: [{
                type: Input
            }], wrapper: [{
                type: ViewChild,
                args: ["contentWrapper"]
            }], mouseenter: [{
                type: HostListener,
                args: ["mouseenter", ["$event"]]
            }], mouseleave: [{
                type: HostListener,
                args: ["mouseleave", ["$event"]]
            }], hostkeys: [{
                type: HostListener,
                args: ["keyup", ["$event"]]
            }], handleFocus: [{
                type: HostListener,
                args: ["focusin", ["$event"]]
            }], handleFocusOut: [{
                type: HostListener,
                args: ["focusout", ["$event"]]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9vbHRpcC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvdG9vbHRpcC90b29sdGlwLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBRU4sdUJBQXVCLEVBRXZCLFNBQVMsRUFFVCxXQUFXLEVBQ1gsWUFBWSxFQUNaLEtBQUssRUFLTCxXQUFXLEVBQ1gsU0FBUyxFQUNULE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLG1DQUFtQyxDQUFDOzs7QUFFckU7Ozs7Ozs7O0dBUUc7QUF5QkgsTUFBTSxPQUFPLE9BQVEsU0FBUSxnQkFBZ0I7SUErQjVDLFlBQ1csVUFBc0IsRUFDdEIsTUFBYyxFQUNkLFFBQW1CLEVBQ25CLGlCQUFvQztRQUU5QyxLQUFLLENBQUMsVUFBVSxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUUsaUJBQWlCLENBQUMsQ0FBQztRQUw3QyxlQUFVLEdBQVYsVUFBVSxDQUFZO1FBQ3RCLFdBQU0sR0FBTixNQUFNLENBQVE7UUFDZCxhQUFRLEdBQVIsUUFBUSxDQUFXO1FBQ25CLHNCQUFpQixHQUFqQixpQkFBaUIsQ0FBbUI7UUFoQ1osaUJBQVksR0FBRyxJQUFJLENBQUM7UUFFOUMsT0FBRSxHQUFHLFdBQVcsT0FBTyxDQUFDLFlBQVksRUFBRSxFQUFFLENBQUM7UUFDbEQ7O1dBRUc7UUFDTSxpQkFBWSxHQUFHLEdBQUcsQ0FBQztRQUM1Qjs7V0FFRztRQUNNLGlCQUFZLEdBQUcsR0FBRyxDQUFDO1FBQzVCOztXQUVHO1FBQ00sYUFBUSxHQUFHLEtBQUssQ0FBQztRQXFCekIsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUM7UUFDekIsSUFBSSxDQUFDLFVBQVUsR0FBRyxLQUFLLENBQUM7SUFDekIsQ0FBQztJQUdELFVBQVUsQ0FBQyxLQUFLO1FBQ2YsMkdBQTJHO1FBQzNHLGdGQUFnRjtRQUNoRixZQUFZLENBQUMs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QURaLE9BQU87d0ZBQVAsT0FBTyxnb0JBckJUOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBbUJUOzJGQUVXLE9BQU87a0JBeEJuQixTQUFTO21CQUFDO29CQUNWLFFBQVEsRUFBRSwwQkFBMEI7b0JBQ3BDLGVBQWUsRUFBRSx1QkFBdUIsQ0FBQyxNQUFNO29CQUMvQyxRQUFRLEVBQUU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFtQlQ7aUJBQ0Q7OEtBSW1DLFlBQVk7c0JBQTlDLFdBQVc7dUJBQUMsb0JBQW9CO2dCQUV4QixFQUFFO3NCQUFWLEtBQUs7Z0JBSUcsWUFBWTtzQkFBcEIsS0FBSztnQkFJRyxZQUFZO3NCQUFwQixLQUFLO2dCQUlHLFFBQVE7c0JBQWhCLEtBQUs7Z0JBSUcsV0FBVztzQkFBbkIsS0FBSztnQkFJRyxlQUFlO3NCQUF2QixLQUFLO2dCQUV1QixPQUFPO3NCQUFuQyxTQUFTO3VCQUFDLGdCQUFnQjtnQkFnQjNCLFVBQVU7c0JBRFQsWUFBWTt1QkFBQyxZQUFZLEVBQUUsQ0FBQyxRQUFRLENBQUM7Z0JBV3RDLFVBQVU7c0JBRFQsWUFBWTt1QkFBQyxZQUFZLEVBQUUsQ0FBQyxRQUFRLENBQUM7Z0JBV3RDLFFBQVE7c0JBRFAsWUFBWTt1QkFBQyxPQUFPLEVBQUUsQ0FBQyxRQUFRLENBQUM7Z0JBVWpDLFdBQVc7c0JBRFYsWUFBWTt1QkFBQyxTQUFTLEVBQUUsQ0FBQyxRQUFRLENBQUM7Z0JBTW5DLGNBQWM7c0JBRGIsWUFBWTt1QkFBQyxVQUFVLEVBQUUsQ0FBQyxRQUFRLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuXHRBZnRlckNvbnRlbnRDaGVja2VkLFxuXHRDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcblx0Q2hhbmdlRGV0ZWN0b3JSZWYsXG5cdENvbXBvbmVudCxcblx0RWxlbWVudFJlZixcblx0SG9zdEJpbmRpbmcsXG5cdEhvc3RMaXN0ZW5lcixcblx0SW5wdXQsXG5cdE5nWm9uZSxcblx0T25DaGFuZ2VzLFxuXHRSZW5kZXJlcjIsXG5cdFNpbXBsZUNoYW5nZXMsXG5cdFRlbXBsYXRlUmVmLFxuXHRWaWV3Q2hpbGRcbn0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcbmltcG9ydCB7IFBvcG92ZXJDb250YWluZXIgfSBmcm9tIFwiY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci9wb3BvdmVyXCI7XG5cbi8qKlxuICogR2V0IHN0YXJ0ZWQgd2l0aCBpbXBvcnRpbmcgdGhlIG1vZHVsZTpcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQgeyBUb29sdGlwTW9kdWxlIH0gZnJvbSAnY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhcic7XG4gKiBgYGBcbiAqXG4gKiBbU2VlIGRlbW9dKC4uLy4uLz9wYXRoPS9zdG9yeS9jb21wb25lbnRzLXRvb2x0aXAtLWJhc2ljKVxuICovXG5AQ29tcG9uZW50KHtcblx0c2VsZWN0b3I6IFwiY2RzLXRvb2x0aXAsIGlibS10b29sdGlwXCIsXG5cdGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuXHR0ZW1wbGF0ZTogYFxuXHRcdDxzcGFuICNjb250ZW50V3JhcHBlcj5cblx0XHRcdDxuZy1jb250ZW50PjwvbmctY29udGVudD5cblx0XHQ8L3NwYW4+XG5cdFx0PHNwYW5cblx0XHRcdCpuZ0lmPVwiZGVzY3JpcHRpb25cIlxuXHRcdFx0Y2xhc3M9XCJjZHMtLXBvcG92ZXJcIlxuXHRcdFx0W2lkXT1cImlkXCJcblx0XHRcdFthdHRyLmFyaWEtaGlkZGVuXT1cIiFpc09wZW5cIlxuXHRcdFx0cm9sZT1cInRvb2x0aXBcIj5cblx0XHRcdDxuZy1jb250YWluZXIgKm5nSWY9XCIhZGlzYWJsZWRcIj5cblx0XHRcdFx0PHNwYW4gY2xhc3M9XCJjZHMtLXBvcG92ZXItY29udGVudCBjZHMtLXRvb2x0aXAtY29udGVudFwiPlxuXHRcdFx0XHRcdDxuZy1jb250YWluZXIgKm5nSWY9XCIhaXNUZW1wbGF0ZShkZXNjcmlwdGlvbilcIj57e2Rlc2NyaXB0aW9ufX08L25nLWNvbnRhaW5lcj5cblx0XHRcdFx0XHQ8bmctdGVtcGxhdGUgKm5nSWY9XCJpc1RlbXBsYXRlKGRlc2NyaXB0aW9uKVwiIFtuZ1RlbXBsYXRlT3V0bGV0XT1cImRlc2NyaXB0aW9uXCIgW25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cInsgJGltcGxpY2l0OiB0ZW1wbGF0ZUNvbnRleHQgfVwiPjwvbmctdGVtcGxhdGU+XG5cdFx0XHRcdFx0PHNwYW4gKm5nSWY9XCJhdXRvQWxpZ25cIiBjbGFzcz1cImNkcy0tcG9wb3Zlci1jYXJldCBjZHMtLXBvcG92ZXItLWF1dG8tYWxpZ25cIj48L3NwYW4+XG5cdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0PHNwYW4gKm5nSWY9XCIhYXV0b0FsaWduXCIgY2xhc3M9XCJjZHMtLXBvcG92ZXItY2FyZXRcIj48L3NwYW4+XG5cdFx0XHQ8L25nLWNvbnRhaW5lcj5cblx0XHQ8L3NwYW4+XG5cdGBcbn0pXG5leHBvcnQgY2xhc3MgVG9vbHRpcCBleHRlbmRzIFBvcG92ZXJDb250YWluZXIgaW1wbGVtZW50cyBPbkNoYW5nZXMsIEFmdGVyQ29udGVudENoZWNrZWQge1xuXHRzdGF0aWMgdG9vbHRpcENvdW50ID0gMDtcblxuXHRASG9zdEJpbmRpbmcoXCJjbGFzcy5jZHMtLXRvb2x0aXBcIikgdG9vbHRpcENsYXNzID0gdHJ1ZTtcblxuXHRASW5wdXQoKSBpZCA9IGB0b29sdGlwLSR7VG9vbHRpcC50b29sdGlwQ291bnQrK31gO1xuXHQvKipcblx0ICogU2V0IGRlbGF5IGJlZm9yZSB0b29sdGlwIGlzIHNob3duXG5cdCAqL1xuXHRASW5wdXQoKSBlbnRlckRlbGF5TXMgPSAxMDA7XG5cdC8qKlxuXHQgKiBTZXQgZGVsYXkgd2hlbiB0b29sdGlwIGRpc2FwcGVhcnNcblx0ICovXG5cdEBJbnB1dCgpIGxlYXZlRGVsYXlNcyA9IDMwMDtcblx0LyoqXG5cdCAqIFByZXZlbnQgdG9vbHRpcCBmcm9tIHNob3dpbmcsIHVzZWQgYnkgaWNvbiBidXR0b25cblx0ICovXG5cdEBJbnB1dCgpIGRpc2FibGVkID0gZmFsc2U7XG5cdC8qKlxuXHQgKiBUaGUgc3RyaW5nIG9yIHRlbXBsYXRlIGNvbnRlbnQgdG8gYmUgZXhwb3NlZCBieSB0aGUgdG9vbHRpcC5cblx0ICovXG5cdEBJbnB1dCgpIGRlc2NyaXB0aW9uOiBzdHJpbmcgfCBUZW1wbGF0ZVJlZjxhbnk+O1xuXHQvKipcblx0ICogT3B0aW9uYWwgZGF0YSBmb3IgdGVtcGxhdGVzIHBhc3NlZCBhcyBpbXBsaWNpdCBjb250ZXh0XG5cdCAqL1xuXHRASW5wdXQoKSB0ZW1wbGF0ZUNvbnRleHQ6IGFueTtcblxuXHRAVmlld0NoaWxkKFwiY29udGVudFdyYXBwZXJcIikgd3JhcHBlcjogRWxlbWVudFJlZjxIVE1MU3BhbkVsZW1lbnQ+O1xuXG5cdHByaXZhdGUgdGltZW91dElkOiBhbnk7IC8vIGl0IHNob3VsZCBiZSBudW1iZXIsIGJ1dCBzZXRUaW1lb3V0IGJlbG93IGlzIG1hdGNoaW5nIHRoZSBOb2RlSnMgdHlwZSBpbnN0ZWFkIG9mIHRoZSBKUyB0eXBlXG5cblx0Y29uc3RydWN0b3IoXG5cdFx0cHJvdGVjdGVkIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsXG5cdFx0cHJvdGVjdGVkIG5nWm9uZTogTmdab25lLFxuXHRcdHByb3RlY3RlZCByZW5kZXJlcjogUmVuZGVyZXIyLFxuXHRcdHByb3RlY3RlZCBjaGFuZ2VEZXRlY3RvclJlZjogQ2hhbmdlRGV0ZWN0b3JSZWZcblx0KSB7XG5cdFx0c3VwZXIoZWxlbWVudFJlZiwgbmdab25lLCByZW5kZXJlciwgY2hhbmdlRGV0ZWN0b3JSZWYpO1xuXHRcdHRoaXMuaGlnaENvbnRyYXN0ID0gdHJ1ZTtcblx0XHR0aGlzLmRyb3BTaGFkb3cgPSBmYWxzZTtcblx0fVxuXG5cdEBIb3N0TGlzdGVuZXIoXCJtb3VzZWVudGVyXCIsIFtcIiRldmVudFwiXSlcblx0bW91c2VlbnRlcihldmVudCkge1xuXHRcdC8vIElmIGEgbW91c2VsZWF2ZSBpcyB0cmlnZ2VyZWQgYmVmb3JlIHRoZSB0b29sdGlwIGlzIGRpc3BsYXllZCAoYmVmb3JlIHNldFRpbWVvdXQgb2YgbW91c2VlbnRlciBjb21wbGV0ZXMpXG5cdFx0Ly8gd2UgdHJpZ2dlciB0aGUgbW91c2VsZWF2ZSBvbmx5IGF2b2lkaW5nIGhhdmluZyB0byB1bmVjZXNzYXJ5IHNob3cgdGhlIHRvb2x0aXBcblx0XHRjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0SWQpO1xuXHRcdHRoaXMudGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHR0aGlzLmhhbmRsZUNoYW5nZSh0cnVlLCBldmVudCk7XG5cdFx0fSwgdGhpcy5lbnRlckRlbGF5TXMpO1xuXHR9XG5cblx0QEhvc3RMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgW1wiJGV2ZW50XCJdKVxuXHRtb3VzZWxlYXZlKGV2ZW50KSB7XG5cdFx0Ly8gSWYgYSBtb3VzZWxlYXZlIGlzIHRyaWdnZXJlZCBiZWZvcmUgdGhlIHRvb2x0aXAgaXMgZGlzcGxheWVkIChiZWZvcmUgc2V0VGltZW91dCBvZiBtb3VzZWVudGVyIGNvbXBsZXRlcylcblx0XHQvLyB3ZSB0cmlnZ2VyIHRoZSBtb3VzZWxlYXZlIG9ubHkgYXZvaWRpbmcgaGF2aW5nIHRvIHVuZWNlc3Nhcnkgc2hvdyB0aGUgdG9vbHRpcFxuXHRcdGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJZCk7XG5cdFx0dGhpcy50aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdHRoaXMuaGFuZGxlQ2hhbmdlKGZhbHNlLCBldmVudCk7XG5cdFx0fSwgdGhpcy5sZWF2ZURlbGF5TXMpO1xuXHR9XG5cblx0QEhvc3RMaXN0ZW5lcihcImtleXVwXCIsIFtcIiRldmVudFwiXSlcblx0aG9zdGtleXMoZXZlbnQ6IEtleWJvYXJkRXZlbnQpIHtcblx0XHRpZiAob3BlbiAmJiBldmVudC5rZXkgPT09IFwiRXNjYXBlXCIpIHtcblx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0dGhpcy5oYW5kbGVDaGFuZ2UoZmFsc2UsIGV2ZW50KTtcblx0XHR9XG5cdH1cblxuXHQvLyBXZSBhcmUgbm90IGZvY3VzaW5nIG9uIGVudGlyZSBwb3BvdmVyLCBvbmx5IHRoZSB0cmlnZ2VyXG5cdEBIb3N0TGlzdGVuZXIoXCJmb2N1c2luXCIsIFtcIiRldmVudFwiXSlcblx0aGFuZGxlRm9jdXMoZXZlbnQ6IEV2ZW50KSB7XG5cdFx0dGhpcy5oYW5kbGVDaGFuZ2UodHJ1ZSwgZXZlbnQpO1xuXHR9XG5cblx0QEhvc3RMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIFtcIiRldmVudFwiXSlcblx0aGFuZGxlRm9jdXNPdXQoZXZlbnQ6IEV2ZW50KSB7XG5cdFx0dGhpcy5oYW5kbGVDaGFuZ2UoZmFsc2UsIGV2ZW50KTtcblx0fVxuXG5cdGlzVGVtcGxhdGUodmFsdWUpIHtcblx0XHRyZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBUZW1wbGF0ZVJlZjtcblx0fVxuXG5cdC8qKlxuXHQgKiBDbG9zZSB0aGUgcG9wb3ZlciBhbmQgcmVvcGVuIGl0IHdpdGggdXBkYXRlZCB2YWx1ZXMgd2l0aG91dCBlbWl0dGluZyBhbiBldmVudFxuXHQgKiBAcGFyYW0gY2hhbmdlc1xuXHQgKi9cblx0bmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xuXHRcdC8vIENsb3NlIGFuZCByZW9wZW4gdGhlIHBvcG92ZXIsIGhhbmRsZSBhbGlnbm1lbnQvcHJvZ3JhbW1hdGljIG9wZW4vY2xvc2Vcblx0XHRjb25zdCBvcmlnaW5hbFN0YXRlID0gdGhpcy5pc09wZW47XG5cdFx0dGhpcy5oYW5kbGVDaGFuZ2UoZmFsc2UpO1xuXG5cdFx0Ly8gSWdub3JlIGZpcnN0IGNoYW5nZSBzaW5jZSBjb250ZW50IGlzIG5vdCBpbml0aWFsaXplZFxuXHRcdGlmICgoY2hhbmdlcy5hdXRvQWxpZ24gJiYgIWNoYW5nZXMuYXV0b0FsaWduLmZpcnN0Q2hhbmdlKVxuXHRcdFx0fHwgKGNoYW5nZXMuZGlzYWJsZWQgJiYgIWNoYW5nZXMuZGlzYWJsZWQuZmlyc3RDaGFuZ2UgJiYgIWNoYW5nZXMuZGlzYWJsZWQuY3VycmVudFZhbHVlKSkge1xuXHRcdFx0LyoqXG5cdFx0XHQgKiBXaGVuIGBkaXNhYmxlZGAgaXMgYHRydWVgLCBwb3BvdmVyIGNvbnRlbnQgbm9kZSBpcyByZW1vdmVkLiBTbyB3aGVuIHJlLWVuYWJsaW5nIGBkaXNhYmxlZGAsXG5cdFx0XHQgKiB3ZSBtYW51YWxseSB1cGRhdGUgdmlldyBzbyBxdWVyeVNlbGVjdG9yIGNhbiBkZXRlY3QgdGhlIHBvcG92ZXIgY29udGVudCBub2RlLlxuXHRcdFx0ICogT3RoZXJ3aXNlLCB0aGUgcG9zaXRpb24gb2YgdGhlIHBvcG92ZXIgd2lsbCBiZSBpbmNvcnJlY3Qgd2hlbiBhdXRvQWxpZ24gaXMgZW5hYmxlZC5cblx0XHRcdCAqL1xuXHRcdFx0dGhpcy5jaGFuZ2VEZXRlY3RvclJlZi5kZXRlY3RDaGFuZ2VzKCk7XG5cblx0XHRcdC8vIFJlc2V0IHRoZSBpbmxpbmUgc3R5bGVzXG5cdFx0XHR0aGlzLnBvcG92ZXJDb250ZW50UmVmID0gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcihcIi5jZHMtLXBvcG92ZXItY29udGVudFwiKTtcblx0XHRcdHRoaXMucG9wb3ZlckNvbnRlbnRSZWYuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgXCJcIik7XG5cdFx0XHR0aGlzLmNhcmV0UmVmID0gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcihcInNwYW4uY2RzLS1wb3BvdmVyLWNhcmV0XCIpO1xuXHRcdH1cblxuXHRcdHRoaXMuaGFuZGxlQ2hhbmdlKG9yaWdpbmFsU3RhdGUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrIGZvciBhbnkgY2hhbmdlcyBpbiB0aGUgcHJvamVjdGVkIGNvbnRlbnQgJiBhcHBseSBhY2Nlc3NpYmlsaXR5IGF0dHJpYnV0ZSBpZiBuZWVkZWRcblx0ICovXG5cdG5nQWZ0ZXJDb250ZW50Q2hlY2tlZCgpIHtcblx0XHRpZiAodGhpcy53cmFwcGVyKSB7XG5cdFx0XHRjb25zdCBidXR0b25FbGVtZW50ID0gdGhpcy53cmFwcGVyLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcihcImJ1dHRvblwiKTtcblx0XHRcdGlmIChidXR0b25FbGVtZW50ICYmICFidXR0b25FbGVtZW50LmdldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxsZWRieVwiKSkge1xuXHRcdFx0XHRidXR0b25FbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxsZWRieVwiLCB0aGlzLmlkKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cbiJdfQ==